// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `EvolveBuild.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:PPKHGCHPCLC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PPKHGCHPCLC {
    // message fields
    // @@protoc_insertion_point(field:PPKHGCHPCLC.EMECLFMNJIA)
    pub EMECLFMNJIA: u32,
    // @@protoc_insertion_point(field:PPKHGCHPCLC.KMHGILBNPIN)
    pub KMHGILBNPIN: u32,
    // special fields
    // @@protoc_insertion_point(special_field:PPKHGCHPCLC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PPKHGCHPCLC {
    fn default() -> &'a PPKHGCHPCLC {
        <PPKHGCHPCLC as ::protobuf::Message>::default_instance()
    }
}

impl PPKHGCHPCLC {
    pub fn new() -> PPKHGCHPCLC {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "EMECLFMNJIA",
            |m: &PPKHGCHPCLC| { &m.EMECLFMNJIA },
            |m: &mut PPKHGCHPCLC| { &mut m.EMECLFMNJIA },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "KMHGILBNPIN",
            |m: &PPKHGCHPCLC| { &m.KMHGILBNPIN },
            |m: &mut PPKHGCHPCLC| { &mut m.KMHGILBNPIN },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PPKHGCHPCLC>(
            "PPKHGCHPCLC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PPKHGCHPCLC {
    const NAME: &'static str = "PPKHGCHPCLC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.EMECLFMNJIA = is.read_uint32()?;
                },
                16 => {
                    self.KMHGILBNPIN = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.EMECLFMNJIA != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.EMECLFMNJIA);
        }
        if self.KMHGILBNPIN != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.KMHGILBNPIN);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.EMECLFMNJIA != 0 {
            os.write_uint32(1, self.EMECLFMNJIA)?;
        }
        if self.KMHGILBNPIN != 0 {
            os.write_uint32(2, self.KMHGILBNPIN)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PPKHGCHPCLC {
        PPKHGCHPCLC::new()
    }

    fn clear(&mut self) {
        self.EMECLFMNJIA = 0;
        self.KMHGILBNPIN = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PPKHGCHPCLC {
        static instance: PPKHGCHPCLC = PPKHGCHPCLC {
            EMECLFMNJIA: 0,
            KMHGILBNPIN: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PPKHGCHPCLC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PPKHGCHPCLC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PPKHGCHPCLC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PPKHGCHPCLC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EvolveBuildEquip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EvolveBuildEquip {
    // message fields
    // @@protoc_insertion_point(field:EvolveBuildEquip.OKFLGFJJJBI)
    pub OKFLGFJJJBI: u32,
    // @@protoc_insertion_point(field:EvolveBuildEquip.LIBMPHILENJ)
    pub LIBMPHILENJ: bool,
    // @@protoc_insertion_point(field:EvolveBuildEquip.MNKDHNHKPGC)
    pub MNKDHNHKPGC: ::protobuf::MessageField<PPKHGCHPCLC>,
    // special fields
    // @@protoc_insertion_point(special_field:EvolveBuildEquip.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EvolveBuildEquip {
    fn default() -> &'a EvolveBuildEquip {
        <EvolveBuildEquip as ::protobuf::Message>::default_instance()
    }
}

impl EvolveBuildEquip {
    pub fn new() -> EvolveBuildEquip {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OKFLGFJJJBI",
            |m: &EvolveBuildEquip| { &m.OKFLGFJJJBI },
            |m: &mut EvolveBuildEquip| { &mut m.OKFLGFJJJBI },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LIBMPHILENJ",
            |m: &EvolveBuildEquip| { &m.LIBMPHILENJ },
            |m: &mut EvolveBuildEquip| { &mut m.LIBMPHILENJ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PPKHGCHPCLC>(
            "MNKDHNHKPGC",
            |m: &EvolveBuildEquip| { &m.MNKDHNHKPGC },
            |m: &mut EvolveBuildEquip| { &mut m.MNKDHNHKPGC },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EvolveBuildEquip>(
            "EvolveBuildEquip",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EvolveBuildEquip {
    const NAME: &'static str = "EvolveBuildEquip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.OKFLGFJJJBI = is.read_uint32()?;
                },
                16 => {
                    self.LIBMPHILENJ = is.read_bool()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.MNKDHNHKPGC)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.OKFLGFJJJBI != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.OKFLGFJJJBI);
        }
        if self.LIBMPHILENJ != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.MNKDHNHKPGC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.OKFLGFJJJBI != 0 {
            os.write_uint32(1, self.OKFLGFJJJBI)?;
        }
        if self.LIBMPHILENJ != false {
            os.write_bool(2, self.LIBMPHILENJ)?;
        }
        if let Some(v) = self.MNKDHNHKPGC.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EvolveBuildEquip {
        EvolveBuildEquip::new()
    }

    fn clear(&mut self) {
        self.OKFLGFJJJBI = 0;
        self.LIBMPHILENJ = false;
        self.MNKDHNHKPGC.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EvolveBuildEquip {
        static instance: EvolveBuildEquip = EvolveBuildEquip {
            OKFLGFJJJBI: 0,
            LIBMPHILENJ: false,
            MNKDHNHKPGC: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EvolveBuildEquip {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EvolveBuildEquip").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EvolveBuildEquip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvolveBuildEquip {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EvolveBuildCard)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EvolveBuildCard {
    // message fields
    // @@protoc_insertion_point(field:EvolveBuildCard.card_id)
    pub card_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:EvolveBuildCard.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EvolveBuildCard {
    fn default() -> &'a EvolveBuildCard {
        <EvolveBuildCard as ::protobuf::Message>::default_instance()
    }
}

impl EvolveBuildCard {
    pub fn new() -> EvolveBuildCard {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "card_id",
            |m: &EvolveBuildCard| { &m.card_id },
            |m: &mut EvolveBuildCard| { &mut m.card_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EvolveBuildCard>(
            "EvolveBuildCard",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EvolveBuildCard {
    const NAME: &'static str = "EvolveBuildCard";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.card_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.card_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.card_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.card_id != 0 {
            os.write_uint32(1, self.card_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EvolveBuildCard {
        EvolveBuildCard::new()
    }

    fn clear(&mut self) {
        self.card_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EvolveBuildCard {
        static instance: EvolveBuildCard = EvolveBuildCard {
            card_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EvolveBuildCard {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EvolveBuildCard").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EvolveBuildCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvolveBuildCard {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EvolveBuildGearDamageInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EvolveBuildGearDamageInfo {
    // message fields
    // @@protoc_insertion_point(field:EvolveBuildGearDamageInfo.GearId)
    pub GearId: u32,
    // @@protoc_insertion_point(field:EvolveBuildGearDamageInfo.Damage)
    pub Damage: f64,
    // @@protoc_insertion_point(field:EvolveBuildGearDamageInfo.HpDamage)
    pub HpDamage: f64,
    // special fields
    // @@protoc_insertion_point(special_field:EvolveBuildGearDamageInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EvolveBuildGearDamageInfo {
    fn default() -> &'a EvolveBuildGearDamageInfo {
        <EvolveBuildGearDamageInfo as ::protobuf::Message>::default_instance()
    }
}

impl EvolveBuildGearDamageInfo {
    pub fn new() -> EvolveBuildGearDamageInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "GearId",
            |m: &EvolveBuildGearDamageInfo| { &m.GearId },
            |m: &mut EvolveBuildGearDamageInfo| { &mut m.GearId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Damage",
            |m: &EvolveBuildGearDamageInfo| { &m.Damage },
            |m: &mut EvolveBuildGearDamageInfo| { &mut m.Damage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "HpDamage",
            |m: &EvolveBuildGearDamageInfo| { &m.HpDamage },
            |m: &mut EvolveBuildGearDamageInfo| { &mut m.HpDamage },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EvolveBuildGearDamageInfo>(
            "EvolveBuildGearDamageInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EvolveBuildGearDamageInfo {
    const NAME: &'static str = "EvolveBuildGearDamageInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.GearId = is.read_uint32()?;
                },
                17 => {
                    self.Damage = is.read_double()?;
                },
                25 => {
                    self.HpDamage = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.GearId != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.GearId);
        }
        if self.Damage != 0. {
            my_size += 1 + 8;
        }
        if self.HpDamage != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.GearId != 0 {
            os.write_uint32(1, self.GearId)?;
        }
        if self.Damage != 0. {
            os.write_double(2, self.Damage)?;
        }
        if self.HpDamage != 0. {
            os.write_double(3, self.HpDamage)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EvolveBuildGearDamageInfo {
        EvolveBuildGearDamageInfo::new()
    }

    fn clear(&mut self) {
        self.GearId = 0;
        self.Damage = 0.;
        self.HpDamage = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EvolveBuildGearDamageInfo {
        static instance: EvolveBuildGearDamageInfo = EvolveBuildGearDamageInfo {
            GearId: 0,
            Damage: 0.,
            HpDamage: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EvolveBuildGearDamageInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EvolveBuildGearDamageInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EvolveBuildGearDamageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvolveBuildGearDamageInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EvolveBuildGearCollection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EvolveBuildGearCollection {
    // message fields
    // @@protoc_insertion_point(field:EvolveBuildGearCollection.OADLCKECIPM)
    pub OADLCKECIPM: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:EvolveBuildGearCollection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EvolveBuildGearCollection {
    fn default() -> &'a EvolveBuildGearCollection {
        <EvolveBuildGearCollection as ::protobuf::Message>::default_instance()
    }
}

impl EvolveBuildGearCollection {
    pub fn new() -> EvolveBuildGearCollection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "OADLCKECIPM",
            |m: &EvolveBuildGearCollection| { &m.OADLCKECIPM },
            |m: &mut EvolveBuildGearCollection| { &mut m.OADLCKECIPM },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EvolveBuildGearCollection>(
            "EvolveBuildGearCollection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EvolveBuildGearCollection {
    const NAME: &'static str = "EvolveBuildGearCollection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.OADLCKECIPM)?;
                },
                8 => {
                    self.OADLCKECIPM.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.OADLCKECIPM {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.OADLCKECIPM {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EvolveBuildGearCollection {
        EvolveBuildGearCollection::new()
    }

    fn clear(&mut self) {
        self.OADLCKECIPM.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EvolveBuildGearCollection {
        static instance: EvolveBuildGearCollection = EvolveBuildGearCollection {
            OADLCKECIPM: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EvolveBuildGearCollection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EvolveBuildGearCollection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EvolveBuildGearCollection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvolveBuildGearCollection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EvolveBuildStat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EvolveBuildStat {
    // message fields
    // @@protoc_insertion_point(field:EvolveBuildStat.KMBODLBAMND)
    pub KMBODLBAMND: u32,
    // @@protoc_insertion_point(field:EvolveBuildStat.OGGKLHIKOBO)
    pub OGGKLHIKOBO: u32,
    // @@protoc_insertion_point(field:EvolveBuildStat.IDKFHDLLLDA)
    pub IDKFHDLLLDA: u32,
    // @@protoc_insertion_point(field:EvolveBuildStat.FCKMBLINDLO)
    pub FCKMBLINDLO: ::std::vec::Vec<PPKHGCHPCLC>,
    // @@protoc_insertion_point(field:EvolveBuildStat.FIPGHGJBBEA)
    pub FIPGHGJBBEA: f32,
    // special fields
    // @@protoc_insertion_point(special_field:EvolveBuildStat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EvolveBuildStat {
    fn default() -> &'a EvolveBuildStat {
        <EvolveBuildStat as ::protobuf::Message>::default_instance()
    }
}

impl EvolveBuildStat {
    pub fn new() -> EvolveBuildStat {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "KMBODLBAMND",
            |m: &EvolveBuildStat| { &m.KMBODLBAMND },
            |m: &mut EvolveBuildStat| { &mut m.KMBODLBAMND },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OGGKLHIKOBO",
            |m: &EvolveBuildStat| { &m.OGGKLHIKOBO },
            |m: &mut EvolveBuildStat| { &mut m.OGGKLHIKOBO },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "IDKFHDLLLDA",
            |m: &EvolveBuildStat| { &m.IDKFHDLLLDA },
            |m: &mut EvolveBuildStat| { &mut m.IDKFHDLLLDA },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "FCKMBLINDLO",
            |m: &EvolveBuildStat| { &m.FCKMBLINDLO },
            |m: &mut EvolveBuildStat| { &mut m.FCKMBLINDLO },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "FIPGHGJBBEA",
            |m: &EvolveBuildStat| { &m.FIPGHGJBBEA },
            |m: &mut EvolveBuildStat| { &mut m.FIPGHGJBBEA },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EvolveBuildStat>(
            "EvolveBuildStat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EvolveBuildStat {
    const NAME: &'static str = "EvolveBuildStat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.KMBODLBAMND = is.read_uint32()?;
                },
                16 => {
                    self.OGGKLHIKOBO = is.read_uint32()?;
                },
                24 => {
                    self.IDKFHDLLLDA = is.read_uint32()?;
                },
                34 => {
                    self.FCKMBLINDLO.push(is.read_message()?);
                },
                45 => {
                    self.FIPGHGJBBEA = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.KMBODLBAMND != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.KMBODLBAMND);
        }
        if self.OGGKLHIKOBO != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.OGGKLHIKOBO);
        }
        if self.IDKFHDLLLDA != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.IDKFHDLLLDA);
        }
        for value in &self.FCKMBLINDLO {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.FIPGHGJBBEA != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.KMBODLBAMND != 0 {
            os.write_uint32(1, self.KMBODLBAMND)?;
        }
        if self.OGGKLHIKOBO != 0 {
            os.write_uint32(2, self.OGGKLHIKOBO)?;
        }
        if self.IDKFHDLLLDA != 0 {
            os.write_uint32(3, self.IDKFHDLLLDA)?;
        }
        for v in &self.FCKMBLINDLO {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if self.FIPGHGJBBEA != 0. {
            os.write_float(5, self.FIPGHGJBBEA)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EvolveBuildStat {
        EvolveBuildStat::new()
    }

    fn clear(&mut self) {
        self.KMBODLBAMND = 0;
        self.OGGKLHIKOBO = 0;
        self.IDKFHDLLLDA = 0;
        self.FCKMBLINDLO.clear();
        self.FIPGHGJBBEA = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EvolveBuildStat {
        static instance: EvolveBuildStat = EvolveBuildStat {
            KMBODLBAMND: 0,
            OGGKLHIKOBO: 0,
            IDKFHDLLLDA: 0,
            FCKMBLINDLO: ::std::vec::Vec::new(),
            FIPGHGJBBEA: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EvolveBuildStat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EvolveBuildStat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EvolveBuildStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvolveBuildStat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EvolveBuildStatInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EvolveBuildStatInfo {
    // message fields
    // @@protoc_insertion_point(field:EvolveBuildStatInfo.JFNKBMGCLLG)
    pub JFNKBMGCLLG: u32,
    // @@protoc_insertion_point(field:EvolveBuildStatInfo.HMKPLAJNJPI)
    pub HMKPLAJNJPI: ::std::vec::Vec<EvolveBuildStat>,
    // special fields
    // @@protoc_insertion_point(special_field:EvolveBuildStatInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EvolveBuildStatInfo {
    fn default() -> &'a EvolveBuildStatInfo {
        <EvolveBuildStatInfo as ::protobuf::Message>::default_instance()
    }
}

impl EvolveBuildStatInfo {
    pub fn new() -> EvolveBuildStatInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "JFNKBMGCLLG",
            |m: &EvolveBuildStatInfo| { &m.JFNKBMGCLLG },
            |m: &mut EvolveBuildStatInfo| { &mut m.JFNKBMGCLLG },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "HMKPLAJNJPI",
            |m: &EvolveBuildStatInfo| { &m.HMKPLAJNJPI },
            |m: &mut EvolveBuildStatInfo| { &mut m.HMKPLAJNJPI },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EvolveBuildStatInfo>(
            "EvolveBuildStatInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EvolveBuildStatInfo {
    const NAME: &'static str = "EvolveBuildStatInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.JFNKBMGCLLG = is.read_uint32()?;
                },
                18 => {
                    self.HMKPLAJNJPI.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.JFNKBMGCLLG != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.JFNKBMGCLLG);
        }
        for value in &self.HMKPLAJNJPI {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.JFNKBMGCLLG != 0 {
            os.write_uint32(1, self.JFNKBMGCLLG)?;
        }
        for v in &self.HMKPLAJNJPI {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EvolveBuildStatInfo {
        EvolveBuildStatInfo::new()
    }

    fn clear(&mut self) {
        self.JFNKBMGCLLG = 0;
        self.HMKPLAJNJPI.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EvolveBuildStatInfo {
        static instance: EvolveBuildStatInfo = EvolveBuildStatInfo {
            JFNKBMGCLLG: 0,
            HMKPLAJNJPI: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EvolveBuildStatInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EvolveBuildStatInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EvolveBuildStatInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvolveBuildStatInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EvolveBuildBattleInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EvolveBuildBattleInfo {
    // message fields
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.CurLevelId)
    pub CurLevelId: u32,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.CurPeriod)
    pub CurPeriod: u32,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.CurCoin)
    pub CurCoin: u32,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.WeaponSlotList)
    pub WeaponSlotList: ::std::vec::Vec<EvolveBuildEquip>,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.AccessorySlotList)
    pub AccessorySlotList: ::std::vec::Vec<EvolveBuildEquip>,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.BanGearList)
    pub BanGearList: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.Collection)
    pub Collection: ::protobuf::MessageField<EvolveBuildGearCollection>,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.AllowedGearList)
    pub AllowedGearList: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.CurExp)
    pub CurExp: u32,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.CurReroll)
    pub CurReroll: u32,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.CurTreasureMissCnt)
    pub CurTreasureMissCnt: u32,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.PeriodIdList)
    pub PeriodIdList: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.CurGearLostCnt)
    pub CurGearLostCnt: u32,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.CurWave)
    pub CurWave: u32,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.IsUnlockGearReroll)
    pub IsUnlockGearReroll: bool,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.IsUnlockGearBan)
    pub IsUnlockGearBan: bool,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.CardList)
    pub CardList: ::std::vec::Vec<EvolveBuildCard>,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.GearDamageList)
    pub GearDamageList: ::std::vec::Vec<EvolveBuildGearDamageInfo>,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.StatParams)
    pub StatParams: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.IsGiveup)
    pub IsGiveup: bool,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.CurUnusedRoundCnt)
    pub CurUnusedRoundCnt: u32,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.StatLogInfo)
    pub StatLogInfo: ::protobuf::MessageField<EvolveBuildStatInfo>,
    // @@protoc_insertion_point(field:EvolveBuildBattleInfo.PeriodFirstRandomSeed)
    pub PeriodFirstRandomSeed: u32,
    // special fields
    // @@protoc_insertion_point(special_field:EvolveBuildBattleInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EvolveBuildBattleInfo {
    fn default() -> &'a EvolveBuildBattleInfo {
        <EvolveBuildBattleInfo as ::protobuf::Message>::default_instance()
    }
}

impl EvolveBuildBattleInfo {
    pub fn new() -> EvolveBuildBattleInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(23);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CurLevelId",
            |m: &EvolveBuildBattleInfo| { &m.CurLevelId },
            |m: &mut EvolveBuildBattleInfo| { &mut m.CurLevelId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CurPeriod",
            |m: &EvolveBuildBattleInfo| { &m.CurPeriod },
            |m: &mut EvolveBuildBattleInfo| { &mut m.CurPeriod },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CurCoin",
            |m: &EvolveBuildBattleInfo| { &m.CurCoin },
            |m: &mut EvolveBuildBattleInfo| { &mut m.CurCoin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "WeaponSlotList",
            |m: &EvolveBuildBattleInfo| { &m.WeaponSlotList },
            |m: &mut EvolveBuildBattleInfo| { &mut m.WeaponSlotList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "AccessorySlotList",
            |m: &EvolveBuildBattleInfo| { &m.AccessorySlotList },
            |m: &mut EvolveBuildBattleInfo| { &mut m.AccessorySlotList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "BanGearList",
            |m: &EvolveBuildBattleInfo| { &m.BanGearList },
            |m: &mut EvolveBuildBattleInfo| { &mut m.BanGearList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EvolveBuildGearCollection>(
            "Collection",
            |m: &EvolveBuildBattleInfo| { &m.Collection },
            |m: &mut EvolveBuildBattleInfo| { &mut m.Collection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "AllowedGearList",
            |m: &EvolveBuildBattleInfo| { &m.AllowedGearList },
            |m: &mut EvolveBuildBattleInfo| { &mut m.AllowedGearList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CurExp",
            |m: &EvolveBuildBattleInfo| { &m.CurExp },
            |m: &mut EvolveBuildBattleInfo| { &mut m.CurExp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CurReroll",
            |m: &EvolveBuildBattleInfo| { &m.CurReroll },
            |m: &mut EvolveBuildBattleInfo| { &mut m.CurReroll },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CurTreasureMissCnt",
            |m: &EvolveBuildBattleInfo| { &m.CurTreasureMissCnt },
            |m: &mut EvolveBuildBattleInfo| { &mut m.CurTreasureMissCnt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "PeriodIdList",
            |m: &EvolveBuildBattleInfo| { &m.PeriodIdList },
            |m: &mut EvolveBuildBattleInfo| { &mut m.PeriodIdList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CurGearLostCnt",
            |m: &EvolveBuildBattleInfo| { &m.CurGearLostCnt },
            |m: &mut EvolveBuildBattleInfo| { &mut m.CurGearLostCnt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CurWave",
            |m: &EvolveBuildBattleInfo| { &m.CurWave },
            |m: &mut EvolveBuildBattleInfo| { &mut m.CurWave },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "IsUnlockGearReroll",
            |m: &EvolveBuildBattleInfo| { &m.IsUnlockGearReroll },
            |m: &mut EvolveBuildBattleInfo| { &mut m.IsUnlockGearReroll },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "IsUnlockGearBan",
            |m: &EvolveBuildBattleInfo| { &m.IsUnlockGearBan },
            |m: &mut EvolveBuildBattleInfo| { &mut m.IsUnlockGearBan },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "CardList",
            |m: &EvolveBuildBattleInfo| { &m.CardList },
            |m: &mut EvolveBuildBattleInfo| { &mut m.CardList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "GearDamageList",
            |m: &EvolveBuildBattleInfo| { &m.GearDamageList },
            |m: &mut EvolveBuildBattleInfo| { &mut m.GearDamageList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "StatParams",
            |m: &EvolveBuildBattleInfo| { &m.StatParams },
            |m: &mut EvolveBuildBattleInfo| { &mut m.StatParams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "IsGiveup",
            |m: &EvolveBuildBattleInfo| { &m.IsGiveup },
            |m: &mut EvolveBuildBattleInfo| { &mut m.IsGiveup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CurUnusedRoundCnt",
            |m: &EvolveBuildBattleInfo| { &m.CurUnusedRoundCnt },
            |m: &mut EvolveBuildBattleInfo| { &mut m.CurUnusedRoundCnt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EvolveBuildStatInfo>(
            "StatLogInfo",
            |m: &EvolveBuildBattleInfo| { &m.StatLogInfo },
            |m: &mut EvolveBuildBattleInfo| { &mut m.StatLogInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PeriodFirstRandomSeed",
            |m: &EvolveBuildBattleInfo| { &m.PeriodFirstRandomSeed },
            |m: &mut EvolveBuildBattleInfo| { &mut m.PeriodFirstRandomSeed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EvolveBuildBattleInfo>(
            "EvolveBuildBattleInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EvolveBuildBattleInfo {
    const NAME: &'static str = "EvolveBuildBattleInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.CurLevelId = is.read_uint32()?;
                },
                16 => {
                    self.CurPeriod = is.read_uint32()?;
                },
                24 => {
                    self.CurCoin = is.read_uint32()?;
                },
                34 => {
                    self.WeaponSlotList.push(is.read_message()?);
                },
                42 => {
                    self.AccessorySlotList.push(is.read_message()?);
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.BanGearList)?;
                },
                48 => {
                    self.BanGearList.push(is.read_uint32()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Collection)?;
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.AllowedGearList)?;
                },
                64 => {
                    self.AllowedGearList.push(is.read_uint32()?);
                },
                72 => {
                    self.CurExp = is.read_uint32()?;
                },
                80 => {
                    self.CurReroll = is.read_uint32()?;
                },
                88 => {
                    self.CurTreasureMissCnt = is.read_uint32()?;
                },
                98 => {
                    is.read_repeated_packed_uint32_into(&mut self.PeriodIdList)?;
                },
                96 => {
                    self.PeriodIdList.push(is.read_uint32()?);
                },
                104 => {
                    self.CurGearLostCnt = is.read_uint32()?;
                },
                112 => {
                    self.CurWave = is.read_uint32()?;
                },
                120 => {
                    self.IsUnlockGearReroll = is.read_bool()?;
                },
                128 => {
                    self.IsUnlockGearBan = is.read_bool()?;
                },
                138 => {
                    self.CardList.push(is.read_message()?);
                },
                146 => {
                    self.GearDamageList.push(is.read_message()?);
                },
                154 => {
                    is.read_repeated_packed_uint32_into(&mut self.StatParams)?;
                },
                152 => {
                    self.StatParams.push(is.read_uint32()?);
                },
                160 => {
                    self.IsGiveup = is.read_bool()?;
                },
                168 => {
                    self.CurUnusedRoundCnt = is.read_uint32()?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.StatLogInfo)?;
                },
                184 => {
                    self.PeriodFirstRandomSeed = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.CurLevelId != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.CurLevelId);
        }
        if self.CurPeriod != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.CurPeriod);
        }
        if self.CurCoin != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.CurCoin);
        }
        for value in &self.WeaponSlotList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.AccessorySlotList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.BanGearList {
            my_size += ::protobuf::rt::uint32_size(6, *value);
        };
        if let Some(v) = self.Collection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.AllowedGearList {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        if self.CurExp != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.CurExp);
        }
        if self.CurReroll != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.CurReroll);
        }
        if self.CurTreasureMissCnt != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.CurTreasureMissCnt);
        }
        for value in &self.PeriodIdList {
            my_size += ::protobuf::rt::uint32_size(12, *value);
        };
        if self.CurGearLostCnt != 0 {
            my_size += ::protobuf::rt::uint32_size(13, self.CurGearLostCnt);
        }
        if self.CurWave != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.CurWave);
        }
        if self.IsUnlockGearReroll != false {
            my_size += 1 + 1;
        }
        if self.IsUnlockGearBan != false {
            my_size += 2 + 1;
        }
        for value in &self.CardList {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.GearDamageList {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.StatParams {
            my_size += ::protobuf::rt::uint32_size(19, *value);
        };
        if self.IsGiveup != false {
            my_size += 2 + 1;
        }
        if self.CurUnusedRoundCnt != 0 {
            my_size += ::protobuf::rt::uint32_size(21, self.CurUnusedRoundCnt);
        }
        if let Some(v) = self.StatLogInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.PeriodFirstRandomSeed != 0 {
            my_size += ::protobuf::rt::uint32_size(23, self.PeriodFirstRandomSeed);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.CurLevelId != 0 {
            os.write_uint32(1, self.CurLevelId)?;
        }
        if self.CurPeriod != 0 {
            os.write_uint32(2, self.CurPeriod)?;
        }
        if self.CurCoin != 0 {
            os.write_uint32(3, self.CurCoin)?;
        }
        for v in &self.WeaponSlotList {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.AccessorySlotList {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.BanGearList {
            os.write_uint32(6, *v)?;
        };
        if let Some(v) = self.Collection.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.AllowedGearList {
            os.write_uint32(8, *v)?;
        };
        if self.CurExp != 0 {
            os.write_uint32(9, self.CurExp)?;
        }
        if self.CurReroll != 0 {
            os.write_uint32(10, self.CurReroll)?;
        }
        if self.CurTreasureMissCnt != 0 {
            os.write_uint32(11, self.CurTreasureMissCnt)?;
        }
        for v in &self.PeriodIdList {
            os.write_uint32(12, *v)?;
        };
        if self.CurGearLostCnt != 0 {
            os.write_uint32(13, self.CurGearLostCnt)?;
        }
        if self.CurWave != 0 {
            os.write_uint32(14, self.CurWave)?;
        }
        if self.IsUnlockGearReroll != false {
            os.write_bool(15, self.IsUnlockGearReroll)?;
        }
        if self.IsUnlockGearBan != false {
            os.write_bool(16, self.IsUnlockGearBan)?;
        }
        for v in &self.CardList {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        for v in &self.GearDamageList {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        for v in &self.StatParams {
            os.write_uint32(19, *v)?;
        };
        if self.IsGiveup != false {
            os.write_bool(20, self.IsGiveup)?;
        }
        if self.CurUnusedRoundCnt != 0 {
            os.write_uint32(21, self.CurUnusedRoundCnt)?;
        }
        if let Some(v) = self.StatLogInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if self.PeriodFirstRandomSeed != 0 {
            os.write_uint32(23, self.PeriodFirstRandomSeed)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EvolveBuildBattleInfo {
        EvolveBuildBattleInfo::new()
    }

    fn clear(&mut self) {
        self.CurLevelId = 0;
        self.CurPeriod = 0;
        self.CurCoin = 0;
        self.WeaponSlotList.clear();
        self.AccessorySlotList.clear();
        self.BanGearList.clear();
        self.Collection.clear();
        self.AllowedGearList.clear();
        self.CurExp = 0;
        self.CurReroll = 0;
        self.CurTreasureMissCnt = 0;
        self.PeriodIdList.clear();
        self.CurGearLostCnt = 0;
        self.CurWave = 0;
        self.IsUnlockGearReroll = false;
        self.IsUnlockGearBan = false;
        self.CardList.clear();
        self.GearDamageList.clear();
        self.StatParams.clear();
        self.IsGiveup = false;
        self.CurUnusedRoundCnt = 0;
        self.StatLogInfo.clear();
        self.PeriodFirstRandomSeed = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EvolveBuildBattleInfo {
        static instance: EvolveBuildBattleInfo = EvolveBuildBattleInfo {
            CurLevelId: 0,
            CurPeriod: 0,
            CurCoin: 0,
            WeaponSlotList: ::std::vec::Vec::new(),
            AccessorySlotList: ::std::vec::Vec::new(),
            BanGearList: ::std::vec::Vec::new(),
            Collection: ::protobuf::MessageField::none(),
            AllowedGearList: ::std::vec::Vec::new(),
            CurExp: 0,
            CurReroll: 0,
            CurTreasureMissCnt: 0,
            PeriodIdList: ::std::vec::Vec::new(),
            CurGearLostCnt: 0,
            CurWave: 0,
            IsUnlockGearReroll: false,
            IsUnlockGearBan: false,
            CardList: ::std::vec::Vec::new(),
            GearDamageList: ::std::vec::Vec::new(),
            StatParams: ::std::vec::Vec::new(),
            IsGiveup: false,
            CurUnusedRoundCnt: 0,
            StatLogInfo: ::protobuf::MessageField::none(),
            PeriodFirstRandomSeed: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EvolveBuildBattleInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EvolveBuildBattleInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EvolveBuildBattleInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvolveBuildBattleInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11EvolveBuild.proto\"Q\n\x0bPPKHGCHPCLC\x12\x20\n\x0bEMECLFMNJIA\x18\
    \x01\x20\x01(\rR\x0bEMECLFMNJIA\x12\x20\n\x0bKMHGILBNPIN\x18\x02\x20\x01\
    (\rR\x0bKMHGILBNPIN\"\x86\x01\n\x10EvolveBuildEquip\x12\x20\n\x0bOKFLGFJ\
    JJBI\x18\x01\x20\x01(\rR\x0bOKFLGFJJJBI\x12\x20\n\x0bLIBMPHILENJ\x18\x02\
    \x20\x01(\x08R\x0bLIBMPHILENJ\x12.\n\x0bMNKDHNHKPGC\x18\x03\x20\x01(\x0b\
    2\x0c.PPKHGCHPCLCR\x0bMNKDHNHKPGC\"*\n\x0fEvolveBuildCard\x12\x17\n\x07c\
    ard_id\x18\x01\x20\x01(\rR\x06cardId\"g\n\x19EvolveBuildGearDamageInfo\
    \x12\x16\n\x06GearId\x18\x01\x20\x01(\rR\x06GearId\x12\x16\n\x06Damage\
    \x18\x02\x20\x01(\x01R\x06Damage\x12\x1a\n\x08HpDamage\x18\x03\x20\x01(\
    \x01R\x08HpDamage\"=\n\x19EvolveBuildGearCollection\x12\x20\n\x0bOADLCKE\
    CIPM\x18\x01\x20\x03(\rR\x0bOADLCKECIPM\"\xc9\x01\n\x0fEvolveBuildStat\
    \x12\x20\n\x0bKMBODLBAMND\x18\x01\x20\x01(\rR\x0bKMBODLBAMND\x12\x20\n\
    \x0bOGGKLHIKOBO\x18\x02\x20\x01(\rR\x0bOGGKLHIKOBO\x12\x20\n\x0bIDKFHDLL\
    LDA\x18\x03\x20\x01(\rR\x0bIDKFHDLLLDA\x12.\n\x0bFCKMBLINDLO\x18\x04\x20\
    \x03(\x0b2\x0c.PPKHGCHPCLCR\x0bFCKMBLINDLO\x12\x20\n\x0bFIPGHGJBBEA\x18\
    \x05\x20\x01(\x02R\x0bFIPGHGJBBEA\"k\n\x13EvolveBuildStatInfo\x12\x20\n\
    \x0bJFNKBMGCLLG\x18\x01\x20\x01(\rR\x0bJFNKBMGCLLG\x122\n\x0bHMKPLAJNJPI\
    \x18\x02\x20\x03(\x0b2\x10.EvolveBuildStatR\x0bHMKPLAJNJPI\"\xe3\x07\n\
    \x15EvolveBuildBattleInfo\x12\x1e\n\nCurLevelId\x18\x01\x20\x01(\rR\nCur\
    LevelId\x12\x1c\n\tCurPeriod\x18\x02\x20\x01(\rR\tCurPeriod\x12\x18\n\
    \x07CurCoin\x18\x03\x20\x01(\rR\x07CurCoin\x129\n\x0eWeaponSlotList\x18\
    \x04\x20\x03(\x0b2\x11.EvolveBuildEquipR\x0eWeaponSlotList\x12?\n\x11Acc\
    essorySlotList\x18\x05\x20\x03(\x0b2\x11.EvolveBuildEquipR\x11AccessoryS\
    lotList\x12\x20\n\x0bBanGearList\x18\x06\x20\x03(\rR\x0bBanGearList\x12:\
    \n\nCollection\x18\x07\x20\x01(\x0b2\x1a.EvolveBuildGearCollectionR\nCol\
    lection\x12(\n\x0fAllowedGearList\x18\x08\x20\x03(\rR\x0fAllowedGearList\
    \x12\x16\n\x06CurExp\x18\t\x20\x01(\rR\x06CurExp\x12\x1c\n\tCurReroll\
    \x18\n\x20\x01(\rR\tCurReroll\x12.\n\x12CurTreasureMissCnt\x18\x0b\x20\
    \x01(\rR\x12CurTreasureMissCnt\x12\"\n\x0cPeriodIdList\x18\x0c\x20\x03(\
    \rR\x0cPeriodIdList\x12&\n\x0eCurGearLostCnt\x18\r\x20\x01(\rR\x0eCurGea\
    rLostCnt\x12\x18\n\x07CurWave\x18\x0e\x20\x01(\rR\x07CurWave\x12.\n\x12I\
    sUnlockGearReroll\x18\x0f\x20\x01(\x08R\x12IsUnlockGearReroll\x12(\n\x0f\
    IsUnlockGearBan\x18\x10\x20\x01(\x08R\x0fIsUnlockGearBan\x12,\n\x08CardL\
    ist\x18\x11\x20\x03(\x0b2\x10.EvolveBuildCardR\x08CardList\x12B\n\x0eGea\
    rDamageList\x18\x12\x20\x03(\x0b2\x1a.EvolveBuildGearDamageInfoR\x0eGear\
    DamageList\x12\x1e\n\nStatParams\x18\x13\x20\x03(\rR\nStatParams\x12\x1a\
    \n\x08IsGiveup\x18\x14\x20\x01(\x08R\x08IsGiveup\x12,\n\x11CurUnusedRoun\
    dCnt\x18\x15\x20\x01(\rR\x11CurUnusedRoundCnt\x126\n\x0bStatLogInfo\x18\
    \x16\x20\x01(\x0b2\x14.EvolveBuildStatInfoR\x0bStatLogInfo\x124\n\x15Per\
    iodFirstRandomSeed\x18\x17\x20\x01(\rR\x15PeriodFirstRandomSeedB\x15\n\
    \x13emu.lunarcore.protob\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(8);
            messages.push(PPKHGCHPCLC::generated_message_descriptor_data());
            messages.push(EvolveBuildEquip::generated_message_descriptor_data());
            messages.push(EvolveBuildCard::generated_message_descriptor_data());
            messages.push(EvolveBuildGearDamageInfo::generated_message_descriptor_data());
            messages.push(EvolveBuildGearCollection::generated_message_descriptor_data());
            messages.push(EvolveBuildStat::generated_message_descriptor_data());
            messages.push(EvolveBuildStatInfo::generated_message_descriptor_data());
            messages.push(EvolveBuildBattleInfo::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
