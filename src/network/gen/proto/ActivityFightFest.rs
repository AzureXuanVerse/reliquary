// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `ActivityFightFest.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:FestChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FestChallenge {
    // message fields
    // @@protoc_insertion_point(field:FestChallenge.MOIDPJNOOEB)
    pub MOIDPJNOOEB: u32,
    // @@protoc_insertion_point(field:FestChallenge.remaining_cycle)
    pub remaining_cycle: u32,
    // @@protoc_insertion_point(field:FestChallenge.challenge_id)
    pub challenge_id: u32,
    // @@protoc_insertion_point(field:FestChallenge.activity_rank)
    pub activity_rank: ::protobuf::EnumOrUnknown<FightFestBattleRank>,
    // special fields
    // @@protoc_insertion_point(special_field:FestChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FestChallenge {
    fn default() -> &'a FestChallenge {
        <FestChallenge as ::protobuf::Message>::default_instance()
    }
}

impl FestChallenge {
    pub fn new() -> FestChallenge {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MOIDPJNOOEB",
            |m: &FestChallenge| { &m.MOIDPJNOOEB },
            |m: &mut FestChallenge| { &mut m.MOIDPJNOOEB },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "remaining_cycle",
            |m: &FestChallenge| { &m.remaining_cycle },
            |m: &mut FestChallenge| { &mut m.remaining_cycle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "challenge_id",
            |m: &FestChallenge| { &m.challenge_id },
            |m: &mut FestChallenge| { &mut m.challenge_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "activity_rank",
            |m: &FestChallenge| { &m.activity_rank },
            |m: &mut FestChallenge| { &mut m.activity_rank },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FestChallenge>(
            "FestChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FestChallenge {
    const NAME: &'static str = "FestChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                96 => {
                    self.MOIDPJNOOEB = is.read_uint32()?;
                },
                32 => {
                    self.remaining_cycle = is.read_uint32()?;
                },
                16 => {
                    self.challenge_id = is.read_uint32()?;
                },
                8 => {
                    self.activity_rank = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.MOIDPJNOOEB != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.MOIDPJNOOEB);
        }
        if self.remaining_cycle != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.remaining_cycle);
        }
        if self.challenge_id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.challenge_id);
        }
        if self.activity_rank != ::protobuf::EnumOrUnknown::new(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_C) {
            my_size += ::protobuf::rt::int32_size(1, self.activity_rank.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.MOIDPJNOOEB != 0 {
            os.write_uint32(12, self.MOIDPJNOOEB)?;
        }
        if self.remaining_cycle != 0 {
            os.write_uint32(4, self.remaining_cycle)?;
        }
        if self.challenge_id != 0 {
            os.write_uint32(2, self.challenge_id)?;
        }
        if self.activity_rank != ::protobuf::EnumOrUnknown::new(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_C) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.activity_rank))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FestChallenge {
        FestChallenge::new()
    }

    fn clear(&mut self) {
        self.MOIDPJNOOEB = 0;
        self.remaining_cycle = 0;
        self.challenge_id = 0;
        self.activity_rank = ::protobuf::EnumOrUnknown::new(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_C);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FestChallenge {
        static instance: FestChallenge = FestChallenge {
            MOIDPJNOOEB: 0,
            remaining_cycle: 0,
            challenge_id: 0,
            activity_rank: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FestChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FestChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FestChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FestChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetFightFestDataCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetFightFestDataCsReq {
    // special fields
    // @@protoc_insertion_point(special_field:GetFightFestDataCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFightFestDataCsReq {
    fn default() -> &'a GetFightFestDataCsReq {
        <GetFightFestDataCsReq as ::protobuf::Message>::default_instance()
    }
}

impl GetFightFestDataCsReq {
    pub fn new() -> GetFightFestDataCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetFightFestDataCsReq>(
            "GetFightFestDataCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetFightFestDataCsReq {
    const NAME: &'static str = "GetFightFestDataCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFightFestDataCsReq {
        GetFightFestDataCsReq::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFightFestDataCsReq {
        static instance: GetFightFestDataCsReq = GetFightFestDataCsReq {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetFightFestDataCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetFightFestDataCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetFightFestDataCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFightFestDataCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetFightFestDataScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetFightFestDataScRsp {
    // message fields
    // @@protoc_insertion_point(field:GetFightFestDataScRsp.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:GetFightFestDataScRsp.coin_num)
    pub coin_num: u32,
    // @@protoc_insertion_point(field:GetFightFestDataScRsp.challenge_list)
    pub challenge_list: ::std::vec::Vec<FestChallenge>,
    // @@protoc_insertion_point(field:GetFightFestDataScRsp.coach_skills)
    pub coach_skills: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:GetFightFestDataScRsp.score)
    pub score: u32,
    // special fields
    // @@protoc_insertion_point(special_field:GetFightFestDataScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFightFestDataScRsp {
    fn default() -> &'a GetFightFestDataScRsp {
        <GetFightFestDataScRsp as ::protobuf::Message>::default_instance()
    }
}

impl GetFightFestDataScRsp {
    pub fn new() -> GetFightFestDataScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &GetFightFestDataScRsp| { &m.retcode },
            |m: &mut GetFightFestDataScRsp| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "coin_num",
            |m: &GetFightFestDataScRsp| { &m.coin_num },
            |m: &mut GetFightFestDataScRsp| { &mut m.coin_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "challenge_list",
            |m: &GetFightFestDataScRsp| { &m.challenge_list },
            |m: &mut GetFightFestDataScRsp| { &mut m.challenge_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "coach_skills",
            |m: &GetFightFestDataScRsp| { &m.coach_skills },
            |m: &mut GetFightFestDataScRsp| { &mut m.coach_skills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "score",
            |m: &GetFightFestDataScRsp| { &m.score },
            |m: &mut GetFightFestDataScRsp| { &mut m.score },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetFightFestDataScRsp>(
            "GetFightFestDataScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetFightFestDataScRsp {
    const NAME: &'static str = "GetFightFestDataScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                112 => {
                    self.retcode = is.read_uint32()?;
                },
                64 => {
                    self.coin_num = is.read_uint32()?;
                },
                106 => {
                    self.challenge_list.push(is.read_message()?);
                },
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.coach_skills)?;
                },
                8 => {
                    self.coach_skills.push(is.read_uint32()?);
                },
                96 => {
                    self.score = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.retcode);
        }
        if self.coin_num != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.coin_num);
        }
        for value in &self.challenge_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.coach_skills {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if self.score != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.score);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(14, self.retcode)?;
        }
        if self.coin_num != 0 {
            os.write_uint32(8, self.coin_num)?;
        }
        for v in &self.challenge_list {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        for v in &self.coach_skills {
            os.write_uint32(1, *v)?;
        };
        if self.score != 0 {
            os.write_uint32(12, self.score)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFightFestDataScRsp {
        GetFightFestDataScRsp::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.coin_num = 0;
        self.challenge_list.clear();
        self.coach_skills.clear();
        self.score = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFightFestDataScRsp {
        static instance: GetFightFestDataScRsp = GetFightFestDataScRsp {
            retcode: 0,
            coin_num: 0,
            challenge_list: ::std::vec::Vec::new(),
            coach_skills: ::std::vec::Vec::new(),
            score: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetFightFestDataScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetFightFestDataScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetFightFestDataScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFightFestDataScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FightFestAvatar)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FightFestAvatar {
    // message fields
    // @@protoc_insertion_point(field:FightFestAvatar.avatar_type)
    pub avatar_type: ::protobuf::EnumOrUnknown<super::AvatarType::AvatarType>,
    // @@protoc_insertion_point(field:FightFestAvatar.id)
    pub id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:FightFestAvatar.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FightFestAvatar {
    fn default() -> &'a FightFestAvatar {
        <FightFestAvatar as ::protobuf::Message>::default_instance()
    }
}

impl FightFestAvatar {
    pub fn new() -> FightFestAvatar {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "avatar_type",
            |m: &FightFestAvatar| { &m.avatar_type },
            |m: &mut FightFestAvatar| { &mut m.avatar_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FightFestAvatar| { &m.id },
            |m: &mut FightFestAvatar| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FightFestAvatar>(
            "FightFestAvatar",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FightFestAvatar {
    const NAME: &'static str = "FightFestAvatar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                56 => {
                    self.avatar_type = is.read_enum_or_unknown()?;
                },
                88 => {
                    self.id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.avatar_type != ::protobuf::EnumOrUnknown::new(super::AvatarType::AvatarType::AVATAR_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.avatar_type.value());
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.avatar_type != ::protobuf::EnumOrUnknown::new(super::AvatarType::AvatarType::AVATAR_TYPE_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.avatar_type))?;
        }
        if self.id != 0 {
            os.write_uint32(11, self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FightFestAvatar {
        FightFestAvatar::new()
    }

    fn clear(&mut self) {
        self.avatar_type = ::protobuf::EnumOrUnknown::new(super::AvatarType::AvatarType::AVATAR_TYPE_NONE);
        self.id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FightFestAvatar {
        static instance: FightFestAvatar = FightFestAvatar {
            avatar_type: ::protobuf::EnumOrUnknown::from_i32(0),
            id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FightFestAvatar {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FightFestAvatar").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FightFestAvatar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FightFestAvatar {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:StartFightFestCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StartFightFestCsReq {
    // message fields
    // @@protoc_insertion_point(field:StartFightFestCsReq.coach_skills)
    pub coach_skills: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:StartFightFestCsReq.id)
    pub id: u32,
    // @@protoc_insertion_point(field:StartFightFestCsReq.avatar_list)
    pub avatar_list: ::std::vec::Vec<FightFestAvatar>,
    // @@protoc_insertion_point(field:StartFightFestCsReq.slot)
    pub slot: ::protobuf::EnumOrUnknown<FightFestType>,
    // special fields
    // @@protoc_insertion_point(special_field:StartFightFestCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StartFightFestCsReq {
    fn default() -> &'a StartFightFestCsReq {
        <StartFightFestCsReq as ::protobuf::Message>::default_instance()
    }
}

impl StartFightFestCsReq {
    pub fn new() -> StartFightFestCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "coach_skills",
            |m: &StartFightFestCsReq| { &m.coach_skills },
            |m: &mut StartFightFestCsReq| { &mut m.coach_skills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &StartFightFestCsReq| { &m.id },
            |m: &mut StartFightFestCsReq| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "avatar_list",
            |m: &StartFightFestCsReq| { &m.avatar_list },
            |m: &mut StartFightFestCsReq| { &mut m.avatar_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot",
            |m: &StartFightFestCsReq| { &m.slot },
            |m: &mut StartFightFestCsReq| { &mut m.slot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StartFightFestCsReq>(
            "StartFightFestCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StartFightFestCsReq {
    const NAME: &'static str = "StartFightFestCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.coach_skills)?;
                },
                72 => {
                    self.coach_skills.push(is.read_uint32()?);
                },
                96 => {
                    self.id = is.read_uint32()?;
                },
                58 => {
                    self.avatar_list.push(is.read_message()?);
                },
                8 => {
                    self.slot = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.coach_skills {
            my_size += ::protobuf::rt::uint32_size(9, *value);
        };
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.id);
        }
        for value in &self.avatar_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.slot != ::protobuf::EnumOrUnknown::new(FightFestType::FIGHT_FEST_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(1, self.slot.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.coach_skills {
            os.write_uint32(9, *v)?;
        };
        if self.id != 0 {
            os.write_uint32(12, self.id)?;
        }
        for v in &self.avatar_list {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if self.slot != ::protobuf::EnumOrUnknown::new(FightFestType::FIGHT_FEST_TYPE_NONE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.slot))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StartFightFestCsReq {
        StartFightFestCsReq::new()
    }

    fn clear(&mut self) {
        self.coach_skills.clear();
        self.id = 0;
        self.avatar_list.clear();
        self.slot = ::protobuf::EnumOrUnknown::new(FightFestType::FIGHT_FEST_TYPE_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StartFightFestCsReq {
        static instance: StartFightFestCsReq = StartFightFestCsReq {
            coach_skills: ::std::vec::Vec::new(),
            id: 0,
            avatar_list: ::std::vec::Vec::new(),
            slot: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StartFightFestCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StartFightFestCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StartFightFestCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartFightFestCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:StartFightFestScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StartFightFestScRsp {
    // message fields
    // @@protoc_insertion_point(field:StartFightFestScRsp.slot)
    pub slot: ::protobuf::EnumOrUnknown<FightFestType>,
    // @@protoc_insertion_point(field:StartFightFestScRsp.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:StartFightFestScRsp.id)
    pub id: u32,
    // @@protoc_insertion_point(field:StartFightFestScRsp.battle_info)
    pub battle_info: ::protobuf::MessageField<super::SceneBattleInfo::SceneBattleInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:StartFightFestScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StartFightFestScRsp {
    fn default() -> &'a StartFightFestScRsp {
        <StartFightFestScRsp as ::protobuf::Message>::default_instance()
    }
}

impl StartFightFestScRsp {
    pub fn new() -> StartFightFestScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot",
            |m: &StartFightFestScRsp| { &m.slot },
            |m: &mut StartFightFestScRsp| { &mut m.slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &StartFightFestScRsp| { &m.retcode },
            |m: &mut StartFightFestScRsp| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &StartFightFestScRsp| { &m.id },
            |m: &mut StartFightFestScRsp| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::SceneBattleInfo::SceneBattleInfo>(
            "battle_info",
            |m: &StartFightFestScRsp| { &m.battle_info },
            |m: &mut StartFightFestScRsp| { &mut m.battle_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StartFightFestScRsp>(
            "StartFightFestScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StartFightFestScRsp {
    const NAME: &'static str = "StartFightFestScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.slot = is.read_enum_or_unknown()?;
                },
                40 => {
                    self.retcode = is.read_uint32()?;
                },
                72 => {
                    self.id = is.read_uint32()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.battle_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.slot != ::protobuf::EnumOrUnknown::new(FightFestType::FIGHT_FEST_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(3, self.slot.value());
        }
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.retcode);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.id);
        }
        if let Some(v) = self.battle_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.slot != ::protobuf::EnumOrUnknown::new(FightFestType::FIGHT_FEST_TYPE_NONE) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.slot))?;
        }
        if self.retcode != 0 {
            os.write_uint32(5, self.retcode)?;
        }
        if self.id != 0 {
            os.write_uint32(9, self.id)?;
        }
        if let Some(v) = self.battle_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StartFightFestScRsp {
        StartFightFestScRsp::new()
    }

    fn clear(&mut self) {
        self.slot = ::protobuf::EnumOrUnknown::new(FightFestType::FIGHT_FEST_TYPE_NONE);
        self.retcode = 0;
        self.id = 0;
        self.battle_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StartFightFestScRsp {
        static instance: StartFightFestScRsp = StartFightFestScRsp {
            slot: ::protobuf::EnumOrUnknown::from_i32(0),
            retcode: 0,
            id: 0,
            battle_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StartFightFestScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StartFightFestScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StartFightFestScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartFightFestScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FightFestScoreUpdateNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FightFestScoreUpdateNotify {
    // message fields
    // @@protoc_insertion_point(field:FightFestScoreUpdateNotify.score)
    pub score: u32,
    // @@protoc_insertion_point(field:FightFestScoreUpdateNotify.EFADKNHAECI)
    pub EFADKNHAECI: u32,
    // special fields
    // @@protoc_insertion_point(special_field:FightFestScoreUpdateNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FightFestScoreUpdateNotify {
    fn default() -> &'a FightFestScoreUpdateNotify {
        <FightFestScoreUpdateNotify as ::protobuf::Message>::default_instance()
    }
}

impl FightFestScoreUpdateNotify {
    pub fn new() -> FightFestScoreUpdateNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "score",
            |m: &FightFestScoreUpdateNotify| { &m.score },
            |m: &mut FightFestScoreUpdateNotify| { &mut m.score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "EFADKNHAECI",
            |m: &FightFestScoreUpdateNotify| { &m.EFADKNHAECI },
            |m: &mut FightFestScoreUpdateNotify| { &mut m.EFADKNHAECI },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FightFestScoreUpdateNotify>(
            "FightFestScoreUpdateNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FightFestScoreUpdateNotify {
    const NAME: &'static str = "FightFestScoreUpdateNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.score = is.read_uint32()?;
                },
                96 => {
                    self.EFADKNHAECI = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.score != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.score);
        }
        if self.EFADKNHAECI != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.EFADKNHAECI);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.score != 0 {
            os.write_uint32(4, self.score)?;
        }
        if self.EFADKNHAECI != 0 {
            os.write_uint32(12, self.EFADKNHAECI)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FightFestScoreUpdateNotify {
        FightFestScoreUpdateNotify::new()
    }

    fn clear(&mut self) {
        self.score = 0;
        self.EFADKNHAECI = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FightFestScoreUpdateNotify {
        static instance: FightFestScoreUpdateNotify = FightFestScoreUpdateNotify {
            score: 0,
            EFADKNHAECI: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FightFestScoreUpdateNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FightFestScoreUpdateNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FightFestScoreUpdateNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FightFestScoreUpdateNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FightFestUnlockSkillNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FightFestUnlockSkillNotify {
    // message fields
    // @@protoc_insertion_point(field:FightFestUnlockSkillNotify.coach_skill)
    pub coach_skill: u32,
    // special fields
    // @@protoc_insertion_point(special_field:FightFestUnlockSkillNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FightFestUnlockSkillNotify {
    fn default() -> &'a FightFestUnlockSkillNotify {
        <FightFestUnlockSkillNotify as ::protobuf::Message>::default_instance()
    }
}

impl FightFestUnlockSkillNotify {
    pub fn new() -> FightFestUnlockSkillNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "coach_skill",
            |m: &FightFestUnlockSkillNotify| { &m.coach_skill },
            |m: &mut FightFestUnlockSkillNotify| { &mut m.coach_skill },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FightFestUnlockSkillNotify>(
            "FightFestUnlockSkillNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FightFestUnlockSkillNotify {
    const NAME: &'static str = "FightFestUnlockSkillNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                88 => {
                    self.coach_skill = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.coach_skill != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.coach_skill);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.coach_skill != 0 {
            os.write_uint32(11, self.coach_skill)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FightFestUnlockSkillNotify {
        FightFestUnlockSkillNotify::new()
    }

    fn clear(&mut self) {
        self.coach_skill = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FightFestUnlockSkillNotify {
        static instance: FightFestUnlockSkillNotify = FightFestUnlockSkillNotify {
            coach_skill: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FightFestUnlockSkillNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FightFestUnlockSkillNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FightFestUnlockSkillNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FightFestUnlockSkillNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FightFestUpdateChallengeRecordNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FightFestUpdateChallengeRecordNotify {
    // message fields
    // @@protoc_insertion_point(field:FightFestUpdateChallengeRecordNotify.remaining_cycle)
    pub remaining_cycle: u32,
    // @@protoc_insertion_point(field:FightFestUpdateChallengeRecordNotify.best_rank)
    pub best_rank: ::protobuf::EnumOrUnknown<FightFestBattleRank>,
    // @@protoc_insertion_point(field:FightFestUpdateChallengeRecordNotify.rank)
    pub rank: ::protobuf::EnumOrUnknown<FightFestBattleRank>,
    // @@protoc_insertion_point(field:FightFestUpdateChallengeRecordNotify.MPHCMMFKPOG)
    pub MPHCMMFKPOG: u32,
    // @@protoc_insertion_point(field:FightFestUpdateChallengeRecordNotify.challenge_id)
    pub challenge_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:FightFestUpdateChallengeRecordNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FightFestUpdateChallengeRecordNotify {
    fn default() -> &'a FightFestUpdateChallengeRecordNotify {
        <FightFestUpdateChallengeRecordNotify as ::protobuf::Message>::default_instance()
    }
}

impl FightFestUpdateChallengeRecordNotify {
    pub fn new() -> FightFestUpdateChallengeRecordNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "remaining_cycle",
            |m: &FightFestUpdateChallengeRecordNotify| { &m.remaining_cycle },
            |m: &mut FightFestUpdateChallengeRecordNotify| { &mut m.remaining_cycle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "best_rank",
            |m: &FightFestUpdateChallengeRecordNotify| { &m.best_rank },
            |m: &mut FightFestUpdateChallengeRecordNotify| { &mut m.best_rank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rank",
            |m: &FightFestUpdateChallengeRecordNotify| { &m.rank },
            |m: &mut FightFestUpdateChallengeRecordNotify| { &mut m.rank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MPHCMMFKPOG",
            |m: &FightFestUpdateChallengeRecordNotify| { &m.MPHCMMFKPOG },
            |m: &mut FightFestUpdateChallengeRecordNotify| { &mut m.MPHCMMFKPOG },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "challenge_id",
            |m: &FightFestUpdateChallengeRecordNotify| { &m.challenge_id },
            |m: &mut FightFestUpdateChallengeRecordNotify| { &mut m.challenge_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FightFestUpdateChallengeRecordNotify>(
            "FightFestUpdateChallengeRecordNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FightFestUpdateChallengeRecordNotify {
    const NAME: &'static str = "FightFestUpdateChallengeRecordNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.remaining_cycle = is.read_uint32()?;
                },
                72 => {
                    self.best_rank = is.read_enum_or_unknown()?;
                },
                56 => {
                    self.rank = is.read_enum_or_unknown()?;
                },
                80 => {
                    self.MPHCMMFKPOG = is.read_uint32()?;
                },
                16 => {
                    self.challenge_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.remaining_cycle != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.remaining_cycle);
        }
        if self.best_rank != ::protobuf::EnumOrUnknown::new(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_C) {
            my_size += ::protobuf::rt::int32_size(9, self.best_rank.value());
        }
        if self.rank != ::protobuf::EnumOrUnknown::new(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_C) {
            my_size += ::protobuf::rt::int32_size(7, self.rank.value());
        }
        if self.MPHCMMFKPOG != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.MPHCMMFKPOG);
        }
        if self.challenge_id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.challenge_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.remaining_cycle != 0 {
            os.write_uint32(6, self.remaining_cycle)?;
        }
        if self.best_rank != ::protobuf::EnumOrUnknown::new(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_C) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.best_rank))?;
        }
        if self.rank != ::protobuf::EnumOrUnknown::new(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_C) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.rank))?;
        }
        if self.MPHCMMFKPOG != 0 {
            os.write_uint32(10, self.MPHCMMFKPOG)?;
        }
        if self.challenge_id != 0 {
            os.write_uint32(2, self.challenge_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FightFestUpdateChallengeRecordNotify {
        FightFestUpdateChallengeRecordNotify::new()
    }

    fn clear(&mut self) {
        self.remaining_cycle = 0;
        self.best_rank = ::protobuf::EnumOrUnknown::new(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_C);
        self.rank = ::protobuf::EnumOrUnknown::new(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_C);
        self.MPHCMMFKPOG = 0;
        self.challenge_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FightFestUpdateChallengeRecordNotify {
        static instance: FightFestUpdateChallengeRecordNotify = FightFestUpdateChallengeRecordNotify {
            remaining_cycle: 0,
            best_rank: ::protobuf::EnumOrUnknown::from_i32(0),
            rank: ::protobuf::EnumOrUnknown::from_i32(0),
            MPHCMMFKPOG: 0,
            challenge_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FightFestUpdateChallengeRecordNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FightFestUpdateChallengeRecordNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FightFestUpdateChallengeRecordNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FightFestUpdateChallengeRecordNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FightFestUpdateCoinNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FightFestUpdateCoinNotify {
    // message fields
    // @@protoc_insertion_point(field:FightFestUpdateCoinNotify.coin_num)
    pub coin_num: u32,
    // special fields
    // @@protoc_insertion_point(special_field:FightFestUpdateCoinNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FightFestUpdateCoinNotify {
    fn default() -> &'a FightFestUpdateCoinNotify {
        <FightFestUpdateCoinNotify as ::protobuf::Message>::default_instance()
    }
}

impl FightFestUpdateCoinNotify {
    pub fn new() -> FightFestUpdateCoinNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "coin_num",
            |m: &FightFestUpdateCoinNotify| { &m.coin_num },
            |m: &mut FightFestUpdateCoinNotify| { &mut m.coin_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FightFestUpdateCoinNotify>(
            "FightFestUpdateCoinNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FightFestUpdateCoinNotify {
    const NAME: &'static str = "FightFestUpdateCoinNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.coin_num = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.coin_num != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.coin_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.coin_num != 0 {
            os.write_uint32(10, self.coin_num)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FightFestUpdateCoinNotify {
        FightFestUpdateCoinNotify::new()
    }

    fn clear(&mut self) {
        self.coin_num = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FightFestUpdateCoinNotify {
        static instance: FightFestUpdateCoinNotify = FightFestUpdateCoinNotify {
            coin_num: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FightFestUpdateCoinNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FightFestUpdateCoinNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FightFestUpdateCoinNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FightFestUpdateCoinNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:FightFestBattleRank)
pub enum FightFestBattleRank {
    // @@protoc_insertion_point(enum_value:FightFestBattleRank.FIGHT_FEST_BATTLE_RANK_C)
    FIGHT_FEST_BATTLE_RANK_C = 0,
    // @@protoc_insertion_point(enum_value:FightFestBattleRank.FIGHT_FEST_BATTLE_RANK_B)
    FIGHT_FEST_BATTLE_RANK_B = 1,
    // @@protoc_insertion_point(enum_value:FightFestBattleRank.FIGHT_FEST_BATTLE_RANK_A)
    FIGHT_FEST_BATTLE_RANK_A = 2,
    // @@protoc_insertion_point(enum_value:FightFestBattleRank.FIGHT_FEST_BATTLE_RANK_S)
    FIGHT_FEST_BATTLE_RANK_S = 3,
    // @@protoc_insertion_point(enum_value:FightFestBattleRank.FIGHT_FEST_BATTLE_RANK_SS)
    FIGHT_FEST_BATTLE_RANK_SS = 4,
}

impl ::protobuf::Enum for FightFestBattleRank {
    const NAME: &'static str = "FightFestBattleRank";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FightFestBattleRank> {
        match value {
            0 => ::std::option::Option::Some(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_C),
            1 => ::std::option::Option::Some(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_B),
            2 => ::std::option::Option::Some(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_A),
            3 => ::std::option::Option::Some(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_S),
            4 => ::std::option::Option::Some(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_SS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<FightFestBattleRank> {
        match str {
            "FIGHT_FEST_BATTLE_RANK_C" => ::std::option::Option::Some(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_C),
            "FIGHT_FEST_BATTLE_RANK_B" => ::std::option::Option::Some(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_B),
            "FIGHT_FEST_BATTLE_RANK_A" => ::std::option::Option::Some(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_A),
            "FIGHT_FEST_BATTLE_RANK_S" => ::std::option::Option::Some(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_S),
            "FIGHT_FEST_BATTLE_RANK_SS" => ::std::option::Option::Some(FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_SS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FightFestBattleRank] = &[
        FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_C,
        FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_B,
        FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_A,
        FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_S,
        FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_SS,
    ];
}

impl ::protobuf::EnumFull for FightFestBattleRank {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FightFestBattleRank").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FightFestBattleRank {
    fn default() -> Self {
        FightFestBattleRank::FIGHT_FEST_BATTLE_RANK_C
    }
}

impl FightFestBattleRank {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FightFestBattleRank>("FightFestBattleRank")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:FightFestType)
pub enum FightFestType {
    // @@protoc_insertion_point(enum_value:FightFestType.FIGHT_FEST_TYPE_NONE)
    FIGHT_FEST_TYPE_NONE = 0,
    // @@protoc_insertion_point(enum_value:FightFestType.FIGHT_FEST_TYPE_MAIN)
    FIGHT_FEST_TYPE_MAIN = 1,
    // @@protoc_insertion_point(enum_value:FightFestType.FIGHT_FEST_TYPE_SCORE)
    FIGHT_FEST_TYPE_SCORE = 2,
    // @@protoc_insertion_point(enum_value:FightFestType.FIGHT_FEST_TYPE_CHALLENGE)
    FIGHT_FEST_TYPE_CHALLENGE = 3,
    // @@protoc_insertion_point(enum_value:FightFestType.FIGHT_FEST_TYPE_TEACH)
    FIGHT_FEST_TYPE_TEACH = 4,
}

impl ::protobuf::Enum for FightFestType {
    const NAME: &'static str = "FightFestType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FightFestType> {
        match value {
            0 => ::std::option::Option::Some(FightFestType::FIGHT_FEST_TYPE_NONE),
            1 => ::std::option::Option::Some(FightFestType::FIGHT_FEST_TYPE_MAIN),
            2 => ::std::option::Option::Some(FightFestType::FIGHT_FEST_TYPE_SCORE),
            3 => ::std::option::Option::Some(FightFestType::FIGHT_FEST_TYPE_CHALLENGE),
            4 => ::std::option::Option::Some(FightFestType::FIGHT_FEST_TYPE_TEACH),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<FightFestType> {
        match str {
            "FIGHT_FEST_TYPE_NONE" => ::std::option::Option::Some(FightFestType::FIGHT_FEST_TYPE_NONE),
            "FIGHT_FEST_TYPE_MAIN" => ::std::option::Option::Some(FightFestType::FIGHT_FEST_TYPE_MAIN),
            "FIGHT_FEST_TYPE_SCORE" => ::std::option::Option::Some(FightFestType::FIGHT_FEST_TYPE_SCORE),
            "FIGHT_FEST_TYPE_CHALLENGE" => ::std::option::Option::Some(FightFestType::FIGHT_FEST_TYPE_CHALLENGE),
            "FIGHT_FEST_TYPE_TEACH" => ::std::option::Option::Some(FightFestType::FIGHT_FEST_TYPE_TEACH),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FightFestType] = &[
        FightFestType::FIGHT_FEST_TYPE_NONE,
        FightFestType::FIGHT_FEST_TYPE_MAIN,
        FightFestType::FIGHT_FEST_TYPE_SCORE,
        FightFestType::FIGHT_FEST_TYPE_CHALLENGE,
        FightFestType::FIGHT_FEST_TYPE_TEACH,
    ];
}

impl ::protobuf::EnumFull for FightFestType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FightFestType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FightFestType {
    fn default() -> Self {
        FightFestType::FIGHT_FEST_TYPE_NONE
    }
}

impl FightFestType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FightFestType>("FightFestType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17ActivityFightFest.proto\x1a\x10AvatarType.proto\x1a\x15SceneBattle\
    Info.proto\"\xb8\x01\n\rFestChallenge\x12\x20\n\x0bMOIDPJNOOEB\x18\x0c\
    \x20\x01(\rR\x0bMOIDPJNOOEB\x12'\n\x0fremaining_cycle\x18\x04\x20\x01(\r\
    R\x0eremainingCycle\x12!\n\x0cchallenge_id\x18\x02\x20\x01(\rR\x0bchalle\
    ngeId\x129\n\ractivity_rank\x18\x01\x20\x01(\x0e2\x14.FightFestBattleRan\
    kR\x0cactivityRank\"\x17\n\x15GetFightFestDataCsReq\"\xbc\x01\n\x15GetFi\
    ghtFestDataScRsp\x12\x18\n\x07retcode\x18\x0e\x20\x01(\rR\x07retcode\x12\
    \x19\n\x08coin_num\x18\x08\x20\x01(\rR\x07coinNum\x125\n\x0echallenge_li\
    st\x18\r\x20\x03(\x0b2\x0e.FestChallengeR\rchallengeList\x12!\n\x0ccoach\
    _skills\x18\x01\x20\x03(\rR\x0bcoachSkills\x12\x14\n\x05score\x18\x0c\
    \x20\x01(\rR\x05score\"O\n\x0fFightFestAvatar\x12,\n\x0bavatar_type\x18\
    \x07\x20\x01(\x0e2\x0b.AvatarTypeR\navatarType\x12\x0e\n\x02id\x18\x0b\
    \x20\x01(\rR\x02id\"\x9f\x01\n\x13StartFightFestCsReq\x12!\n\x0ccoach_sk\
    ills\x18\t\x20\x03(\rR\x0bcoachSkills\x12\x0e\n\x02id\x18\x0c\x20\x01(\r\
    R\x02id\x121\n\x0bavatar_list\x18\x07\x20\x03(\x0b2\x10.FightFestAvatarR\
    \navatarList\x12\"\n\x04slot\x18\x01\x20\x01(\x0e2\x0e.FightFestTypeR\
    \x04slot\"\x96\x01\n\x13StartFightFestScRsp\x12\"\n\x04slot\x18\x03\x20\
    \x01(\x0e2\x0e.FightFestTypeR\x04slot\x12\x18\n\x07retcode\x18\x05\x20\
    \x01(\rR\x07retcode\x12\x0e\n\x02id\x18\t\x20\x01(\rR\x02id\x121\n\x0bba\
    ttle_info\x18\n\x20\x01(\x0b2\x10.SceneBattleInfoR\nbattleInfo\"T\n\x1aF\
    ightFestScoreUpdateNotify\x12\x14\n\x05score\x18\x04\x20\x01(\rR\x05scor\
    e\x12\x20\n\x0bEFADKNHAECI\x18\x0c\x20\x01(\rR\x0bEFADKNHAECI\"=\n\x1aFi\
    ghtFestUnlockSkillNotify\x12\x1f\n\x0bcoach_skill\x18\x0b\x20\x01(\rR\nc\
    oachSkill\"\xf1\x01\n$FightFestUpdateChallengeRecordNotify\x12'\n\x0frem\
    aining_cycle\x18\x06\x20\x01(\rR\x0eremainingCycle\x121\n\tbest_rank\x18\
    \t\x20\x01(\x0e2\x14.FightFestBattleRankR\x08bestRank\x12(\n\x04rank\x18\
    \x07\x20\x01(\x0e2\x14.FightFestBattleRankR\x04rank\x12\x20\n\x0bMPHCMMF\
    KPOG\x18\n\x20\x01(\rR\x0bMPHCMMFKPOG\x12!\n\x0cchallenge_id\x18\x02\x20\
    \x01(\rR\x0bchallengeId\"6\n\x19FightFestUpdateCoinNotify\x12\x19\n\x08c\
    oin_num\x18\n\x20\x01(\rR\x07coinNum*\xac\x01\n\x13FightFestBattleRank\
    \x12\x1c\n\x18FIGHT_FEST_BATTLE_RANK_C\x10\0\x12\x1c\n\x18FIGHT_FEST_BAT\
    TLE_RANK_B\x10\x01\x12\x1c\n\x18FIGHT_FEST_BATTLE_RANK_A\x10\x02\x12\x1c\
    \n\x18FIGHT_FEST_BATTLE_RANK_S\x10\x03\x12\x1d\n\x19FIGHT_FEST_BATTLE_RA\
    NK_SS\x10\x04*\x98\x01\n\rFightFestType\x12\x18\n\x14FIGHT_FEST_TYPE_NON\
    E\x10\0\x12\x18\n\x14FIGHT_FEST_TYPE_MAIN\x10\x01\x12\x19\n\x15FIGHT_FES\
    T_TYPE_SCORE\x10\x02\x12\x1d\n\x19FIGHT_FEST_TYPE_CHALLENGE\x10\x03\x12\
    \x19\n\x15FIGHT_FEST_TYPE_TEACH\x10\x04B\x15\n\x13emu.lunarcore.protob\
    \x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::AvatarType::file_descriptor().clone());
            deps.push(super::SceneBattleInfo::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(10);
            messages.push(FestChallenge::generated_message_descriptor_data());
            messages.push(GetFightFestDataCsReq::generated_message_descriptor_data());
            messages.push(GetFightFestDataScRsp::generated_message_descriptor_data());
            messages.push(FightFestAvatar::generated_message_descriptor_data());
            messages.push(StartFightFestCsReq::generated_message_descriptor_data());
            messages.push(StartFightFestScRsp::generated_message_descriptor_data());
            messages.push(FightFestScoreUpdateNotify::generated_message_descriptor_data());
            messages.push(FightFestUnlockSkillNotify::generated_message_descriptor_data());
            messages.push(FightFestUpdateChallengeRecordNotify::generated_message_descriptor_data());
            messages.push(FightFestUpdateCoinNotify::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(FightFestBattleRank::generated_enum_descriptor_data());
            enums.push(FightFestType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
