// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `TrainParty.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:TrainPartyCardData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyCardData {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyCardData.unique_id)
    pub unique_id: u32,
    // @@protoc_insertion_point(field:TrainPartyCardData.HMKMKBELCLG)
    pub HMKMKBELCLG: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:TrainPartyCardData.upgrade_level)
    pub upgrade_level: u32,
    // @@protoc_insertion_point(field:TrainPartyCardData.card_id)
    pub card_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyCardData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyCardData {
    fn default() -> &'a TrainPartyCardData {
        <TrainPartyCardData as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyCardData {
    pub fn new() -> TrainPartyCardData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &TrainPartyCardData| { &m.unique_id },
            |m: &mut TrainPartyCardData| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "HMKMKBELCLG",
            |m: &TrainPartyCardData| { &m.HMKMKBELCLG },
            |m: &mut TrainPartyCardData| { &mut m.HMKMKBELCLG },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upgrade_level",
            |m: &TrainPartyCardData| { &m.upgrade_level },
            |m: &mut TrainPartyCardData| { &mut m.upgrade_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "card_id",
            |m: &TrainPartyCardData| { &m.card_id },
            |m: &mut TrainPartyCardData| { &mut m.card_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyCardData>(
            "TrainPartyCardData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyCardData {
    const NAME: &'static str = "TrainPartyCardData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                88 => {
                    self.unique_id = is.read_uint32()?;
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.HMKMKBELCLG)?;
                },
                72 => {
                    self.HMKMKBELCLG.push(is.read_uint32()?);
                },
                40 => {
                    self.upgrade_level = is.read_uint32()?;
                },
                48 => {
                    self.card_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.unique_id != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.unique_id);
        }
        for value in &self.HMKMKBELCLG {
            my_size += ::protobuf::rt::uint32_size(9, *value);
        };
        if self.upgrade_level != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.upgrade_level);
        }
        if self.card_id != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.card_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.unique_id != 0 {
            os.write_uint32(11, self.unique_id)?;
        }
        for v in &self.HMKMKBELCLG {
            os.write_uint32(9, *v)?;
        };
        if self.upgrade_level != 0 {
            os.write_uint32(5, self.upgrade_level)?;
        }
        if self.card_id != 0 {
            os.write_uint32(6, self.card_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyCardData {
        TrainPartyCardData::new()
    }

    fn clear(&mut self) {
        self.unique_id = 0;
        self.HMKMKBELCLG.clear();
        self.upgrade_level = 0;
        self.card_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyCardData {
        static instance: TrainPartyCardData = TrainPartyCardData {
            unique_id: 0,
            HMKMKBELCLG: ::std::vec::Vec::new(),
            upgrade_level: 0,
            card_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyCardData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyCardData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyCardData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyCardData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyCards)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyCards {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyCards.card_data_list)
    pub card_data_list: ::std::vec::Vec<TrainPartyCardData>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyCards.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyCards {
    fn default() -> &'a TrainPartyCards {
        <TrainPartyCards as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyCards {
    pub fn new() -> TrainPartyCards {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "card_data_list",
            |m: &TrainPartyCards| { &m.card_data_list },
            |m: &mut TrainPartyCards| { &mut m.card_data_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyCards>(
            "TrainPartyCards",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyCards {
    const NAME: &'static str = "TrainPartyCards";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                90 => {
                    self.card_data_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.card_data_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.card_data_list {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyCards {
        TrainPartyCards::new()
    }

    fn clear(&mut self) {
        self.card_data_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyCards {
        static instance: TrainPartyCards = TrainPartyCards {
            card_data_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyCards {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyCards").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyCards {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyCards {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyCard)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyCard {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyCard.extra_ratio)
    pub extra_ratio: u32,
    // @@protoc_insertion_point(field:TrainPartyCard.card_data_list)
    pub card_data_list: ::protobuf::MessageField<TrainPartyCards>,
    // @@protoc_insertion_point(field:TrainPartyCard.has_modify_all_passenger_stat_effect)
    pub has_modify_all_passenger_stat_effect: bool,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyCard.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyCard {
    fn default() -> &'a TrainPartyCard {
        <TrainPartyCard as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyCard {
    pub fn new() -> TrainPartyCard {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "extra_ratio",
            |m: &TrainPartyCard| { &m.extra_ratio },
            |m: &mut TrainPartyCard| { &mut m.extra_ratio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyCards>(
            "card_data_list",
            |m: &TrainPartyCard| { &m.card_data_list },
            |m: &mut TrainPartyCard| { &mut m.card_data_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_modify_all_passenger_stat_effect",
            |m: &TrainPartyCard| { &m.has_modify_all_passenger_stat_effect },
            |m: &mut TrainPartyCard| { &mut m.has_modify_all_passenger_stat_effect },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyCard>(
            "TrainPartyCard",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyCard {
    const NAME: &'static str = "TrainPartyCard";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.extra_ratio = is.read_uint32()?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.card_data_list)?;
                },
                112 => {
                    self.has_modify_all_passenger_stat_effect = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.extra_ratio != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.extra_ratio);
        }
        if let Some(v) = self.card_data_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.has_modify_all_passenger_stat_effect != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.extra_ratio != 0 {
            os.write_uint32(1, self.extra_ratio)?;
        }
        if let Some(v) = self.card_data_list.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if self.has_modify_all_passenger_stat_effect != false {
            os.write_bool(14, self.has_modify_all_passenger_stat_effect)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyCard {
        TrainPartyCard::new()
    }

    fn clear(&mut self) {
        self.extra_ratio = 0;
        self.card_data_list.clear();
        self.has_modify_all_passenger_stat_effect = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyCard {
        static instance: TrainPartyCard = TrainPartyCard {
            extra_ratio: 0,
            card_data_list: ::protobuf::MessageField::none(),
            has_modify_all_passenger_stat_effect: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyCard {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyCard").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyCard {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyGridData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyGridData {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyGridData.GAEIOFOPLFN)
    pub GAEIOFOPLFN: u32,
    // @@protoc_insertion_point(field:TrainPartyGridData.GCIMMFIDPJP)
    pub GCIMMFIDPJP: u32,
    // @@protoc_insertion_point(field:TrainPartyGridData.BPGOFIPCNLA)
    pub BPGOFIPCNLA: u32,
    // @@protoc_insertion_point(field:TrainPartyGridData.unique_id)
    pub unique_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyGridData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyGridData {
    fn default() -> &'a TrainPartyGridData {
        <TrainPartyGridData as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyGridData {
    pub fn new() -> TrainPartyGridData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "GAEIOFOPLFN",
            |m: &TrainPartyGridData| { &m.GAEIOFOPLFN },
            |m: &mut TrainPartyGridData| { &mut m.GAEIOFOPLFN },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "GCIMMFIDPJP",
            |m: &TrainPartyGridData| { &m.GCIMMFIDPJP },
            |m: &mut TrainPartyGridData| { &mut m.GCIMMFIDPJP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "BPGOFIPCNLA",
            |m: &TrainPartyGridData| { &m.BPGOFIPCNLA },
            |m: &mut TrainPartyGridData| { &mut m.BPGOFIPCNLA },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &TrainPartyGridData| { &m.unique_id },
            |m: &mut TrainPartyGridData| { &mut m.unique_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyGridData>(
            "TrainPartyGridData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyGridData {
    const NAME: &'static str = "TrainPartyGridData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.GAEIOFOPLFN = is.read_uint32()?;
                },
                16 => {
                    self.GCIMMFIDPJP = is.read_uint32()?;
                },
                64 => {
                    self.BPGOFIPCNLA = is.read_uint32()?;
                },
                88 => {
                    self.unique_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.GAEIOFOPLFN != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.GAEIOFOPLFN);
        }
        if self.GCIMMFIDPJP != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.GCIMMFIDPJP);
        }
        if self.BPGOFIPCNLA != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.BPGOFIPCNLA);
        }
        if self.unique_id != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.unique_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.GAEIOFOPLFN != 0 {
            os.write_uint32(6, self.GAEIOFOPLFN)?;
        }
        if self.GCIMMFIDPJP != 0 {
            os.write_uint32(2, self.GCIMMFIDPJP)?;
        }
        if self.BPGOFIPCNLA != 0 {
            os.write_uint32(8, self.BPGOFIPCNLA)?;
        }
        if self.unique_id != 0 {
            os.write_uint32(11, self.unique_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyGridData {
        TrainPartyGridData::new()
    }

    fn clear(&mut self) {
        self.GAEIOFOPLFN = 0;
        self.GCIMMFIDPJP = 0;
        self.BPGOFIPCNLA = 0;
        self.unique_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyGridData {
        static instance: TrainPartyGridData = TrainPartyGridData {
            GAEIOFOPLFN: 0,
            GCIMMFIDPJP: 0,
            BPGOFIPCNLA: 0,
            unique_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyGridData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyGridData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyGridData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyGridData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyMeetingCountInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyMeetingCountInfo {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyMeetingCountInfo.AADBGCLODKK)
    pub AADBGCLODKK: u32,
    // @@protoc_insertion_point(field:TrainPartyMeetingCountInfo.HLIDPIFAJCG)
    pub HLIDPIFAJCG: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:TrainPartyMeetingCountInfo.AOJBNMEECHF)
    pub AOJBNMEECHF: u32,
    // @@protoc_insertion_point(field:TrainPartyMeetingCountInfo.DFNCNGPDILM)
    pub DFNCNGPDILM: u32,
    // @@protoc_insertion_point(field:TrainPartyMeetingCountInfo.EPALCFOJBKJ)
    pub EPALCFOJBKJ: u32,
    // @@protoc_insertion_point(field:TrainPartyMeetingCountInfo.ECFPFKNJINA)
    pub ECFPFKNJINA: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyMeetingCountInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyMeetingCountInfo {
    fn default() -> &'a TrainPartyMeetingCountInfo {
        <TrainPartyMeetingCountInfo as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyMeetingCountInfo {
    pub fn new() -> TrainPartyMeetingCountInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "AADBGCLODKK",
            |m: &TrainPartyMeetingCountInfo| { &m.AADBGCLODKK },
            |m: &mut TrainPartyMeetingCountInfo| { &mut m.AADBGCLODKK },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "HLIDPIFAJCG",
            |m: &TrainPartyMeetingCountInfo| { &m.HLIDPIFAJCG },
            |m: &mut TrainPartyMeetingCountInfo| { &mut m.HLIDPIFAJCG },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "AOJBNMEECHF",
            |m: &TrainPartyMeetingCountInfo| { &m.AOJBNMEECHF },
            |m: &mut TrainPartyMeetingCountInfo| { &mut m.AOJBNMEECHF },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DFNCNGPDILM",
            |m: &TrainPartyMeetingCountInfo| { &m.DFNCNGPDILM },
            |m: &mut TrainPartyMeetingCountInfo| { &mut m.DFNCNGPDILM },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "EPALCFOJBKJ",
            |m: &TrainPartyMeetingCountInfo| { &m.EPALCFOJBKJ },
            |m: &mut TrainPartyMeetingCountInfo| { &mut m.EPALCFOJBKJ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ECFPFKNJINA",
            |m: &TrainPartyMeetingCountInfo| { &m.ECFPFKNJINA },
            |m: &mut TrainPartyMeetingCountInfo| { &mut m.ECFPFKNJINA },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyMeetingCountInfo>(
            "TrainPartyMeetingCountInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyMeetingCountInfo {
    const NAME: &'static str = "TrainPartyMeetingCountInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.AADBGCLODKK = is.read_uint32()?;
                },
                122 => {
                    is.read_repeated_packed_uint32_into(&mut self.HLIDPIFAJCG)?;
                },
                120 => {
                    self.HLIDPIFAJCG.push(is.read_uint32()?);
                },
                16 => {
                    self.AOJBNMEECHF = is.read_uint32()?;
                },
                88 => {
                    self.DFNCNGPDILM = is.read_uint32()?;
                },
                32 => {
                    self.EPALCFOJBKJ = is.read_uint32()?;
                },
                80 => {
                    self.ECFPFKNJINA = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.AADBGCLODKK != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.AADBGCLODKK);
        }
        for value in &self.HLIDPIFAJCG {
            my_size += ::protobuf::rt::uint32_size(15, *value);
        };
        if self.AOJBNMEECHF != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.AOJBNMEECHF);
        }
        if self.DFNCNGPDILM != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.DFNCNGPDILM);
        }
        if self.EPALCFOJBKJ != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.EPALCFOJBKJ);
        }
        if self.ECFPFKNJINA != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.ECFPFKNJINA);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.AADBGCLODKK != 0 {
            os.write_uint32(6, self.AADBGCLODKK)?;
        }
        for v in &self.HLIDPIFAJCG {
            os.write_uint32(15, *v)?;
        };
        if self.AOJBNMEECHF != 0 {
            os.write_uint32(2, self.AOJBNMEECHF)?;
        }
        if self.DFNCNGPDILM != 0 {
            os.write_uint32(11, self.DFNCNGPDILM)?;
        }
        if self.EPALCFOJBKJ != 0 {
            os.write_uint32(4, self.EPALCFOJBKJ)?;
        }
        if self.ECFPFKNJINA != 0 {
            os.write_uint32(10, self.ECFPFKNJINA)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyMeetingCountInfo {
        TrainPartyMeetingCountInfo::new()
    }

    fn clear(&mut self) {
        self.AADBGCLODKK = 0;
        self.HLIDPIFAJCG.clear();
        self.AOJBNMEECHF = 0;
        self.DFNCNGPDILM = 0;
        self.EPALCFOJBKJ = 0;
        self.ECFPFKNJINA = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyMeetingCountInfo {
        static instance: TrainPartyMeetingCountInfo = TrainPartyMeetingCountInfo {
            AADBGCLODKK: 0,
            HLIDPIFAJCG: ::std::vec::Vec::new(),
            AOJBNMEECHF: 0,
            DFNCNGPDILM: 0,
            EPALCFOJBKJ: 0,
            ECFPFKNJINA: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyMeetingCountInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyMeetingCountInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyMeetingCountInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyMeetingCountInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyGrids)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyGrids {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyGrids.OOPDLCMLKKL)
    pub OOPDLCMLKKL: u32,
    // @@protoc_insertion_point(field:TrainPartyGrids.NOFPLBABCCB)
    pub NOFPLBABCCB: u32,
    // @@protoc_insertion_point(field:TrainPartyGrids.meeting_count_info)
    pub meeting_count_info: ::protobuf::MessageField<TrainPartyMeetingCountInfo>,
    // @@protoc_insertion_point(field:TrainPartyGrids.ANPNJEKLCJJ)
    pub ANPNJEKLCJJ: ::std::vec::Vec<TrainPartyGridData>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyGrids.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyGrids {
    fn default() -> &'a TrainPartyGrids {
        <TrainPartyGrids as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyGrids {
    pub fn new() -> TrainPartyGrids {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OOPDLCMLKKL",
            |m: &TrainPartyGrids| { &m.OOPDLCMLKKL },
            |m: &mut TrainPartyGrids| { &mut m.OOPDLCMLKKL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NOFPLBABCCB",
            |m: &TrainPartyGrids| { &m.NOFPLBABCCB },
            |m: &mut TrainPartyGrids| { &mut m.NOFPLBABCCB },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyMeetingCountInfo>(
            "meeting_count_info",
            |m: &TrainPartyGrids| { &m.meeting_count_info },
            |m: &mut TrainPartyGrids| { &mut m.meeting_count_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ANPNJEKLCJJ",
            |m: &TrainPartyGrids| { &m.ANPNJEKLCJJ },
            |m: &mut TrainPartyGrids| { &mut m.ANPNJEKLCJJ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyGrids>(
            "TrainPartyGrids",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyGrids {
    const NAME: &'static str = "TrainPartyGrids";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.OOPDLCMLKKL = is.read_uint32()?;
                },
                88 => {
                    self.NOFPLBABCCB = is.read_uint32()?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.meeting_count_info)?;
                },
                18 => {
                    self.ANPNJEKLCJJ.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.OOPDLCMLKKL != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.OOPDLCMLKKL);
        }
        if self.NOFPLBABCCB != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.NOFPLBABCCB);
        }
        if let Some(v) = self.meeting_count_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ANPNJEKLCJJ {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.OOPDLCMLKKL != 0 {
            os.write_uint32(4, self.OOPDLCMLKKL)?;
        }
        if self.NOFPLBABCCB != 0 {
            os.write_uint32(11, self.NOFPLBABCCB)?;
        }
        if let Some(v) = self.meeting_count_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        for v in &self.ANPNJEKLCJJ {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyGrids {
        TrainPartyGrids::new()
    }

    fn clear(&mut self) {
        self.OOPDLCMLKKL = 0;
        self.NOFPLBABCCB = 0;
        self.meeting_count_info.clear();
        self.ANPNJEKLCJJ.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyGrids {
        static instance: TrainPartyGrids = TrainPartyGrids {
            OOPDLCMLKKL: 0,
            NOFPLBABCCB: 0,
            meeting_count_info: ::protobuf::MessageField::none(),
            ANPNJEKLCJJ: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyGrids {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyGrids").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyGrids {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyGrids {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyPassengerStatusInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyPassengerStatusInfo {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyPassengerStatusInfo.DDELOEPNMPM)
    pub DDELOEPNMPM: u32,
    // @@protoc_insertion_point(field:TrainPartyPassengerStatusInfo.KLAAHPFNMHP)
    pub KLAAHPFNMHP: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyPassengerStatusInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyPassengerStatusInfo {
    fn default() -> &'a TrainPartyPassengerStatusInfo {
        <TrainPartyPassengerStatusInfo as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyPassengerStatusInfo {
    pub fn new() -> TrainPartyPassengerStatusInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DDELOEPNMPM",
            |m: &TrainPartyPassengerStatusInfo| { &m.DDELOEPNMPM },
            |m: &mut TrainPartyPassengerStatusInfo| { &mut m.DDELOEPNMPM },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "KLAAHPFNMHP",
            |m: &TrainPartyPassengerStatusInfo| { &m.KLAAHPFNMHP },
            |m: &mut TrainPartyPassengerStatusInfo| { &mut m.KLAAHPFNMHP },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyPassengerStatusInfo>(
            "TrainPartyPassengerStatusInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyPassengerStatusInfo {
    const NAME: &'static str = "TrainPartyPassengerStatusInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.DDELOEPNMPM = is.read_uint32()?;
                },
                104 => {
                    self.KLAAHPFNMHP = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.DDELOEPNMPM != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.DDELOEPNMPM);
        }
        if self.KLAAHPFNMHP != 0 {
            my_size += ::protobuf::rt::uint32_size(13, self.KLAAHPFNMHP);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.DDELOEPNMPM != 0 {
            os.write_uint32(2, self.DDELOEPNMPM)?;
        }
        if self.KLAAHPFNMHP != 0 {
            os.write_uint32(13, self.KLAAHPFNMHP)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyPassengerStatusInfo {
        TrainPartyPassengerStatusInfo::new()
    }

    fn clear(&mut self) {
        self.DDELOEPNMPM = 0;
        self.KLAAHPFNMHP = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyPassengerStatusInfo {
        static instance: TrainPartyPassengerStatusInfo = TrainPartyPassengerStatusInfo {
            DDELOEPNMPM: 0,
            KLAAHPFNMHP: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyPassengerStatusInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyPassengerStatusInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyPassengerStatusInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyPassengerStatusInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyPassengerSkillInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyPassengerSkillInfo {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyPassengerSkillInfo.MOCKIOPKEKE)
    pub MOCKIOPKEKE: u32,
    // @@protoc_insertion_point(field:TrainPartyPassengerSkillInfo.NCPFPAMHAOE)
    pub NCPFPAMHAOE: u32,
    // @@protoc_insertion_point(field:TrainPartyPassengerSkillInfo.FIIDGPNOEDE)
    pub FIIDGPNOEDE: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyPassengerSkillInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyPassengerSkillInfo {
    fn default() -> &'a TrainPartyPassengerSkillInfo {
        <TrainPartyPassengerSkillInfo as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyPassengerSkillInfo {
    pub fn new() -> TrainPartyPassengerSkillInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MOCKIOPKEKE",
            |m: &TrainPartyPassengerSkillInfo| { &m.MOCKIOPKEKE },
            |m: &mut TrainPartyPassengerSkillInfo| { &mut m.MOCKIOPKEKE },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NCPFPAMHAOE",
            |m: &TrainPartyPassengerSkillInfo| { &m.NCPFPAMHAOE },
            |m: &mut TrainPartyPassengerSkillInfo| { &mut m.NCPFPAMHAOE },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "FIIDGPNOEDE",
            |m: &TrainPartyPassengerSkillInfo| { &m.FIIDGPNOEDE },
            |m: &mut TrainPartyPassengerSkillInfo| { &mut m.FIIDGPNOEDE },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyPassengerSkillInfo>(
            "TrainPartyPassengerSkillInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyPassengerSkillInfo {
    const NAME: &'static str = "TrainPartyPassengerSkillInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                64 => {
                    self.MOCKIOPKEKE = is.read_uint32()?;
                },
                48 => {
                    self.NCPFPAMHAOE = is.read_uint32()?;
                },
                40 => {
                    self.FIIDGPNOEDE = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.MOCKIOPKEKE != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.MOCKIOPKEKE);
        }
        if self.NCPFPAMHAOE != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.NCPFPAMHAOE);
        }
        if self.FIIDGPNOEDE != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.FIIDGPNOEDE);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.MOCKIOPKEKE != 0 {
            os.write_uint32(8, self.MOCKIOPKEKE)?;
        }
        if self.NCPFPAMHAOE != 0 {
            os.write_uint32(6, self.NCPFPAMHAOE)?;
        }
        if self.FIIDGPNOEDE != 0 {
            os.write_uint32(5, self.FIIDGPNOEDE)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyPassengerSkillInfo {
        TrainPartyPassengerSkillInfo::new()
    }

    fn clear(&mut self) {
        self.MOCKIOPKEKE = 0;
        self.NCPFPAMHAOE = 0;
        self.FIIDGPNOEDE = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyPassengerSkillInfo {
        static instance: TrainPartyPassengerSkillInfo = TrainPartyPassengerSkillInfo {
            MOCKIOPKEKE: 0,
            NCPFPAMHAOE: 0,
            FIIDGPNOEDE: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyPassengerSkillInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyPassengerSkillInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyPassengerSkillInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyPassengerSkillInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyPassengerData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyPassengerData {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyPassengerData.DIKPBINAOOH)
    pub DIKPBINAOOH: u32,
    // @@protoc_insertion_point(field:TrainPartyPassengerData.passenger_id)
    pub passenger_id: u32,
    // @@protoc_insertion_point(field:TrainPartyPassengerData.status_info)
    pub status_info: ::protobuf::MessageField<TrainPartyPassengerStatusInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyPassengerData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyPassengerData {
    fn default() -> &'a TrainPartyPassengerData {
        <TrainPartyPassengerData as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyPassengerData {
    pub fn new() -> TrainPartyPassengerData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DIKPBINAOOH",
            |m: &TrainPartyPassengerData| { &m.DIKPBINAOOH },
            |m: &mut TrainPartyPassengerData| { &mut m.DIKPBINAOOH },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "passenger_id",
            |m: &TrainPartyPassengerData| { &m.passenger_id },
            |m: &mut TrainPartyPassengerData| { &mut m.passenger_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyPassengerStatusInfo>(
            "status_info",
            |m: &TrainPartyPassengerData| { &m.status_info },
            |m: &mut TrainPartyPassengerData| { &mut m.status_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyPassengerData>(
            "TrainPartyPassengerData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyPassengerData {
    const NAME: &'static str = "TrainPartyPassengerData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                88 => {
                    self.DIKPBINAOOH = is.read_uint32()?;
                },
                80 => {
                    self.passenger_id = is.read_uint32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.DIKPBINAOOH != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.DIKPBINAOOH);
        }
        if self.passenger_id != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.passenger_id);
        }
        if let Some(v) = self.status_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.DIKPBINAOOH != 0 {
            os.write_uint32(11, self.DIKPBINAOOH)?;
        }
        if self.passenger_id != 0 {
            os.write_uint32(10, self.passenger_id)?;
        }
        if let Some(v) = self.status_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyPassengerData {
        TrainPartyPassengerData::new()
    }

    fn clear(&mut self) {
        self.DIKPBINAOOH = 0;
        self.passenger_id = 0;
        self.status_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyPassengerData {
        static instance: TrainPartyPassengerData = TrainPartyPassengerData {
            DIKPBINAOOH: 0,
            passenger_id: 0,
            status_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyPassengerData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyPassengerData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyPassengerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyPassengerData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyPassengerPersistentData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyPassengerPersistentData {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyPassengerPersistentData.attempts)
    pub attempts: u32,
    // @@protoc_insertion_point(field:TrainPartyPassengerPersistentData.DNGLGOMMFNP)
    pub DNGLGOMMFNP: bool,
    // @@protoc_insertion_point(field:TrainPartyPassengerPersistentData.diary_data_list)
    pub diary_data_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:TrainPartyPassengerPersistentData.passenger_id)
    pub passenger_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyPassengerPersistentData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyPassengerPersistentData {
    fn default() -> &'a TrainPartyPassengerPersistentData {
        <TrainPartyPassengerPersistentData as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyPassengerPersistentData {
    pub fn new() -> TrainPartyPassengerPersistentData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "attempts",
            |m: &TrainPartyPassengerPersistentData| { &m.attempts },
            |m: &mut TrainPartyPassengerPersistentData| { &mut m.attempts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DNGLGOMMFNP",
            |m: &TrainPartyPassengerPersistentData| { &m.DNGLGOMMFNP },
            |m: &mut TrainPartyPassengerPersistentData| { &mut m.DNGLGOMMFNP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "diary_data_list",
            |m: &TrainPartyPassengerPersistentData| { &m.diary_data_list },
            |m: &mut TrainPartyPassengerPersistentData| { &mut m.diary_data_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "passenger_id",
            |m: &TrainPartyPassengerPersistentData| { &m.passenger_id },
            |m: &mut TrainPartyPassengerPersistentData| { &mut m.passenger_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyPassengerPersistentData>(
            "TrainPartyPassengerPersistentData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyPassengerPersistentData {
    const NAME: &'static str = "TrainPartyPassengerPersistentData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                96 => {
                    self.attempts = is.read_uint32()?;
                },
                88 => {
                    self.DNGLGOMMFNP = is.read_bool()?;
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.diary_data_list)?;
                },
                40 => {
                    self.diary_data_list.push(is.read_uint32()?);
                },
                64 => {
                    self.passenger_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.attempts != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.attempts);
        }
        if self.DNGLGOMMFNP != false {
            my_size += 1 + 1;
        }
        for value in &self.diary_data_list {
            my_size += ::protobuf::rt::uint32_size(5, *value);
        };
        if self.passenger_id != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.passenger_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.attempts != 0 {
            os.write_uint32(12, self.attempts)?;
        }
        if self.DNGLGOMMFNP != false {
            os.write_bool(11, self.DNGLGOMMFNP)?;
        }
        for v in &self.diary_data_list {
            os.write_uint32(5, *v)?;
        };
        if self.passenger_id != 0 {
            os.write_uint32(8, self.passenger_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyPassengerPersistentData {
        TrainPartyPassengerPersistentData::new()
    }

    fn clear(&mut self) {
        self.attempts = 0;
        self.DNGLGOMMFNP = false;
        self.diary_data_list.clear();
        self.passenger_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyPassengerPersistentData {
        static instance: TrainPartyPassengerPersistentData = TrainPartyPassengerPersistentData {
            attempts: 0,
            DNGLGOMMFNP: false,
            diary_data_list: ::std::vec::Vec::new(),
            passenger_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyPassengerPersistentData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyPassengerPersistentData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyPassengerPersistentData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyPassengerPersistentData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyPassenger)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyPassenger {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyPassenger.NINMOLKELOE)
    pub NINMOLKELOE: u32,
    // @@protoc_insertion_point(field:TrainPartyPassenger.passenger_data_list)
    pub passenger_data_list: ::std::vec::Vec<TrainPartyPassengerData>,
    // @@protoc_insertion_point(field:TrainPartyPassenger.upgrade_level)
    pub upgrade_level: u32,
    // @@protoc_insertion_point(field:TrainPartyPassenger.FGAGEPHCGGI)
    pub FGAGEPHCGGI: u32,
    // @@protoc_insertion_point(field:TrainPartyPassenger.skill_info_list)
    pub skill_info_list: ::std::vec::Vec<TrainPartyPassengerSkillInfo>,
    // @@protoc_insertion_point(field:TrainPartyPassenger.MNDKAKMGDPH)
    pub MNDKAKMGDPH: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyPassenger.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyPassenger {
    fn default() -> &'a TrainPartyPassenger {
        <TrainPartyPassenger as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyPassenger {
    pub fn new() -> TrainPartyPassenger {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NINMOLKELOE",
            |m: &TrainPartyPassenger| { &m.NINMOLKELOE },
            |m: &mut TrainPartyPassenger| { &mut m.NINMOLKELOE },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "passenger_data_list",
            |m: &TrainPartyPassenger| { &m.passenger_data_list },
            |m: &mut TrainPartyPassenger| { &mut m.passenger_data_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upgrade_level",
            |m: &TrainPartyPassenger| { &m.upgrade_level },
            |m: &mut TrainPartyPassenger| { &mut m.upgrade_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "FGAGEPHCGGI",
            |m: &TrainPartyPassenger| { &m.FGAGEPHCGGI },
            |m: &mut TrainPartyPassenger| { &mut m.FGAGEPHCGGI },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "skill_info_list",
            |m: &TrainPartyPassenger| { &m.skill_info_list },
            |m: &mut TrainPartyPassenger| { &mut m.skill_info_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "MNDKAKMGDPH",
            |m: &TrainPartyPassenger| { &m.MNDKAKMGDPH },
            |m: &mut TrainPartyPassenger| { &mut m.MNDKAKMGDPH },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyPassenger>(
            "TrainPartyPassenger",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyPassenger {
    const NAME: &'static str = "TrainPartyPassenger";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                120 => {
                    self.NINMOLKELOE = is.read_uint32()?;
                },
                114 => {
                    self.passenger_data_list.push(is.read_message()?);
                },
                24 => {
                    self.upgrade_level = is.read_uint32()?;
                },
                40 => {
                    self.FGAGEPHCGGI = is.read_uint32()?;
                },
                66 => {
                    self.skill_info_list.push(is.read_message()?);
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.MNDKAKMGDPH)?;
                },
                56 => {
                    self.MNDKAKMGDPH.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.NINMOLKELOE != 0 {
            my_size += ::protobuf::rt::uint32_size(15, self.NINMOLKELOE);
        }
        for value in &self.passenger_data_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.upgrade_level != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.upgrade_level);
        }
        if self.FGAGEPHCGGI != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.FGAGEPHCGGI);
        }
        for value in &self.skill_info_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.MNDKAKMGDPH {
            my_size += ::protobuf::rt::uint32_size(7, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.NINMOLKELOE != 0 {
            os.write_uint32(15, self.NINMOLKELOE)?;
        }
        for v in &self.passenger_data_list {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        if self.upgrade_level != 0 {
            os.write_uint32(3, self.upgrade_level)?;
        }
        if self.FGAGEPHCGGI != 0 {
            os.write_uint32(5, self.FGAGEPHCGGI)?;
        }
        for v in &self.skill_info_list {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.MNDKAKMGDPH {
            os.write_uint32(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyPassenger {
        TrainPartyPassenger::new()
    }

    fn clear(&mut self) {
        self.NINMOLKELOE = 0;
        self.passenger_data_list.clear();
        self.upgrade_level = 0;
        self.FGAGEPHCGGI = 0;
        self.skill_info_list.clear();
        self.MNDKAKMGDPH.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyPassenger {
        static instance: TrainPartyPassenger = TrainPartyPassenger {
            NINMOLKELOE: 0,
            passenger_data_list: ::std::vec::Vec::new(),
            upgrade_level: 0,
            FGAGEPHCGGI: 0,
            skill_info_list: ::std::vec::Vec::new(),
            MNDKAKMGDPH: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyPassenger {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyPassenger").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyPassenger {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyPassenger {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyPersistentPassenger)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyPersistentPassenger {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyPersistentPassenger.passenger_persistent_data_list)
    pub passenger_persistent_data_list: ::std::vec::Vec<TrainPartyPassengerPersistentData>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyPersistentPassenger.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyPersistentPassenger {
    fn default() -> &'a TrainPartyPersistentPassenger {
        <TrainPartyPersistentPassenger as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyPersistentPassenger {
    pub fn new() -> TrainPartyPersistentPassenger {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "passenger_persistent_data_list",
            |m: &TrainPartyPersistentPassenger| { &m.passenger_persistent_data_list },
            |m: &mut TrainPartyPersistentPassenger| { &mut m.passenger_persistent_data_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyPersistentPassenger>(
            "TrainPartyPersistentPassenger",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyPersistentPassenger {
    const NAME: &'static str = "TrainPartyPersistentPassenger";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.passenger_persistent_data_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.passenger_persistent_data_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.passenger_persistent_data_list {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyPersistentPassenger {
        TrainPartyPersistentPassenger::new()
    }

    fn clear(&mut self) {
        self.passenger_persistent_data_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyPersistentPassenger {
        static instance: TrainPartyPersistentPassenger = TrainPartyPersistentPassenger {
            passenger_persistent_data_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyPersistentPassenger {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyPersistentPassenger").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyPersistentPassenger {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyPersistentPassenger {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyAreaInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyAreaInfo {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyAreaInfo.area_id)
    pub area_id: u32,
    // @@protoc_insertion_point(field:TrainPartyAreaInfo.build_slot_list)
    pub build_slot_list: ::std::vec::Vec<TrainPartyBuildSlotInfo>,
    // @@protoc_insertion_point(field:TrainPartyAreaInfo.step_id_list)
    pub step_id_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:TrainPartyAreaInfo.step_pages)
    pub step_pages: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:TrainPartyAreaInfo.progress)
    pub progress: u32,
    // @@protoc_insertion_point(field:TrainPartyAreaInfo.build_goal)
    pub build_goal: ::protobuf::MessageField<TrainPartyBuildGoalData>,
    // @@protoc_insertion_point(field:TrainPartyAreaInfo.static_config_list)
    pub static_config_list: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyAreaInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyAreaInfo {
    fn default() -> &'a TrainPartyAreaInfo {
        <TrainPartyAreaInfo as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyAreaInfo {
    pub fn new() -> TrainPartyAreaInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "area_id",
            |m: &TrainPartyAreaInfo| { &m.area_id },
            |m: &mut TrainPartyAreaInfo| { &mut m.area_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "build_slot_list",
            |m: &TrainPartyAreaInfo| { &m.build_slot_list },
            |m: &mut TrainPartyAreaInfo| { &mut m.build_slot_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "step_id_list",
            |m: &TrainPartyAreaInfo| { &m.step_id_list },
            |m: &mut TrainPartyAreaInfo| { &mut m.step_id_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "step_pages",
            |m: &TrainPartyAreaInfo| { &m.step_pages },
            |m: &mut TrainPartyAreaInfo| { &mut m.step_pages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "progress",
            |m: &TrainPartyAreaInfo| { &m.progress },
            |m: &mut TrainPartyAreaInfo| { &mut m.progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyBuildGoalData>(
            "build_goal",
            |m: &TrainPartyAreaInfo| { &m.build_goal },
            |m: &mut TrainPartyAreaInfo| { &mut m.build_goal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "static_config_list",
            |m: &TrainPartyAreaInfo| { &m.static_config_list },
            |m: &mut TrainPartyAreaInfo| { &mut m.static_config_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyAreaInfo>(
            "TrainPartyAreaInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyAreaInfo {
    const NAME: &'static str = "TrainPartyAreaInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                104 => {
                    self.area_id = is.read_uint32()?;
                },
                18 => {
                    self.build_slot_list.push(is.read_message()?);
                },
                90 => {
                    is.read_repeated_packed_uint32_into(&mut self.step_id_list)?;
                },
                88 => {
                    self.step_id_list.push(is.read_uint32()?);
                },
                122 => {
                    is.read_repeated_packed_uint32_into(&mut self.step_pages)?;
                },
                120 => {
                    self.step_pages.push(is.read_uint32()?);
                },
                112 => {
                    self.progress = is.read_uint32()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.build_goal)?;
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.static_config_list)?;
                },
                64 => {
                    self.static_config_list.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.area_id != 0 {
            my_size += ::protobuf::rt::uint32_size(13, self.area_id);
        }
        for value in &self.build_slot_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.step_id_list {
            my_size += ::protobuf::rt::uint32_size(11, *value);
        };
        for value in &self.step_pages {
            my_size += ::protobuf::rt::uint32_size(15, *value);
        };
        if self.progress != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.progress);
        }
        if let Some(v) = self.build_goal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.static_config_list {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.area_id != 0 {
            os.write_uint32(13, self.area_id)?;
        }
        for v in &self.build_slot_list {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.step_id_list {
            os.write_uint32(11, *v)?;
        };
        for v in &self.step_pages {
            os.write_uint32(15, *v)?;
        };
        if self.progress != 0 {
            os.write_uint32(14, self.progress)?;
        }
        if let Some(v) = self.build_goal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.static_config_list {
            os.write_uint32(8, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyAreaInfo {
        TrainPartyAreaInfo::new()
    }

    fn clear(&mut self) {
        self.area_id = 0;
        self.build_slot_list.clear();
        self.step_id_list.clear();
        self.step_pages.clear();
        self.progress = 0;
        self.build_goal.clear();
        self.static_config_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyAreaInfo {
        static instance: TrainPartyAreaInfo = TrainPartyAreaInfo {
            area_id: 0,
            build_slot_list: ::std::vec::Vec::new(),
            step_id_list: ::std::vec::Vec::new(),
            step_pages: ::std::vec::Vec::new(),
            progress: 0,
            build_goal: ::protobuf::MessageField::none(),
            static_config_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyAreaInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyAreaInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyAreaInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyAreaInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HHOKBPHNFNE)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HHOKBPHNFNE {
    // message fields
    // @@protoc_insertion_point(field:HHOKBPHNFNE.step_pages)
    pub step_pages: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:HHOKBPHNFNE.area_id)
    pub area_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:HHOKBPHNFNE.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HHOKBPHNFNE {
    fn default() -> &'a HHOKBPHNFNE {
        <HHOKBPHNFNE as ::protobuf::Message>::default_instance()
    }
}

impl HHOKBPHNFNE {
    pub fn new() -> HHOKBPHNFNE {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "step_pages",
            |m: &HHOKBPHNFNE| { &m.step_pages },
            |m: &mut HHOKBPHNFNE| { &mut m.step_pages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "area_id",
            |m: &HHOKBPHNFNE| { &m.area_id },
            |m: &mut HHOKBPHNFNE| { &mut m.area_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HHOKBPHNFNE>(
            "HHOKBPHNFNE",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HHOKBPHNFNE {
    const NAME: &'static str = "HHOKBPHNFNE";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.step_pages)?;
                },
                40 => {
                    self.step_pages.push(is.read_uint32()?);
                },
                72 => {
                    self.area_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.step_pages {
            my_size += ::protobuf::rt::uint32_size(5, *value);
        };
        if self.area_id != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.area_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.step_pages {
            os.write_uint32(5, *v)?;
        };
        if self.area_id != 0 {
            os.write_uint32(9, self.area_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HHOKBPHNFNE {
        HHOKBPHNFNE::new()
    }

    fn clear(&mut self) {
        self.step_pages.clear();
        self.area_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HHOKBPHNFNE {
        static instance: HHOKBPHNFNE = HHOKBPHNFNE {
            step_pages: ::std::vec::Vec::new(),
            area_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HHOKBPHNFNE {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HHOKBPHNFNE").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HHOKBPHNFNE {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HHOKBPHNFNE {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyBuildStepInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyBuildStepInfo {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyBuildStepInfo.status)
    pub status: ::protobuf::EnumOrUnknown<TrainPartyBuildStatus>,
    // @@protoc_insertion_point(field:TrainPartyBuildStepInfo.step_id)
    pub step_id: u32,
    // @@protoc_insertion_point(field:TrainPartyBuildStepInfo.MJALJMGLEFP)
    pub MJALJMGLEFP: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyBuildStepInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyBuildStepInfo {
    fn default() -> &'a TrainPartyBuildStepInfo {
        <TrainPartyBuildStepInfo as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyBuildStepInfo {
    pub fn new() -> TrainPartyBuildStepInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &TrainPartyBuildStepInfo| { &m.status },
            |m: &mut TrainPartyBuildStepInfo| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "step_id",
            |m: &TrainPartyBuildStepInfo| { &m.step_id },
            |m: &mut TrainPartyBuildStepInfo| { &mut m.step_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MJALJMGLEFP",
            |m: &TrainPartyBuildStepInfo| { &m.MJALJMGLEFP },
            |m: &mut TrainPartyBuildStepInfo| { &mut m.MJALJMGLEFP },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyBuildStepInfo>(
            "TrainPartyBuildStepInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyBuildStepInfo {
    const NAME: &'static str = "TrainPartyBuildStepInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                88 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                8 => {
                    self.step_id = is.read_uint32()?;
                },
                56 => {
                    self.MJALJMGLEFP = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.status != ::protobuf::EnumOrUnknown::new(TrainPartyBuildStatus::BuildGoalStepNone) {
            my_size += ::protobuf::rt::int32_size(11, self.status.value());
        }
        if self.step_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.step_id);
        }
        if self.MJALJMGLEFP != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.MJALJMGLEFP);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.status != ::protobuf::EnumOrUnknown::new(TrainPartyBuildStatus::BuildGoalStepNone) {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if self.step_id != 0 {
            os.write_uint32(1, self.step_id)?;
        }
        if self.MJALJMGLEFP != 0 {
            os.write_uint32(7, self.MJALJMGLEFP)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyBuildStepInfo {
        TrainPartyBuildStepInfo::new()
    }

    fn clear(&mut self) {
        self.status = ::protobuf::EnumOrUnknown::new(TrainPartyBuildStatus::BuildGoalStepNone);
        self.step_id = 0;
        self.MJALJMGLEFP = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyBuildStepInfo {
        static instance: TrainPartyBuildStepInfo = TrainPartyBuildStepInfo {
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            step_id: 0,
            MJALJMGLEFP: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyBuildStepInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyBuildStepInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyBuildStepInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyBuildStepInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyBuildGoalData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyBuildGoalData {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyBuildGoalData.build_step_list)
    pub build_step_list: ::std::vec::Vec<TrainPartyBuildStepInfo>,
    // @@protoc_insertion_point(field:TrainPartyBuildGoalData.goal_id)
    pub goal_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyBuildGoalData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyBuildGoalData {
    fn default() -> &'a TrainPartyBuildGoalData {
        <TrainPartyBuildGoalData as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyBuildGoalData {
    pub fn new() -> TrainPartyBuildGoalData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "build_step_list",
            |m: &TrainPartyBuildGoalData| { &m.build_step_list },
            |m: &mut TrainPartyBuildGoalData| { &mut m.build_step_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "goal_id",
            |m: &TrainPartyBuildGoalData| { &m.goal_id },
            |m: &mut TrainPartyBuildGoalData| { &mut m.goal_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyBuildGoalData>(
            "TrainPartyBuildGoalData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyBuildGoalData {
    const NAME: &'static str = "TrainPartyBuildGoalData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                58 => {
                    self.build_step_list.push(is.read_message()?);
                },
                88 => {
                    self.goal_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.build_step_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.goal_id != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.goal_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.build_step_list {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if self.goal_id != 0 {
            os.write_uint32(11, self.goal_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyBuildGoalData {
        TrainPartyBuildGoalData::new()
    }

    fn clear(&mut self) {
        self.build_step_list.clear();
        self.goal_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyBuildGoalData {
        static instance: TrainPartyBuildGoalData = TrainPartyBuildGoalData {
            build_step_list: ::std::vec::Vec::new(),
            goal_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyBuildGoalData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyBuildGoalData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyBuildGoalData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyBuildGoalData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyBuildSlotInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyBuildSlotInfo {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyBuildSlotInfo.slot_id)
    pub slot_id: u32,
    // @@protoc_insertion_point(field:TrainPartyBuildSlotInfo.dynamic_prop_id)
    pub dynamic_prop_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyBuildSlotInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyBuildSlotInfo {
    fn default() -> &'a TrainPartyBuildSlotInfo {
        <TrainPartyBuildSlotInfo as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyBuildSlotInfo {
    pub fn new() -> TrainPartyBuildSlotInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot_id",
            |m: &TrainPartyBuildSlotInfo| { &m.slot_id },
            |m: &mut TrainPartyBuildSlotInfo| { &mut m.slot_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dynamic_prop_id",
            |m: &TrainPartyBuildSlotInfo| { &m.dynamic_prop_id },
            |m: &mut TrainPartyBuildSlotInfo| { &mut m.dynamic_prop_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyBuildSlotInfo>(
            "TrainPartyBuildSlotInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyBuildSlotInfo {
    const NAME: &'static str = "TrainPartyBuildSlotInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.slot_id = is.read_uint32()?;
                },
                88 => {
                    self.dynamic_prop_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.slot_id != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.slot_id);
        }
        if self.dynamic_prop_id != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.dynamic_prop_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.slot_id != 0 {
            os.write_uint32(6, self.slot_id)?;
        }
        if self.dynamic_prop_id != 0 {
            os.write_uint32(11, self.dynamic_prop_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyBuildSlotInfo {
        TrainPartyBuildSlotInfo::new()
    }

    fn clear(&mut self) {
        self.slot_id = 0;
        self.dynamic_prop_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyBuildSlotInfo {
        static instance: TrainPartyBuildSlotInfo = TrainPartyBuildSlotInfo {
            slot_id: 0,
            dynamic_prop_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyBuildSlotInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyBuildSlotInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyBuildSlotInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyBuildSlotInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyBuildInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyBuildInfo {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyBuildInfo.area_info_list)
    pub area_info_list: ::std::vec::Vec<TrainPartyAreaInfo>,
    // @@protoc_insertion_point(field:TrainPartyBuildInfo.funds)
    pub funds: u32,
    // @@protoc_insertion_point(field:TrainPartyBuildInfo.build_progress)
    pub build_progress: u32,
    // @@protoc_insertion_point(field:TrainPartyBuildInfo.NNBHLDDNLDE)
    pub NNBHLDDNLDE: ::std::vec::Vec<super::HHOKBPHNFNE::HHOKBPHNFNE>,
    // @@protoc_insertion_point(field:TrainPartyBuildInfo.CFJKBJHNIJM)
    pub CFJKBJHNIJM: u32,
    // @@protoc_insertion_point(field:TrainPartyBuildInfo.build_level)
    pub build_level: u32,
    // @@protoc_insertion_point(field:TrainPartyBuildInfo.KCFEECACMOD)
    pub KCFEECACMOD: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:TrainPartyBuildInfo.CDJFDJIAING)
    pub CDJFDJIAING: u32,
    // @@protoc_insertion_point(field:TrainPartyBuildInfo.dynamic_config_list)
    pub dynamic_config_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:TrainPartyBuildInfo.build_star)
    pub build_star: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyBuildInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyBuildInfo {
    fn default() -> &'a TrainPartyBuildInfo {
        <TrainPartyBuildInfo as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyBuildInfo {
    pub fn new() -> TrainPartyBuildInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "area_info_list",
            |m: &TrainPartyBuildInfo| { &m.area_info_list },
            |m: &mut TrainPartyBuildInfo| { &mut m.area_info_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "funds",
            |m: &TrainPartyBuildInfo| { &m.funds },
            |m: &mut TrainPartyBuildInfo| { &mut m.funds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "build_progress",
            |m: &TrainPartyBuildInfo| { &m.build_progress },
            |m: &mut TrainPartyBuildInfo| { &mut m.build_progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "NNBHLDDNLDE",
            |m: &TrainPartyBuildInfo| { &m.NNBHLDDNLDE },
            |m: &mut TrainPartyBuildInfo| { &mut m.NNBHLDDNLDE },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CFJKBJHNIJM",
            |m: &TrainPartyBuildInfo| { &m.CFJKBJHNIJM },
            |m: &mut TrainPartyBuildInfo| { &mut m.CFJKBJHNIJM },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "build_level",
            |m: &TrainPartyBuildInfo| { &m.build_level },
            |m: &mut TrainPartyBuildInfo| { &mut m.build_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "KCFEECACMOD",
            |m: &TrainPartyBuildInfo| { &m.KCFEECACMOD },
            |m: &mut TrainPartyBuildInfo| { &mut m.KCFEECACMOD },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CDJFDJIAING",
            |m: &TrainPartyBuildInfo| { &m.CDJFDJIAING },
            |m: &mut TrainPartyBuildInfo| { &mut m.CDJFDJIAING },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dynamic_config_list",
            |m: &TrainPartyBuildInfo| { &m.dynamic_config_list },
            |m: &mut TrainPartyBuildInfo| { &mut m.dynamic_config_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "build_star",
            |m: &TrainPartyBuildInfo| { &m.build_star },
            |m: &mut TrainPartyBuildInfo| { &mut m.build_star },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyBuildInfo>(
            "TrainPartyBuildInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyBuildInfo {
    const NAME: &'static str = "TrainPartyBuildInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                98 => {
                    self.area_info_list.push(is.read_message()?);
                },
                16 => {
                    self.funds = is.read_uint32()?;
                },
                40 => {
                    self.build_progress = is.read_uint32()?;
                },
                66 => {
                    self.NNBHLDDNLDE.push(is.read_message()?);
                },
                112 => {
                    self.CFJKBJHNIJM = is.read_uint32()?;
                },
                48 => {
                    self.build_level = is.read_uint32()?;
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.KCFEECACMOD)?;
                },
                80 => {
                    self.KCFEECACMOD.push(is.read_uint32()?);
                },
                8 => {
                    self.CDJFDJIAING = is.read_uint32()?;
                },
                122 => {
                    is.read_repeated_packed_uint32_into(&mut self.dynamic_config_list)?;
                },
                120 => {
                    self.dynamic_config_list.push(is.read_uint32()?);
                },
                104 => {
                    self.build_star = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.area_info_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.funds != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.funds);
        }
        if self.build_progress != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.build_progress);
        }
        for value in &self.NNBHLDDNLDE {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.CFJKBJHNIJM != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.CFJKBJHNIJM);
        }
        if self.build_level != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.build_level);
        }
        for value in &self.KCFEECACMOD {
            my_size += ::protobuf::rt::uint32_size(10, *value);
        };
        if self.CDJFDJIAING != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.CDJFDJIAING);
        }
        for value in &self.dynamic_config_list {
            my_size += ::protobuf::rt::uint32_size(15, *value);
        };
        if self.build_star != 0 {
            my_size += ::protobuf::rt::uint32_size(13, self.build_star);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.area_info_list {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        if self.funds != 0 {
            os.write_uint32(2, self.funds)?;
        }
        if self.build_progress != 0 {
            os.write_uint32(5, self.build_progress)?;
        }
        for v in &self.NNBHLDDNLDE {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if self.CFJKBJHNIJM != 0 {
            os.write_uint32(14, self.CFJKBJHNIJM)?;
        }
        if self.build_level != 0 {
            os.write_uint32(6, self.build_level)?;
        }
        for v in &self.KCFEECACMOD {
            os.write_uint32(10, *v)?;
        };
        if self.CDJFDJIAING != 0 {
            os.write_uint32(1, self.CDJFDJIAING)?;
        }
        for v in &self.dynamic_config_list {
            os.write_uint32(15, *v)?;
        };
        if self.build_star != 0 {
            os.write_uint32(13, self.build_star)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyBuildInfo {
        TrainPartyBuildInfo::new()
    }

    fn clear(&mut self) {
        self.area_info_list.clear();
        self.funds = 0;
        self.build_progress = 0;
        self.NNBHLDDNLDE.clear();
        self.CFJKBJHNIJM = 0;
        self.build_level = 0;
        self.KCFEECACMOD.clear();
        self.CDJFDJIAING = 0;
        self.dynamic_config_list.clear();
        self.build_star = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyBuildInfo {
        static instance: TrainPartyBuildInfo = TrainPartyBuildInfo {
            area_info_list: ::std::vec::Vec::new(),
            funds: 0,
            build_progress: 0,
            NNBHLDDNLDE: ::std::vec::Vec::new(),
            CFJKBJHNIJM: 0,
            build_level: 0,
            KCFEECACMOD: ::std::vec::Vec::new(),
            CDJFDJIAING: 0,
            dynamic_config_list: ::std::vec::Vec::new(),
            build_star: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyBuildInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyBuildInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyBuildInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyBuildInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyGameInstance)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyGameInstance {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyGameInstance.train_party_persistent_passenger)
    pub train_party_persistent_passenger: ::protobuf::MessageField<TrainPartyPersistentPassenger>,
    // @@protoc_insertion_point(field:TrainPartyGameInstance.NPKLLEHIOAL)
    pub NPKLLEHIOAL: u32,
    // @@protoc_insertion_point(field:TrainPartyGameInstance.build_info)
    pub build_info: ::protobuf::MessageField<TrainPartyBuildInfo>,
    // @@protoc_insertion_point(field:TrainPartyGameInstance.gameplay_data)
    pub gameplay_data: ::protobuf::MessageField<TrainPartyGameplayData>,
    // @@protoc_insertion_point(field:TrainPartyGameInstance.room_unlock)
    pub room_unlock: u32,
    // @@protoc_insertion_point(field:TrainPartyGameInstance.attempts)
    pub attempts: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyGameInstance.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyGameInstance {
    fn default() -> &'a TrainPartyGameInstance {
        <TrainPartyGameInstance as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyGameInstance {
    pub fn new() -> TrainPartyGameInstance {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyPersistentPassenger>(
            "train_party_persistent_passenger",
            |m: &TrainPartyGameInstance| { &m.train_party_persistent_passenger },
            |m: &mut TrainPartyGameInstance| { &mut m.train_party_persistent_passenger },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NPKLLEHIOAL",
            |m: &TrainPartyGameInstance| { &m.NPKLLEHIOAL },
            |m: &mut TrainPartyGameInstance| { &mut m.NPKLLEHIOAL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyBuildInfo>(
            "build_info",
            |m: &TrainPartyGameInstance| { &m.build_info },
            |m: &mut TrainPartyGameInstance| { &mut m.build_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyGameplayData>(
            "gameplay_data",
            |m: &TrainPartyGameInstance| { &m.gameplay_data },
            |m: &mut TrainPartyGameInstance| { &mut m.gameplay_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "room_unlock",
            |m: &TrainPartyGameInstance| { &m.room_unlock },
            |m: &mut TrainPartyGameInstance| { &mut m.room_unlock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "attempts",
            |m: &TrainPartyGameInstance| { &m.attempts },
            |m: &mut TrainPartyGameInstance| { &mut m.attempts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyGameInstance>(
            "TrainPartyGameInstance",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyGameInstance {
    const NAME: &'static str = "TrainPartyGameInstance";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.train_party_persistent_passenger)?;
                },
                120 => {
                    self.NPKLLEHIOAL = is.read_uint32()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.build_info)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.gameplay_data)?;
                },
                48 => {
                    self.room_unlock = is.read_uint32()?;
                },
                16 => {
                    self.attempts = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.train_party_persistent_passenger.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.NPKLLEHIOAL != 0 {
            my_size += ::protobuf::rt::uint32_size(15, self.NPKLLEHIOAL);
        }
        if let Some(v) = self.build_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gameplay_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.room_unlock != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.room_unlock);
        }
        if self.attempts != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.attempts);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.train_party_persistent_passenger.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if self.NPKLLEHIOAL != 0 {
            os.write_uint32(15, self.NPKLLEHIOAL)?;
        }
        if let Some(v) = self.build_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.gameplay_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if self.room_unlock != 0 {
            os.write_uint32(6, self.room_unlock)?;
        }
        if self.attempts != 0 {
            os.write_uint32(2, self.attempts)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyGameInstance {
        TrainPartyGameInstance::new()
    }

    fn clear(&mut self) {
        self.train_party_persistent_passenger.clear();
        self.NPKLLEHIOAL = 0;
        self.build_info.clear();
        self.gameplay_data.clear();
        self.room_unlock = 0;
        self.attempts = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyGameInstance {
        static instance: TrainPartyGameInstance = TrainPartyGameInstance {
            train_party_persistent_passenger: ::protobuf::MessageField::none(),
            NPKLLEHIOAL: 0,
            build_info: ::protobuf::MessageField::none(),
            gameplay_data: ::protobuf::MessageField::none(),
            room_unlock: 0,
            attempts: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyGameInstance {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyGameInstance").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyGameInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyGameInstance {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyGameplayData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyGameplayData {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyGameplayData.train_party_card)
    pub train_party_card: ::protobuf::MessageField<TrainPartyCard>,
    // @@protoc_insertion_point(field:TrainPartyGameplayData.train_party_passenger)
    pub train_party_passenger: ::protobuf::MessageField<TrainPartyPassenger>,
    // @@protoc_insertion_point(field:TrainPartyGameplayData.KNPFNNGBAIC)
    pub KNPFNNGBAIC: u32,
    // @@protoc_insertion_point(field:TrainPartyGameplayData.train_party_grids)
    pub train_party_grids: ::protobuf::MessageField<TrainPartyGrids>,
    // @@protoc_insertion_point(field:TrainPartyGameplayData.train_party_pending_action)
    pub train_party_pending_action: ::protobuf::MessageField<TrainPartyPendingAction>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyGameplayData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyGameplayData {
    fn default() -> &'a TrainPartyGameplayData {
        <TrainPartyGameplayData as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyGameplayData {
    pub fn new() -> TrainPartyGameplayData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyCard>(
            "train_party_card",
            |m: &TrainPartyGameplayData| { &m.train_party_card },
            |m: &mut TrainPartyGameplayData| { &mut m.train_party_card },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyPassenger>(
            "train_party_passenger",
            |m: &TrainPartyGameplayData| { &m.train_party_passenger },
            |m: &mut TrainPartyGameplayData| { &mut m.train_party_passenger },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "KNPFNNGBAIC",
            |m: &TrainPartyGameplayData| { &m.KNPFNNGBAIC },
            |m: &mut TrainPartyGameplayData| { &mut m.KNPFNNGBAIC },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyGrids>(
            "train_party_grids",
            |m: &TrainPartyGameplayData| { &m.train_party_grids },
            |m: &mut TrainPartyGameplayData| { &mut m.train_party_grids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyPendingAction>(
            "train_party_pending_action",
            |m: &TrainPartyGameplayData| { &m.train_party_pending_action },
            |m: &mut TrainPartyGameplayData| { &mut m.train_party_pending_action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyGameplayData>(
            "TrainPartyGameplayData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyGameplayData {
    const NAME: &'static str = "TrainPartyGameplayData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.train_party_card)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.train_party_passenger)?;
                },
                40 => {
                    self.KNPFNNGBAIC = is.read_uint32()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.train_party_grids)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.train_party_pending_action)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.train_party_card.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.train_party_passenger.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.KNPFNNGBAIC != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.KNPFNNGBAIC);
        }
        if let Some(v) = self.train_party_grids.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.train_party_pending_action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.train_party_card.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.train_party_passenger.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if self.KNPFNNGBAIC != 0 {
            os.write_uint32(5, self.KNPFNNGBAIC)?;
        }
        if let Some(v) = self.train_party_grids.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.train_party_pending_action.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyGameplayData {
        TrainPartyGameplayData::new()
    }

    fn clear(&mut self) {
        self.train_party_card.clear();
        self.train_party_passenger.clear();
        self.KNPFNNGBAIC = 0;
        self.train_party_grids.clear();
        self.train_party_pending_action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyGameplayData {
        static instance: TrainPartyGameplayData = TrainPartyGameplayData {
            train_party_card: ::protobuf::MessageField::none(),
            train_party_passenger: ::protobuf::MessageField::none(),
            KNPFNNGBAIC: 0,
            train_party_grids: ::protobuf::MessageField::none(),
            train_party_pending_action: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyGameplayData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyGameplayData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyGameplayData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyGameplayData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyGetDataCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyGetDataCsReq {
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyGetDataCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyGetDataCsReq {
    fn default() -> &'a TrainPartyGetDataCsReq {
        <TrainPartyGetDataCsReq as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyGetDataCsReq {
    pub fn new() -> TrainPartyGetDataCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyGetDataCsReq>(
            "TrainPartyGetDataCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyGetDataCsReq {
    const NAME: &'static str = "TrainPartyGetDataCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyGetDataCsReq {
        TrainPartyGetDataCsReq::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyGetDataCsReq {
        static instance: TrainPartyGetDataCsReq = TrainPartyGetDataCsReq {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyGetDataCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyGetDataCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyGetDataCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyGetDataCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyGetDataScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyGetDataScRsp {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyGetDataScRsp.train_party_game_instance)
    pub train_party_game_instance: ::protobuf::MessageField<TrainPartyGameInstance>,
    // @@protoc_insertion_point(field:TrainPartyGetDataScRsp.retcode)
    pub retcode: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyGetDataScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyGetDataScRsp {
    fn default() -> &'a TrainPartyGetDataScRsp {
        <TrainPartyGetDataScRsp as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyGetDataScRsp {
    pub fn new() -> TrainPartyGetDataScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyGameInstance>(
            "train_party_game_instance",
            |m: &TrainPartyGetDataScRsp| { &m.train_party_game_instance },
            |m: &mut TrainPartyGetDataScRsp| { &mut m.train_party_game_instance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &TrainPartyGetDataScRsp| { &m.retcode },
            |m: &mut TrainPartyGetDataScRsp| { &mut m.retcode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyGetDataScRsp>(
            "TrainPartyGetDataScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyGetDataScRsp {
    const NAME: &'static str = "TrainPartyGetDataScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.train_party_game_instance)?;
                },
                16 => {
                    self.retcode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.train_party_game_instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.retcode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.train_party_game_instance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if self.retcode != 0 {
            os.write_uint32(2, self.retcode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyGetDataScRsp {
        TrainPartyGetDataScRsp::new()
    }

    fn clear(&mut self) {
        self.train_party_game_instance.clear();
        self.retcode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyGetDataScRsp {
        static instance: TrainPartyGetDataScRsp = TrainPartyGetDataScRsp {
            train_party_game_instance: ::protobuf::MessageField::none(),
            retcode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyGetDataScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyGetDataScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyGetDataScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyGetDataScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyUseCardCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyUseCardCsReq {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyUseCardCsReq.use_card_id)
    pub use_card_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyUseCardCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyUseCardCsReq {
    fn default() -> &'a TrainPartyUseCardCsReq {
        <TrainPartyUseCardCsReq as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyUseCardCsReq {
    pub fn new() -> TrainPartyUseCardCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "use_card_id",
            |m: &TrainPartyUseCardCsReq| { &m.use_card_id },
            |m: &mut TrainPartyUseCardCsReq| { &mut m.use_card_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyUseCardCsReq>(
            "TrainPartyUseCardCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyUseCardCsReq {
    const NAME: &'static str = "TrainPartyUseCardCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                104 => {
                    self.use_card_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.use_card_id != 0 {
            my_size += ::protobuf::rt::uint32_size(13, self.use_card_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.use_card_id != 0 {
            os.write_uint32(13, self.use_card_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyUseCardCsReq {
        TrainPartyUseCardCsReq::new()
    }

    fn clear(&mut self) {
        self.use_card_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyUseCardCsReq {
        static instance: TrainPartyUseCardCsReq = TrainPartyUseCardCsReq {
            use_card_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyUseCardCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyUseCardCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyUseCardCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyUseCardCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyUseCardScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyUseCardScRsp {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyUseCardScRsp.use_card_id)
    pub use_card_id: u32,
    // @@protoc_insertion_point(field:TrainPartyUseCardScRsp.retcode)
    pub retcode: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyUseCardScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyUseCardScRsp {
    fn default() -> &'a TrainPartyUseCardScRsp {
        <TrainPartyUseCardScRsp as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyUseCardScRsp {
    pub fn new() -> TrainPartyUseCardScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "use_card_id",
            |m: &TrainPartyUseCardScRsp| { &m.use_card_id },
            |m: &mut TrainPartyUseCardScRsp| { &mut m.use_card_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &TrainPartyUseCardScRsp| { &m.retcode },
            |m: &mut TrainPartyUseCardScRsp| { &mut m.retcode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyUseCardScRsp>(
            "TrainPartyUseCardScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyUseCardScRsp {
    const NAME: &'static str = "TrainPartyUseCardScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.use_card_id = is.read_uint32()?;
                },
                48 => {
                    self.retcode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.use_card_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.use_card_id);
        }
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.retcode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.use_card_id != 0 {
            os.write_uint32(1, self.use_card_id)?;
        }
        if self.retcode != 0 {
            os.write_uint32(6, self.retcode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyUseCardScRsp {
        TrainPartyUseCardScRsp::new()
    }

    fn clear(&mut self) {
        self.use_card_id = 0;
        self.retcode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyUseCardScRsp {
        static instance: TrainPartyUseCardScRsp = TrainPartyUseCardScRsp {
            use_card_id: 0,
            retcode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyUseCardScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyUseCardScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyUseCardScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyUseCardScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyMoveScNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyMoveScNotify {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyMoveScNotify.ONDGNPKGJCB)
    pub ONDGNPKGJCB: u32,
    // @@protoc_insertion_point(field:TrainPartyMoveScNotify.grid_data_list)
    pub grid_data_list: ::std::vec::Vec<TrainPartyGridData>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyMoveScNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyMoveScNotify {
    fn default() -> &'a TrainPartyMoveScNotify {
        <TrainPartyMoveScNotify as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyMoveScNotify {
    pub fn new() -> TrainPartyMoveScNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ONDGNPKGJCB",
            |m: &TrainPartyMoveScNotify| { &m.ONDGNPKGJCB },
            |m: &mut TrainPartyMoveScNotify| { &mut m.ONDGNPKGJCB },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "grid_data_list",
            |m: &TrainPartyMoveScNotify| { &m.grid_data_list },
            |m: &mut TrainPartyMoveScNotify| { &mut m.grid_data_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyMoveScNotify>(
            "TrainPartyMoveScNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyMoveScNotify {
    const NAME: &'static str = "TrainPartyMoveScNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.ONDGNPKGJCB = is.read_uint32()?;
                },
                66 => {
                    self.grid_data_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ONDGNPKGJCB != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.ONDGNPKGJCB);
        }
        for value in &self.grid_data_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ONDGNPKGJCB != 0 {
            os.write_uint32(4, self.ONDGNPKGJCB)?;
        }
        for v in &self.grid_data_list {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyMoveScNotify {
        TrainPartyMoveScNotify::new()
    }

    fn clear(&mut self) {
        self.ONDGNPKGJCB = 0;
        self.grid_data_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyMoveScNotify {
        static instance: TrainPartyMoveScNotify = TrainPartyMoveScNotify {
            ONDGNPKGJCB: 0,
            grid_data_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyMoveScNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyMoveScNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyMoveScNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyMoveScNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartySettleNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartySettleNotify {
    // message fields
    // @@protoc_insertion_point(field:TrainPartySettleNotify.train_party_settle_data)
    pub train_party_settle_data: ::protobuf::MessageField<TrainPartySettleData>,
    // @@protoc_insertion_point(field:TrainPartySettleNotify.use_card_id)
    pub use_card_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartySettleNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartySettleNotify {
    fn default() -> &'a TrainPartySettleNotify {
        <TrainPartySettleNotify as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartySettleNotify {
    pub fn new() -> TrainPartySettleNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartySettleData>(
            "train_party_settle_data",
            |m: &TrainPartySettleNotify| { &m.train_party_settle_data },
            |m: &mut TrainPartySettleNotify| { &mut m.train_party_settle_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "use_card_id",
            |m: &TrainPartySettleNotify| { &m.use_card_id },
            |m: &mut TrainPartySettleNotify| { &mut m.use_card_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartySettleNotify>(
            "TrainPartySettleNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartySettleNotify {
    const NAME: &'static str = "TrainPartySettleNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.train_party_settle_data)?;
                },
                88 => {
                    self.use_card_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.train_party_settle_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.use_card_id != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.use_card_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.train_party_settle_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.use_card_id != 0 {
            os.write_uint32(11, self.use_card_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartySettleNotify {
        TrainPartySettleNotify::new()
    }

    fn clear(&mut self) {
        self.train_party_settle_data.clear();
        self.use_card_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartySettleNotify {
        static instance: TrainPartySettleNotify = TrainPartySettleNotify {
            train_party_settle_data: ::protobuf::MessageField::none(),
            use_card_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartySettleNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartySettleNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartySettleNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartySettleNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartySettleData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartySettleData {
    // message fields
    // @@protoc_insertion_point(field:TrainPartySettleData.settle_record_list)
    pub settle_record_list: ::std::vec::Vec<TrainPartySettleRecord>,
    // @@protoc_insertion_point(field:TrainPartySettleData.KIPKPPEDOJP)
    pub KIPKPPEDOJP: u32,
    // @@protoc_insertion_point(field:TrainPartySettleData.passenger_data_list)
    pub passenger_data_list: ::std::vec::Vec<TrainPartyPassengerData>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartySettleData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartySettleData {
    fn default() -> &'a TrainPartySettleData {
        <TrainPartySettleData as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartySettleData {
    pub fn new() -> TrainPartySettleData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "settle_record_list",
            |m: &TrainPartySettleData| { &m.settle_record_list },
            |m: &mut TrainPartySettleData| { &mut m.settle_record_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "KIPKPPEDOJP",
            |m: &TrainPartySettleData| { &m.KIPKPPEDOJP },
            |m: &mut TrainPartySettleData| { &mut m.KIPKPPEDOJP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "passenger_data_list",
            |m: &TrainPartySettleData| { &m.passenger_data_list },
            |m: &mut TrainPartySettleData| { &mut m.passenger_data_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartySettleData>(
            "TrainPartySettleData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartySettleData {
    const NAME: &'static str = "TrainPartySettleData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    self.settle_record_list.push(is.read_message()?);
                },
                120 => {
                    self.KIPKPPEDOJP = is.read_uint32()?;
                },
                66 => {
                    self.passenger_data_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.settle_record_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.KIPKPPEDOJP != 0 {
            my_size += ::protobuf::rt::uint32_size(15, self.KIPKPPEDOJP);
        }
        for value in &self.passenger_data_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.settle_record_list {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        if self.KIPKPPEDOJP != 0 {
            os.write_uint32(15, self.KIPKPPEDOJP)?;
        }
        for v in &self.passenger_data_list {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartySettleData {
        TrainPartySettleData::new()
    }

    fn clear(&mut self) {
        self.settle_record_list.clear();
        self.KIPKPPEDOJP = 0;
        self.passenger_data_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartySettleData {
        static instance: TrainPartySettleData = TrainPartySettleData {
            settle_record_list: ::std::vec::Vec::new(),
            KIPKPPEDOJP: 0,
            passenger_data_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartySettleData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartySettleData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartySettleData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartySettleData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartySettleRecord)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartySettleRecord {
    // message fields
    // @@protoc_insertion_point(field:TrainPartySettleRecord.AOMFDNHANFA)
    pub AOMFDNHANFA: u32,
    // @@protoc_insertion_point(field:TrainPartySettleRecord.param_list)
    pub param_list: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartySettleRecord.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartySettleRecord {
    fn default() -> &'a TrainPartySettleRecord {
        <TrainPartySettleRecord as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartySettleRecord {
    pub fn new() -> TrainPartySettleRecord {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "AOMFDNHANFA",
            |m: &TrainPartySettleRecord| { &m.AOMFDNHANFA },
            |m: &mut TrainPartySettleRecord| { &mut m.AOMFDNHANFA },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "param_list",
            |m: &TrainPartySettleRecord| { &m.param_list },
            |m: &mut TrainPartySettleRecord| { &mut m.param_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartySettleRecord>(
            "TrainPartySettleRecord",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartySettleRecord {
    const NAME: &'static str = "TrainPartySettleRecord";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.AOMFDNHANFA = is.read_uint32()?;
                },
                114 => {
                    is.read_repeated_packed_uint32_into(&mut self.param_list)?;
                },
                112 => {
                    self.param_list.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.AOMFDNHANFA != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.AOMFDNHANFA);
        }
        for value in &self.param_list {
            my_size += ::protobuf::rt::uint32_size(14, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.AOMFDNHANFA != 0 {
            os.write_uint32(4, self.AOMFDNHANFA)?;
        }
        for v in &self.param_list {
            os.write_uint32(14, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartySettleRecord {
        TrainPartySettleRecord::new()
    }

    fn clear(&mut self) {
        self.AOMFDNHANFA = 0;
        self.param_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartySettleRecord {
        static instance: TrainPartySettleRecord = TrainPartySettleRecord {
            AOMFDNHANFA: 0,
            param_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartySettleRecord {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartySettleRecord").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartySettleRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartySettleRecord {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:JDGAOCPJEPL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct JDGAOCPJEPL {
    // message fields
    // @@protoc_insertion_point(field:JDGAOCPJEPL.train_party_card_data)
    pub train_party_card_data: ::protobuf::MessageField<TrainPartyCardData>,
    // special fields
    // @@protoc_insertion_point(special_field:JDGAOCPJEPL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a JDGAOCPJEPL {
    fn default() -> &'a JDGAOCPJEPL {
        <JDGAOCPJEPL as ::protobuf::Message>::default_instance()
    }
}

impl JDGAOCPJEPL {
    pub fn new() -> JDGAOCPJEPL {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyCardData>(
            "train_party_card_data",
            |m: &JDGAOCPJEPL| { &m.train_party_card_data },
            |m: &mut JDGAOCPJEPL| { &mut m.train_party_card_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JDGAOCPJEPL>(
            "JDGAOCPJEPL",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for JDGAOCPJEPL {
    const NAME: &'static str = "JDGAOCPJEPL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.train_party_card_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.train_party_card_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.train_party_card_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> JDGAOCPJEPL {
        JDGAOCPJEPL::new()
    }

    fn clear(&mut self) {
        self.train_party_card_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static JDGAOCPJEPL {
        static instance: JDGAOCPJEPL = JDGAOCPJEPL {
            train_party_card_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for JDGAOCPJEPL {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("JDGAOCPJEPL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for JDGAOCPJEPL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JDGAOCPJEPL {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CBNHKHEFEFF)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBNHKHEFEFF {
    // message fields
    // @@protoc_insertion_point(field:CBNHKHEFEFF.passenger_id)
    pub passenger_id: u32,
    // @@protoc_insertion_point(field:CBNHKHEFEFF.status_info)
    pub status_info: ::protobuf::MessageField<TrainPartyPassengerStatusInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CBNHKHEFEFF.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBNHKHEFEFF {
    fn default() -> &'a CBNHKHEFEFF {
        <CBNHKHEFEFF as ::protobuf::Message>::default_instance()
    }
}

impl CBNHKHEFEFF {
    pub fn new() -> CBNHKHEFEFF {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "passenger_id",
            |m: &CBNHKHEFEFF| { &m.passenger_id },
            |m: &mut CBNHKHEFEFF| { &mut m.passenger_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyPassengerStatusInfo>(
            "status_info",
            |m: &CBNHKHEFEFF| { &m.status_info },
            |m: &mut CBNHKHEFEFF| { &mut m.status_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CBNHKHEFEFF>(
            "CBNHKHEFEFF",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CBNHKHEFEFF {
    const NAME: &'static str = "CBNHKHEFEFF";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.passenger_id = is.read_uint32()?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.passenger_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.passenger_id);
        }
        if let Some(v) = self.status_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.passenger_id != 0 {
            os.write_uint32(1, self.passenger_id)?;
        }
        if let Some(v) = self.status_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBNHKHEFEFF {
        CBNHKHEFEFF::new()
    }

    fn clear(&mut self) {
        self.passenger_id = 0;
        self.status_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBNHKHEFEFF {
        static instance: CBNHKHEFEFF = CBNHKHEFEFF {
            passenger_id: 0,
            status_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CBNHKHEFEFF {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CBNHKHEFEFF").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CBNHKHEFEFF {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBNHKHEFEFF {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BFFIEMJEDIL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BFFIEMJEDIL {
    // message fields
    // @@protoc_insertion_point(field:BFFIEMJEDIL.KEHPCCGPFAD)
    pub KEHPCCGPFAD: ::std::vec::Vec<super::CBNHKHEFEFF::CBNHKHEFEFF>,
    // special fields
    // @@protoc_insertion_point(special_field:BFFIEMJEDIL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BFFIEMJEDIL {
    fn default() -> &'a BFFIEMJEDIL {
        <BFFIEMJEDIL as ::protobuf::Message>::default_instance()
    }
}

impl BFFIEMJEDIL {
    pub fn new() -> BFFIEMJEDIL {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "KEHPCCGPFAD",
            |m: &BFFIEMJEDIL| { &m.KEHPCCGPFAD },
            |m: &mut BFFIEMJEDIL| { &mut m.KEHPCCGPFAD },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BFFIEMJEDIL>(
            "BFFIEMJEDIL",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BFFIEMJEDIL {
    const NAME: &'static str = "BFFIEMJEDIL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                42 => {
                    self.KEHPCCGPFAD.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.KEHPCCGPFAD {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.KEHPCCGPFAD {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BFFIEMJEDIL {
        BFFIEMJEDIL::new()
    }

    fn clear(&mut self) {
        self.KEHPCCGPFAD.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BFFIEMJEDIL {
        static instance: BFFIEMJEDIL = BFFIEMJEDIL {
            KEHPCCGPFAD: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BFFIEMJEDIL {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BFFIEMJEDIL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BFFIEMJEDIL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BFFIEMJEDIL {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MINMHDAEEHH)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MINMHDAEEHH {
    // message fields
    // @@protoc_insertion_point(field:MINMHDAEEHH.pending_action)
    pub pending_action: ::protobuf::MessageField<TrainPartyPendingAction>,
    // special fields
    // @@protoc_insertion_point(special_field:MINMHDAEEHH.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MINMHDAEEHH {
    fn default() -> &'a MINMHDAEEHH {
        <MINMHDAEEHH as ::protobuf::Message>::default_instance()
    }
}

impl MINMHDAEEHH {
    pub fn new() -> MINMHDAEEHH {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyPendingAction>(
            "pending_action",
            |m: &MINMHDAEEHH| { &m.pending_action },
            |m: &mut MINMHDAEEHH| { &mut m.pending_action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MINMHDAEEHH>(
            "MINMHDAEEHH",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MINMHDAEEHH {
    const NAME: &'static str = "MINMHDAEEHH";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pending_action)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pending_action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pending_action.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MINMHDAEEHH {
        MINMHDAEEHH::new()
    }

    fn clear(&mut self) {
        self.pending_action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MINMHDAEEHH {
        static instance: MINMHDAEEHH = MINMHDAEEHH {
            pending_action: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MINMHDAEEHH {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MINMHDAEEHH").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MINMHDAEEHH {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MINMHDAEEHH {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LFHKDENCECI)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LFHKDENCECI {
    // message fields
    // @@protoc_insertion_point(field:LFHKDENCECI.upgrade_level)
    pub upgrade_level: u32,
    // special fields
    // @@protoc_insertion_point(special_field:LFHKDENCECI.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LFHKDENCECI {
    fn default() -> &'a LFHKDENCECI {
        <LFHKDENCECI as ::protobuf::Message>::default_instance()
    }
}

impl LFHKDENCECI {
    pub fn new() -> LFHKDENCECI {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upgrade_level",
            |m: &LFHKDENCECI| { &m.upgrade_level },
            |m: &mut LFHKDENCECI| { &mut m.upgrade_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LFHKDENCECI>(
            "LFHKDENCECI",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LFHKDENCECI {
    const NAME: &'static str = "LFHKDENCECI";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                56 => {
                    self.upgrade_level = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.upgrade_level != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.upgrade_level);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.upgrade_level != 0 {
            os.write_uint32(7, self.upgrade_level)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LFHKDENCECI {
        LFHKDENCECI::new()
    }

    fn clear(&mut self) {
        self.upgrade_level = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LFHKDENCECI {
        static instance: LFHKDENCECI = LFHKDENCECI {
            upgrade_level: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LFHKDENCECI {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LFHKDENCECI").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LFHKDENCECI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LFHKDENCECI {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LOCAOOGDAMB)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LOCAOOGDAMB {
    // message fields
    // @@protoc_insertion_point(field:LOCAOOGDAMB.MLMDEBKIGBH)
    pub MLMDEBKIGBH: ::protobuf::MessageField<TrainPartyPassengerSkillInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:LOCAOOGDAMB.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LOCAOOGDAMB {
    fn default() -> &'a LOCAOOGDAMB {
        <LOCAOOGDAMB as ::protobuf::Message>::default_instance()
    }
}

impl LOCAOOGDAMB {
    pub fn new() -> LOCAOOGDAMB {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyPassengerSkillInfo>(
            "MLMDEBKIGBH",
            |m: &LOCAOOGDAMB| { &m.MLMDEBKIGBH },
            |m: &mut LOCAOOGDAMB| { &mut m.MLMDEBKIGBH },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LOCAOOGDAMB>(
            "LOCAOOGDAMB",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LOCAOOGDAMB {
    const NAME: &'static str = "LOCAOOGDAMB";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.MLMDEBKIGBH)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.MLMDEBKIGBH.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.MLMDEBKIGBH.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LOCAOOGDAMB {
        LOCAOOGDAMB::new()
    }

    fn clear(&mut self) {
        self.MLMDEBKIGBH.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LOCAOOGDAMB {
        static instance: LOCAOOGDAMB = LOCAOOGDAMB {
            MLMDEBKIGBH: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LOCAOOGDAMB {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LOCAOOGDAMB").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LOCAOOGDAMB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LOCAOOGDAMB {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:JCDCKOAPGEE)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct JCDCKOAPGEE {
    // message fields
    // @@protoc_insertion_point(field:JCDCKOAPGEE.skill_info_list)
    pub skill_info_list: ::std::vec::Vec<TrainPartyPassengerSkillInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:JCDCKOAPGEE.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a JCDCKOAPGEE {
    fn default() -> &'a JCDCKOAPGEE {
        <JCDCKOAPGEE as ::protobuf::Message>::default_instance()
    }
}

impl JCDCKOAPGEE {
    pub fn new() -> JCDCKOAPGEE {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "skill_info_list",
            |m: &JCDCKOAPGEE| { &m.skill_info_list },
            |m: &mut JCDCKOAPGEE| { &mut m.skill_info_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JCDCKOAPGEE>(
            "JCDCKOAPGEE",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for JCDCKOAPGEE {
    const NAME: &'static str = "JCDCKOAPGEE";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                74 => {
                    self.skill_info_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.skill_info_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.skill_info_list {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> JCDCKOAPGEE {
        JCDCKOAPGEE::new()
    }

    fn clear(&mut self) {
        self.skill_info_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static JCDCKOAPGEE {
        static instance: JCDCKOAPGEE = JCDCKOAPGEE {
            skill_info_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for JCDCKOAPGEE {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("JCDCKOAPGEE").unwrap()).clone()
    }
}

impl ::std::fmt::Display for JCDCKOAPGEE {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JCDCKOAPGEE {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:KNINCLCJODM)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KNINCLCJODM {
    // message fields
    // @@protoc_insertion_point(field:KNINCLCJODM.AAHAIIFCFNN)
    pub AAHAIIFCFNN: ::protobuf::MessageField<TrainPartyPassengerPersistentData>,
    // special fields
    // @@protoc_insertion_point(special_field:KNINCLCJODM.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KNINCLCJODM {
    fn default() -> &'a KNINCLCJODM {
        <KNINCLCJODM as ::protobuf::Message>::default_instance()
    }
}

impl KNINCLCJODM {
    pub fn new() -> KNINCLCJODM {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyPassengerPersistentData>(
            "AAHAIIFCFNN",
            |m: &KNINCLCJODM| { &m.AAHAIIFCFNN },
            |m: &mut KNINCLCJODM| { &mut m.AAHAIIFCFNN },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KNINCLCJODM>(
            "KNINCLCJODM",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KNINCLCJODM {
    const NAME: &'static str = "KNINCLCJODM";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.AAHAIIFCFNN)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.AAHAIIFCFNN.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.AAHAIIFCFNN.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KNINCLCJODM {
        KNINCLCJODM::new()
    }

    fn clear(&mut self) {
        self.AAHAIIFCFNN.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KNINCLCJODM {
        static instance: KNINCLCJODM = KNINCLCJODM {
            AAHAIIFCFNN: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KNINCLCJODM {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KNINCLCJODM").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KNINCLCJODM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KNINCLCJODM {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EKLMKFCKLAA)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EKLMKFCKLAA {
    // message fields
    // @@protoc_insertion_point(field:EKLMKFCKLAA.ANPNJEKLCJJ)
    pub ANPNJEKLCJJ: ::std::vec::Vec<TrainPartyGridData>,
    // special fields
    // @@protoc_insertion_point(special_field:EKLMKFCKLAA.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EKLMKFCKLAA {
    fn default() -> &'a EKLMKFCKLAA {
        <EKLMKFCKLAA as ::protobuf::Message>::default_instance()
    }
}

impl EKLMKFCKLAA {
    pub fn new() -> EKLMKFCKLAA {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ANPNJEKLCJJ",
            |m: &EKLMKFCKLAA| { &m.ANPNJEKLCJJ },
            |m: &mut EKLMKFCKLAA| { &mut m.ANPNJEKLCJJ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EKLMKFCKLAA>(
            "EKLMKFCKLAA",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EKLMKFCKLAA {
    const NAME: &'static str = "EKLMKFCKLAA";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                98 => {
                    self.ANPNJEKLCJJ.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ANPNJEKLCJJ {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ANPNJEKLCJJ {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EKLMKFCKLAA {
        EKLMKFCKLAA::new()
    }

    fn clear(&mut self) {
        self.ANPNJEKLCJJ.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EKLMKFCKLAA {
        static instance: EKLMKFCKLAA = EKLMKFCKLAA {
            ANPNJEKLCJJ: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EKLMKFCKLAA {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EKLMKFCKLAA").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EKLMKFCKLAA {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EKLMKFCKLAA {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NHNNJJPBOMJ)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NHNNJJPBOMJ {
    // message fields
    // @@protoc_insertion_point(field:NHNNJJPBOMJ.has_modify_all_passenger_stat_effect)
    pub has_modify_all_passenger_stat_effect: bool,
    // @@protoc_insertion_point(field:NHNNJJPBOMJ.FOAFPCNJNAM)
    pub FOAFPCNJNAM: ::protobuf::MessageField<TrainPartyCards>,
    // @@protoc_insertion_point(field:NHNNJJPBOMJ.extra_ratio)
    pub extra_ratio: u32,
    // @@protoc_insertion_point(field:NHNNJJPBOMJ.meeting_count_info)
    pub meeting_count_info: ::protobuf::MessageField<TrainPartyMeetingCountInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:NHNNJJPBOMJ.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NHNNJJPBOMJ {
    fn default() -> &'a NHNNJJPBOMJ {
        <NHNNJJPBOMJ as ::protobuf::Message>::default_instance()
    }
}

impl NHNNJJPBOMJ {
    pub fn new() -> NHNNJJPBOMJ {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_modify_all_passenger_stat_effect",
            |m: &NHNNJJPBOMJ| { &m.has_modify_all_passenger_stat_effect },
            |m: &mut NHNNJJPBOMJ| { &mut m.has_modify_all_passenger_stat_effect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyCards>(
            "FOAFPCNJNAM",
            |m: &NHNNJJPBOMJ| { &m.FOAFPCNJNAM },
            |m: &mut NHNNJJPBOMJ| { &mut m.FOAFPCNJNAM },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "extra_ratio",
            |m: &NHNNJJPBOMJ| { &m.extra_ratio },
            |m: &mut NHNNJJPBOMJ| { &mut m.extra_ratio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyMeetingCountInfo>(
            "meeting_count_info",
            |m: &NHNNJJPBOMJ| { &m.meeting_count_info },
            |m: &mut NHNNJJPBOMJ| { &mut m.meeting_count_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NHNNJJPBOMJ>(
            "NHNNJJPBOMJ",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NHNNJJPBOMJ {
    const NAME: &'static str = "NHNNJJPBOMJ";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.has_modify_all_passenger_stat_effect = is.read_bool()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.FOAFPCNJNAM)?;
                },
                120 => {
                    self.extra_ratio = is.read_uint32()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.meeting_count_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.has_modify_all_passenger_stat_effect != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.FOAFPCNJNAM.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.extra_ratio != 0 {
            my_size += ::protobuf::rt::uint32_size(15, self.extra_ratio);
        }
        if let Some(v) = self.meeting_count_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.has_modify_all_passenger_stat_effect != false {
            os.write_bool(1, self.has_modify_all_passenger_stat_effect)?;
        }
        if let Some(v) = self.FOAFPCNJNAM.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.extra_ratio != 0 {
            os.write_uint32(15, self.extra_ratio)?;
        }
        if let Some(v) = self.meeting_count_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NHNNJJPBOMJ {
        NHNNJJPBOMJ::new()
    }

    fn clear(&mut self) {
        self.has_modify_all_passenger_stat_effect = false;
        self.FOAFPCNJNAM.clear();
        self.extra_ratio = 0;
        self.meeting_count_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NHNNJJPBOMJ {
        static instance: NHNNJJPBOMJ = NHNNJJPBOMJ {
            has_modify_all_passenger_stat_effect: false,
            FOAFPCNJNAM: ::protobuf::MessageField::none(),
            extra_ratio: 0,
            meeting_count_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NHNNJJPBOMJ {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NHNNJJPBOMJ").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NHNNJJPBOMJ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NHNNJJPBOMJ {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyUpdateInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyUpdateInfo {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyUpdateInfo.src)
    pub src: ::protobuf::EnumOrUnknown<TrainPartyUpdateSrc>,
    // message oneof groups
    pub OMNKNOLIHNB: ::std::option::Option<train_party_update_info::OMNKNOLIHNB>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyUpdateInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyUpdateInfo {
    fn default() -> &'a TrainPartyUpdateInfo {
        <TrainPartyUpdateInfo as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyUpdateInfo {
    pub fn new() -> TrainPartyUpdateInfo {
        ::std::default::Default::default()
    }

    // .TrainPartyCards FOAFPCNJNAM = 1945;

    pub fn FOAFPCNJNAM(&self) -> &TrainPartyCards {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::FOAFPCNJNAM(ref v)) => v,
            _ => <TrainPartyCards as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_FOAFPCNJNAM(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_FOAFPCNJNAM(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::FOAFPCNJNAM(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_FOAFPCNJNAM(&mut self, v: TrainPartyCards) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::FOAFPCNJNAM(v))
    }

    // Mutable pointer to the field.
    pub fn mut_FOAFPCNJNAM(&mut self) -> &mut TrainPartyCards {
        if let ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::FOAFPCNJNAM(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::FOAFPCNJNAM(TrainPartyCards::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::FOAFPCNJNAM(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_FOAFPCNJNAM(&mut self) -> TrainPartyCards {
        if self.has_FOAFPCNJNAM() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::FOAFPCNJNAM(v)) => v,
                _ => panic!(),
            }
        } else {
            TrainPartyCards::new()
        }
    }

    // .BFFIEMJEDIL IHKAOGHIMDN = 1705;

    pub fn IHKAOGHIMDN(&self) -> &super::BFFIEMJEDIL::BFFIEMJEDIL {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::IHKAOGHIMDN(ref v)) => v,
            _ => <super::BFFIEMJEDIL::BFFIEMJEDIL as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_IHKAOGHIMDN(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_IHKAOGHIMDN(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::IHKAOGHIMDN(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_IHKAOGHIMDN(&mut self, v: super::BFFIEMJEDIL::BFFIEMJEDIL) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::IHKAOGHIMDN(v))
    }

    // Mutable pointer to the field.
    pub fn mut_IHKAOGHIMDN(&mut self) -> &mut super::BFFIEMJEDIL::BFFIEMJEDIL {
        if let ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::IHKAOGHIMDN(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::IHKAOGHIMDN(super::BFFIEMJEDIL::BFFIEMJEDIL::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::IHKAOGHIMDN(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_IHKAOGHIMDN(&mut self) -> super::BFFIEMJEDIL::BFFIEMJEDIL {
        if self.has_IHKAOGHIMDN() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::IHKAOGHIMDN(v)) => v,
                _ => panic!(),
            }
        } else {
            super::BFFIEMJEDIL::BFFIEMJEDIL::new()
        }
    }

    // .MINMHDAEEHH GJKIGLGOOAF = 1085;

    pub fn GJKIGLGOOAF(&self) -> &super::MINMHDAEEHH::MINMHDAEEHH {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::GJKIGLGOOAF(ref v)) => v,
            _ => <super::MINMHDAEEHH::MINMHDAEEHH as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_GJKIGLGOOAF(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_GJKIGLGOOAF(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::GJKIGLGOOAF(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_GJKIGLGOOAF(&mut self, v: super::MINMHDAEEHH::MINMHDAEEHH) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::GJKIGLGOOAF(v))
    }

    // Mutable pointer to the field.
    pub fn mut_GJKIGLGOOAF(&mut self) -> &mut super::MINMHDAEEHH::MINMHDAEEHH {
        if let ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::GJKIGLGOOAF(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::GJKIGLGOOAF(super::MINMHDAEEHH::MINMHDAEEHH::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::GJKIGLGOOAF(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_GJKIGLGOOAF(&mut self) -> super::MINMHDAEEHH::MINMHDAEEHH {
        if self.has_GJKIGLGOOAF() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::GJKIGLGOOAF(v)) => v,
                _ => panic!(),
            }
        } else {
            super::MINMHDAEEHH::MINMHDAEEHH::new()
        }
    }

    // .LFHKDENCECI EEAFEPKNKMI = 661;

    pub fn EEAFEPKNKMI(&self) -> &super::LFHKDENCECI::LFHKDENCECI {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::EEAFEPKNKMI(ref v)) => v,
            _ => <super::LFHKDENCECI::LFHKDENCECI as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_EEAFEPKNKMI(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_EEAFEPKNKMI(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::EEAFEPKNKMI(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_EEAFEPKNKMI(&mut self, v: super::LFHKDENCECI::LFHKDENCECI) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::EEAFEPKNKMI(v))
    }

    // Mutable pointer to the field.
    pub fn mut_EEAFEPKNKMI(&mut self) -> &mut super::LFHKDENCECI::LFHKDENCECI {
        if let ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::EEAFEPKNKMI(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::EEAFEPKNKMI(super::LFHKDENCECI::LFHKDENCECI::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::EEAFEPKNKMI(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_EEAFEPKNKMI(&mut self) -> super::LFHKDENCECI::LFHKDENCECI {
        if self.has_EEAFEPKNKMI() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::EEAFEPKNKMI(v)) => v,
                _ => panic!(),
            }
        } else {
            super::LFHKDENCECI::LFHKDENCECI::new()
        }
    }

    // .EKLMKFCKLAA LKCLGKLDNHE = 1547;

    pub fn LKCLGKLDNHE(&self) -> &super::EKLMKFCKLAA::EKLMKFCKLAA {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::LKCLGKLDNHE(ref v)) => v,
            _ => <super::EKLMKFCKLAA::EKLMKFCKLAA as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_LKCLGKLDNHE(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_LKCLGKLDNHE(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::LKCLGKLDNHE(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_LKCLGKLDNHE(&mut self, v: super::EKLMKFCKLAA::EKLMKFCKLAA) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::LKCLGKLDNHE(v))
    }

    // Mutable pointer to the field.
    pub fn mut_LKCLGKLDNHE(&mut self) -> &mut super::EKLMKFCKLAA::EKLMKFCKLAA {
        if let ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::LKCLGKLDNHE(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::LKCLGKLDNHE(super::EKLMKFCKLAA::EKLMKFCKLAA::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::LKCLGKLDNHE(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_LKCLGKLDNHE(&mut self) -> super::EKLMKFCKLAA::EKLMKFCKLAA {
        if self.has_LKCLGKLDNHE() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::LKCLGKLDNHE(v)) => v,
                _ => panic!(),
            }
        } else {
            super::EKLMKFCKLAA::EKLMKFCKLAA::new()
        }
    }

    // .LOCAOOGDAMB IDMPFCHCPHO = 840;

    pub fn IDMPFCHCPHO(&self) -> &super::LOCAOOGDAMB::LOCAOOGDAMB {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::IDMPFCHCPHO(ref v)) => v,
            _ => <super::LOCAOOGDAMB::LOCAOOGDAMB as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_IDMPFCHCPHO(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_IDMPFCHCPHO(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::IDMPFCHCPHO(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_IDMPFCHCPHO(&mut self, v: super::LOCAOOGDAMB::LOCAOOGDAMB) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::IDMPFCHCPHO(v))
    }

    // Mutable pointer to the field.
    pub fn mut_IDMPFCHCPHO(&mut self) -> &mut super::LOCAOOGDAMB::LOCAOOGDAMB {
        if let ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::IDMPFCHCPHO(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::IDMPFCHCPHO(super::LOCAOOGDAMB::LOCAOOGDAMB::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::IDMPFCHCPHO(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_IDMPFCHCPHO(&mut self) -> super::LOCAOOGDAMB::LOCAOOGDAMB {
        if self.has_IDMPFCHCPHO() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::IDMPFCHCPHO(v)) => v,
                _ => panic!(),
            }
        } else {
            super::LOCAOOGDAMB::LOCAOOGDAMB::new()
        }
    }

    // .NHNNJJPBOMJ CKECMALEPAA = 1390;

    pub fn CKECMALEPAA(&self) -> &super::NHNNJJPBOMJ::NHNNJJPBOMJ {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::CKECMALEPAA(ref v)) => v,
            _ => <super::NHNNJJPBOMJ::NHNNJJPBOMJ as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_CKECMALEPAA(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_CKECMALEPAA(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::CKECMALEPAA(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_CKECMALEPAA(&mut self, v: super::NHNNJJPBOMJ::NHNNJJPBOMJ) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::CKECMALEPAA(v))
    }

    // Mutable pointer to the field.
    pub fn mut_CKECMALEPAA(&mut self) -> &mut super::NHNNJJPBOMJ::NHNNJJPBOMJ {
        if let ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::CKECMALEPAA(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::CKECMALEPAA(super::NHNNJJPBOMJ::NHNNJJPBOMJ::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::CKECMALEPAA(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_CKECMALEPAA(&mut self) -> super::NHNNJJPBOMJ::NHNNJJPBOMJ {
        if self.has_CKECMALEPAA() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::CKECMALEPAA(v)) => v,
                _ => panic!(),
            }
        } else {
            super::NHNNJJPBOMJ::NHNNJJPBOMJ::new()
        }
    }

    // .JCDCKOAPGEE NCLOBABIAHI = 79;

    pub fn NCLOBABIAHI(&self) -> &super::JCDCKOAPGEE::JCDCKOAPGEE {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::NCLOBABIAHI(ref v)) => v,
            _ => <super::JCDCKOAPGEE::JCDCKOAPGEE as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_NCLOBABIAHI(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_NCLOBABIAHI(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::NCLOBABIAHI(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_NCLOBABIAHI(&mut self, v: super::JCDCKOAPGEE::JCDCKOAPGEE) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::NCLOBABIAHI(v))
    }

    // Mutable pointer to the field.
    pub fn mut_NCLOBABIAHI(&mut self) -> &mut super::JCDCKOAPGEE::JCDCKOAPGEE {
        if let ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::NCLOBABIAHI(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::NCLOBABIAHI(super::JCDCKOAPGEE::JCDCKOAPGEE::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::NCLOBABIAHI(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_NCLOBABIAHI(&mut self) -> super::JCDCKOAPGEE::JCDCKOAPGEE {
        if self.has_NCLOBABIAHI() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::NCLOBABIAHI(v)) => v,
                _ => panic!(),
            }
        } else {
            super::JCDCKOAPGEE::JCDCKOAPGEE::new()
        }
    }

    // .KNINCLCJODM APGDKAPIMGF = 780;

    pub fn APGDKAPIMGF(&self) -> &super::KNINCLCJODM::KNINCLCJODM {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::APGDKAPIMGF(ref v)) => v,
            _ => <super::KNINCLCJODM::KNINCLCJODM as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_APGDKAPIMGF(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_APGDKAPIMGF(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::APGDKAPIMGF(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_APGDKAPIMGF(&mut self, v: super::KNINCLCJODM::KNINCLCJODM) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::APGDKAPIMGF(v))
    }

    // Mutable pointer to the field.
    pub fn mut_APGDKAPIMGF(&mut self) -> &mut super::KNINCLCJODM::KNINCLCJODM {
        if let ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::APGDKAPIMGF(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::APGDKAPIMGF(super::KNINCLCJODM::KNINCLCJODM::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::APGDKAPIMGF(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_APGDKAPIMGF(&mut self) -> super::KNINCLCJODM::KNINCLCJODM {
        if self.has_APGDKAPIMGF() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::APGDKAPIMGF(v)) => v,
                _ => panic!(),
            }
        } else {
            super::KNINCLCJODM::KNINCLCJODM::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TrainPartyCards>(
            "FOAFPCNJNAM",
            TrainPartyUpdateInfo::has_FOAFPCNJNAM,
            TrainPartyUpdateInfo::FOAFPCNJNAM,
            TrainPartyUpdateInfo::mut_FOAFPCNJNAM,
            TrainPartyUpdateInfo::set_FOAFPCNJNAM,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::BFFIEMJEDIL::BFFIEMJEDIL>(
            "IHKAOGHIMDN",
            TrainPartyUpdateInfo::has_IHKAOGHIMDN,
            TrainPartyUpdateInfo::IHKAOGHIMDN,
            TrainPartyUpdateInfo::mut_IHKAOGHIMDN,
            TrainPartyUpdateInfo::set_IHKAOGHIMDN,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::MINMHDAEEHH::MINMHDAEEHH>(
            "GJKIGLGOOAF",
            TrainPartyUpdateInfo::has_GJKIGLGOOAF,
            TrainPartyUpdateInfo::GJKIGLGOOAF,
            TrainPartyUpdateInfo::mut_GJKIGLGOOAF,
            TrainPartyUpdateInfo::set_GJKIGLGOOAF,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::LFHKDENCECI::LFHKDENCECI>(
            "EEAFEPKNKMI",
            TrainPartyUpdateInfo::has_EEAFEPKNKMI,
            TrainPartyUpdateInfo::EEAFEPKNKMI,
            TrainPartyUpdateInfo::mut_EEAFEPKNKMI,
            TrainPartyUpdateInfo::set_EEAFEPKNKMI,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::EKLMKFCKLAA::EKLMKFCKLAA>(
            "LKCLGKLDNHE",
            TrainPartyUpdateInfo::has_LKCLGKLDNHE,
            TrainPartyUpdateInfo::LKCLGKLDNHE,
            TrainPartyUpdateInfo::mut_LKCLGKLDNHE,
            TrainPartyUpdateInfo::set_LKCLGKLDNHE,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::LOCAOOGDAMB::LOCAOOGDAMB>(
            "IDMPFCHCPHO",
            TrainPartyUpdateInfo::has_IDMPFCHCPHO,
            TrainPartyUpdateInfo::IDMPFCHCPHO,
            TrainPartyUpdateInfo::mut_IDMPFCHCPHO,
            TrainPartyUpdateInfo::set_IDMPFCHCPHO,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::NHNNJJPBOMJ::NHNNJJPBOMJ>(
            "CKECMALEPAA",
            TrainPartyUpdateInfo::has_CKECMALEPAA,
            TrainPartyUpdateInfo::CKECMALEPAA,
            TrainPartyUpdateInfo::mut_CKECMALEPAA,
            TrainPartyUpdateInfo::set_CKECMALEPAA,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::JCDCKOAPGEE::JCDCKOAPGEE>(
            "NCLOBABIAHI",
            TrainPartyUpdateInfo::has_NCLOBABIAHI,
            TrainPartyUpdateInfo::NCLOBABIAHI,
            TrainPartyUpdateInfo::mut_NCLOBABIAHI,
            TrainPartyUpdateInfo::set_NCLOBABIAHI,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::KNINCLCJODM::KNINCLCJODM>(
            "APGDKAPIMGF",
            TrainPartyUpdateInfo::has_APGDKAPIMGF,
            TrainPartyUpdateInfo::APGDKAPIMGF,
            TrainPartyUpdateInfo::mut_APGDKAPIMGF,
            TrainPartyUpdateInfo::set_APGDKAPIMGF,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "src",
            |m: &TrainPartyUpdateInfo| { &m.src },
            |m: &mut TrainPartyUpdateInfo| { &mut m.src },
        ));
        oneofs.push(train_party_update_info::OMNKNOLIHNB::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyUpdateInfo>(
            "TrainPartyUpdateInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyUpdateInfo {
    const NAME: &'static str = "TrainPartyUpdateInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                15562 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::FOAFPCNJNAM(is.read_message()?));
                },
                13642 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::IHKAOGHIMDN(is.read_message()?));
                },
                8682 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::GJKIGLGOOAF(is.read_message()?));
                },
                5290 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::EEAFEPKNKMI(is.read_message()?));
                },
                12378 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::LKCLGKLDNHE(is.read_message()?));
                },
                6722 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::IDMPFCHCPHO(is.read_message()?));
                },
                11122 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::CKECMALEPAA(is.read_message()?));
                },
                634 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::NCLOBABIAHI(is.read_message()?));
                },
                6242 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(train_party_update_info::OMNKNOLIHNB::APGDKAPIMGF(is.read_message()?));
                },
                104 => {
                    self.src = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.src != ::protobuf::EnumOrUnknown::new(TrainPartyUpdateSrc::kTrainPartySrcNone) {
            my_size += ::protobuf::rt::int32_size(13, self.src.value());
        }
        if let ::std::option::Option::Some(ref v) = self.OMNKNOLIHNB {
            match v {
                &train_party_update_info::OMNKNOLIHNB::FOAFPCNJNAM(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &train_party_update_info::OMNKNOLIHNB::IHKAOGHIMDN(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &train_party_update_info::OMNKNOLIHNB::GJKIGLGOOAF(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &train_party_update_info::OMNKNOLIHNB::EEAFEPKNKMI(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &train_party_update_info::OMNKNOLIHNB::LKCLGKLDNHE(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &train_party_update_info::OMNKNOLIHNB::IDMPFCHCPHO(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &train_party_update_info::OMNKNOLIHNB::CKECMALEPAA(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &train_party_update_info::OMNKNOLIHNB::NCLOBABIAHI(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &train_party_update_info::OMNKNOLIHNB::APGDKAPIMGF(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.src != ::protobuf::EnumOrUnknown::new(TrainPartyUpdateSrc::kTrainPartySrcNone) {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(&self.src))?;
        }
        if let ::std::option::Option::Some(ref v) = self.OMNKNOLIHNB {
            match v {
                &train_party_update_info::OMNKNOLIHNB::FOAFPCNJNAM(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1945, v, os)?;
                },
                &train_party_update_info::OMNKNOLIHNB::IHKAOGHIMDN(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1705, v, os)?;
                },
                &train_party_update_info::OMNKNOLIHNB::GJKIGLGOOAF(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1085, v, os)?;
                },
                &train_party_update_info::OMNKNOLIHNB::EEAFEPKNKMI(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(661, v, os)?;
                },
                &train_party_update_info::OMNKNOLIHNB::LKCLGKLDNHE(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1547, v, os)?;
                },
                &train_party_update_info::OMNKNOLIHNB::IDMPFCHCPHO(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(840, v, os)?;
                },
                &train_party_update_info::OMNKNOLIHNB::CKECMALEPAA(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1390, v, os)?;
                },
                &train_party_update_info::OMNKNOLIHNB::NCLOBABIAHI(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(79, v, os)?;
                },
                &train_party_update_info::OMNKNOLIHNB::APGDKAPIMGF(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(780, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyUpdateInfo {
        TrainPartyUpdateInfo::new()
    }

    fn clear(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.src = ::protobuf::EnumOrUnknown::new(TrainPartyUpdateSrc::kTrainPartySrcNone);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyUpdateInfo {
        static instance: TrainPartyUpdateInfo = TrainPartyUpdateInfo {
            src: ::protobuf::EnumOrUnknown::from_i32(0),
            OMNKNOLIHNB: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyUpdateInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyUpdateInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyUpdateInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyUpdateInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TrainPartyUpdateInfo`
pub mod train_party_update_info {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:TrainPartyUpdateInfo.OMNKNOLIHNB)
    pub enum OMNKNOLIHNB {
        // @@protoc_insertion_point(oneof_field:TrainPartyUpdateInfo.FOAFPCNJNAM)
        FOAFPCNJNAM(super::TrainPartyCards),
        // @@protoc_insertion_point(oneof_field:TrainPartyUpdateInfo.IHKAOGHIMDN)
        IHKAOGHIMDN(super::super::BFFIEMJEDIL::BFFIEMJEDIL),
        // @@protoc_insertion_point(oneof_field:TrainPartyUpdateInfo.GJKIGLGOOAF)
        GJKIGLGOOAF(super::super::MINMHDAEEHH::MINMHDAEEHH),
        // @@protoc_insertion_point(oneof_field:TrainPartyUpdateInfo.EEAFEPKNKMI)
        EEAFEPKNKMI(super::super::LFHKDENCECI::LFHKDENCECI),
        // @@protoc_insertion_point(oneof_field:TrainPartyUpdateInfo.LKCLGKLDNHE)
        LKCLGKLDNHE(super::super::EKLMKFCKLAA::EKLMKFCKLAA),
        // @@protoc_insertion_point(oneof_field:TrainPartyUpdateInfo.IDMPFCHCPHO)
        IDMPFCHCPHO(super::super::LOCAOOGDAMB::LOCAOOGDAMB),
        // @@protoc_insertion_point(oneof_field:TrainPartyUpdateInfo.CKECMALEPAA)
        CKECMALEPAA(super::super::NHNNJJPBOMJ::NHNNJJPBOMJ),
        // @@protoc_insertion_point(oneof_field:TrainPartyUpdateInfo.NCLOBABIAHI)
        NCLOBABIAHI(super::super::JCDCKOAPGEE::JCDCKOAPGEE),
        // @@protoc_insertion_point(oneof_field:TrainPartyUpdateInfo.APGDKAPIMGF)
        APGDKAPIMGF(super::super::KNINCLCJODM::KNINCLCJODM),
    }

    impl ::protobuf::Oneof for OMNKNOLIHNB {
    }

    impl ::protobuf::OneofFull for OMNKNOLIHNB {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TrainPartyUpdateInfo as ::protobuf::MessageFull>::descriptor().oneof_by_name("OMNKNOLIHNB").unwrap()).clone()
        }
    }

    impl OMNKNOLIHNB {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<OMNKNOLIHNB>("OMNKNOLIHNB")
        }
    }
}

// @@protoc_insertion_point(message:TrainPartySyncUpdateScNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartySyncUpdateScNotify {
    // message fields
    // @@protoc_insertion_point(field:TrainPartySyncUpdateScNotify.update_info_list)
    pub update_info_list: ::std::vec::Vec<TrainPartyUpdateInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartySyncUpdateScNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartySyncUpdateScNotify {
    fn default() -> &'a TrainPartySyncUpdateScNotify {
        <TrainPartySyncUpdateScNotify as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartySyncUpdateScNotify {
    pub fn new() -> TrainPartySyncUpdateScNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "update_info_list",
            |m: &TrainPartySyncUpdateScNotify| { &m.update_info_list },
            |m: &mut TrainPartySyncUpdateScNotify| { &mut m.update_info_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartySyncUpdateScNotify>(
            "TrainPartySyncUpdateScNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartySyncUpdateScNotify {
    const NAME: &'static str = "TrainPartySyncUpdateScNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                74 => {
                    self.update_info_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.update_info_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.update_info_list {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartySyncUpdateScNotify {
        TrainPartySyncUpdateScNotify::new()
    }

    fn clear(&mut self) {
        self.update_info_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartySyncUpdateScNotify {
        static instance: TrainPartySyncUpdateScNotify = TrainPartySyncUpdateScNotify {
            update_info_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartySyncUpdateScNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartySyncUpdateScNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartySyncUpdateScNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartySyncUpdateScNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyPendingAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyPendingAction {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyPendingAction.LMFHNELKFOC)
    pub LMFHNELKFOC: u32,
    // message oneof groups
    pub MHJAPKEOAIK: ::std::option::Option<train_party_pending_action::MHJAPKEOAIK>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyPendingAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyPendingAction {
    fn default() -> &'a TrainPartyPendingAction {
        <TrainPartyPendingAction as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyPendingAction {
    pub fn new() -> TrainPartyPendingAction {
        ::std::default::Default::default()
    }

    // .EEIADCHLFNB GFLJGKBPCGB = 1263;

    pub fn GFLJGKBPCGB(&self) -> &super::EEIADCHLFNB::EEIADCHLFNB {
        match self.MHJAPKEOAIK {
            ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::GFLJGKBPCGB(ref v)) => v,
            _ => <super::EEIADCHLFNB::EEIADCHLFNB as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_GFLJGKBPCGB(&mut self) {
        self.MHJAPKEOAIK = ::std::option::Option::None;
    }

    pub fn has_GFLJGKBPCGB(&self) -> bool {
        match self.MHJAPKEOAIK {
            ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::GFLJGKBPCGB(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_GFLJGKBPCGB(&mut self, v: super::EEIADCHLFNB::EEIADCHLFNB) {
        self.MHJAPKEOAIK = ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::GFLJGKBPCGB(v))
    }

    // Mutable pointer to the field.
    pub fn mut_GFLJGKBPCGB(&mut self) -> &mut super::EEIADCHLFNB::EEIADCHLFNB {
        if let ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::GFLJGKBPCGB(_)) = self.MHJAPKEOAIK {
        } else {
            self.MHJAPKEOAIK = ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::GFLJGKBPCGB(super::EEIADCHLFNB::EEIADCHLFNB::new()));
        }
        match self.MHJAPKEOAIK {
            ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::GFLJGKBPCGB(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_GFLJGKBPCGB(&mut self) -> super::EEIADCHLFNB::EEIADCHLFNB {
        if self.has_GFLJGKBPCGB() {
            match self.MHJAPKEOAIK.take() {
                ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::GFLJGKBPCGB(v)) => v,
                _ => panic!(),
            }
        } else {
            super::EEIADCHLFNB::EEIADCHLFNB::new()
        }
    }

    // .BOMJDHMAAJM HAKLMMJEHPF = 1647;

    pub fn HAKLMMJEHPF(&self) -> &super::BOMJDHMAAJM::BOMJDHMAAJM {
        match self.MHJAPKEOAIK {
            ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::HAKLMMJEHPF(ref v)) => v,
            _ => <super::BOMJDHMAAJM::BOMJDHMAAJM as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_HAKLMMJEHPF(&mut self) {
        self.MHJAPKEOAIK = ::std::option::Option::None;
    }

    pub fn has_HAKLMMJEHPF(&self) -> bool {
        match self.MHJAPKEOAIK {
            ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::HAKLMMJEHPF(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_HAKLMMJEHPF(&mut self, v: super::BOMJDHMAAJM::BOMJDHMAAJM) {
        self.MHJAPKEOAIK = ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::HAKLMMJEHPF(v))
    }

    // Mutable pointer to the field.
    pub fn mut_HAKLMMJEHPF(&mut self) -> &mut super::BOMJDHMAAJM::BOMJDHMAAJM {
        if let ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::HAKLMMJEHPF(_)) = self.MHJAPKEOAIK {
        } else {
            self.MHJAPKEOAIK = ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::HAKLMMJEHPF(super::BOMJDHMAAJM::BOMJDHMAAJM::new()));
        }
        match self.MHJAPKEOAIK {
            ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::HAKLMMJEHPF(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_HAKLMMJEHPF(&mut self) -> super::BOMJDHMAAJM::BOMJDHMAAJM {
        if self.has_HAKLMMJEHPF() {
            match self.MHJAPKEOAIK.take() {
                ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::HAKLMMJEHPF(v)) => v,
                _ => panic!(),
            }
        } else {
            super::BOMJDHMAAJM::BOMJDHMAAJM::new()
        }
    }

    // .TrainPartyMeetingData JJFGCDEHMPF = 410;

    pub fn JJFGCDEHMPF(&self) -> &TrainPartyMeetingData {
        match self.MHJAPKEOAIK {
            ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::JJFGCDEHMPF(ref v)) => v,
            _ => <TrainPartyMeetingData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_JJFGCDEHMPF(&mut self) {
        self.MHJAPKEOAIK = ::std::option::Option::None;
    }

    pub fn has_JJFGCDEHMPF(&self) -> bool {
        match self.MHJAPKEOAIK {
            ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::JJFGCDEHMPF(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_JJFGCDEHMPF(&mut self, v: TrainPartyMeetingData) {
        self.MHJAPKEOAIK = ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::JJFGCDEHMPF(v))
    }

    // Mutable pointer to the field.
    pub fn mut_JJFGCDEHMPF(&mut self) -> &mut TrainPartyMeetingData {
        if let ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::JJFGCDEHMPF(_)) = self.MHJAPKEOAIK {
        } else {
            self.MHJAPKEOAIK = ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::JJFGCDEHMPF(TrainPartyMeetingData::new()));
        }
        match self.MHJAPKEOAIK {
            ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::JJFGCDEHMPF(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_JJFGCDEHMPF(&mut self) -> TrainPartyMeetingData {
        if self.has_JJFGCDEHMPF() {
            match self.MHJAPKEOAIK.take() {
                ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::JJFGCDEHMPF(v)) => v,
                _ => panic!(),
            }
        } else {
            TrainPartyMeetingData::new()
        }
    }

    // .TrainPartyReplaceSkillAction EPPNHJCNFCI = 543;

    pub fn EPPNHJCNFCI(&self) -> &TrainPartyReplaceSkillAction {
        match self.MHJAPKEOAIK {
            ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::EPPNHJCNFCI(ref v)) => v,
            _ => <TrainPartyReplaceSkillAction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_EPPNHJCNFCI(&mut self) {
        self.MHJAPKEOAIK = ::std::option::Option::None;
    }

    pub fn has_EPPNHJCNFCI(&self) -> bool {
        match self.MHJAPKEOAIK {
            ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::EPPNHJCNFCI(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_EPPNHJCNFCI(&mut self, v: TrainPartyReplaceSkillAction) {
        self.MHJAPKEOAIK = ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::EPPNHJCNFCI(v))
    }

    // Mutable pointer to the field.
    pub fn mut_EPPNHJCNFCI(&mut self) -> &mut TrainPartyReplaceSkillAction {
        if let ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::EPPNHJCNFCI(_)) = self.MHJAPKEOAIK {
        } else {
            self.MHJAPKEOAIK = ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::EPPNHJCNFCI(TrainPartyReplaceSkillAction::new()));
        }
        match self.MHJAPKEOAIK {
            ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::EPPNHJCNFCI(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_EPPNHJCNFCI(&mut self) -> TrainPartyReplaceSkillAction {
        if self.has_EPPNHJCNFCI() {
            match self.MHJAPKEOAIK.take() {
                ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::EPPNHJCNFCI(v)) => v,
                _ => panic!(),
            }
        } else {
            TrainPartyReplaceSkillAction::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::EEIADCHLFNB::EEIADCHLFNB>(
            "GFLJGKBPCGB",
            TrainPartyPendingAction::has_GFLJGKBPCGB,
            TrainPartyPendingAction::GFLJGKBPCGB,
            TrainPartyPendingAction::mut_GFLJGKBPCGB,
            TrainPartyPendingAction::set_GFLJGKBPCGB,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::BOMJDHMAAJM::BOMJDHMAAJM>(
            "HAKLMMJEHPF",
            TrainPartyPendingAction::has_HAKLMMJEHPF,
            TrainPartyPendingAction::HAKLMMJEHPF,
            TrainPartyPendingAction::mut_HAKLMMJEHPF,
            TrainPartyPendingAction::set_HAKLMMJEHPF,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TrainPartyMeetingData>(
            "JJFGCDEHMPF",
            TrainPartyPendingAction::has_JJFGCDEHMPF,
            TrainPartyPendingAction::JJFGCDEHMPF,
            TrainPartyPendingAction::mut_JJFGCDEHMPF,
            TrainPartyPendingAction::set_JJFGCDEHMPF,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TrainPartyReplaceSkillAction>(
            "EPPNHJCNFCI",
            TrainPartyPendingAction::has_EPPNHJCNFCI,
            TrainPartyPendingAction::EPPNHJCNFCI,
            TrainPartyPendingAction::mut_EPPNHJCNFCI,
            TrainPartyPendingAction::set_EPPNHJCNFCI,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LMFHNELKFOC",
            |m: &TrainPartyPendingAction| { &m.LMFHNELKFOC },
            |m: &mut TrainPartyPendingAction| { &mut m.LMFHNELKFOC },
        ));
        oneofs.push(train_party_pending_action::MHJAPKEOAIK::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyPendingAction>(
            "TrainPartyPendingAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyPendingAction {
    const NAME: &'static str = "TrainPartyPendingAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10106 => {
                    self.MHJAPKEOAIK = ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::GFLJGKBPCGB(is.read_message()?));
                },
                13178 => {
                    self.MHJAPKEOAIK = ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::HAKLMMJEHPF(is.read_message()?));
                },
                3282 => {
                    self.MHJAPKEOAIK = ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::JJFGCDEHMPF(is.read_message()?));
                },
                4346 => {
                    self.MHJAPKEOAIK = ::std::option::Option::Some(train_party_pending_action::MHJAPKEOAIK::EPPNHJCNFCI(is.read_message()?));
                },
                56 => {
                    self.LMFHNELKFOC = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.LMFHNELKFOC != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.LMFHNELKFOC);
        }
        if let ::std::option::Option::Some(ref v) = self.MHJAPKEOAIK {
            match v {
                &train_party_pending_action::MHJAPKEOAIK::GFLJGKBPCGB(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &train_party_pending_action::MHJAPKEOAIK::HAKLMMJEHPF(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &train_party_pending_action::MHJAPKEOAIK::JJFGCDEHMPF(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &train_party_pending_action::MHJAPKEOAIK::EPPNHJCNFCI(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.LMFHNELKFOC != 0 {
            os.write_uint32(7, self.LMFHNELKFOC)?;
        }
        if let ::std::option::Option::Some(ref v) = self.MHJAPKEOAIK {
            match v {
                &train_party_pending_action::MHJAPKEOAIK::GFLJGKBPCGB(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1263, v, os)?;
                },
                &train_party_pending_action::MHJAPKEOAIK::HAKLMMJEHPF(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1647, v, os)?;
                },
                &train_party_pending_action::MHJAPKEOAIK::JJFGCDEHMPF(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(410, v, os)?;
                },
                &train_party_pending_action::MHJAPKEOAIK::EPPNHJCNFCI(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(543, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyPendingAction {
        TrainPartyPendingAction::new()
    }

    fn clear(&mut self) {
        self.MHJAPKEOAIK = ::std::option::Option::None;
        self.MHJAPKEOAIK = ::std::option::Option::None;
        self.MHJAPKEOAIK = ::std::option::Option::None;
        self.MHJAPKEOAIK = ::std::option::Option::None;
        self.LMFHNELKFOC = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyPendingAction {
        static instance: TrainPartyPendingAction = TrainPartyPendingAction {
            LMFHNELKFOC: 0,
            MHJAPKEOAIK: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyPendingAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyPendingAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyPendingAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyPendingAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TrainPartyPendingAction`
pub mod train_party_pending_action {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:TrainPartyPendingAction.MHJAPKEOAIK)
    pub enum MHJAPKEOAIK {
        // @@protoc_insertion_point(oneof_field:TrainPartyPendingAction.GFLJGKBPCGB)
        GFLJGKBPCGB(super::super::EEIADCHLFNB::EEIADCHLFNB),
        // @@protoc_insertion_point(oneof_field:TrainPartyPendingAction.HAKLMMJEHPF)
        HAKLMMJEHPF(super::super::BOMJDHMAAJM::BOMJDHMAAJM),
        // @@protoc_insertion_point(oneof_field:TrainPartyPendingAction.JJFGCDEHMPF)
        JJFGCDEHMPF(super::TrainPartyMeetingData),
        // @@protoc_insertion_point(oneof_field:TrainPartyPendingAction.EPPNHJCNFCI)
        EPPNHJCNFCI(super::TrainPartyReplaceSkillAction),
    }

    impl ::protobuf::Oneof for MHJAPKEOAIK {
    }

    impl ::protobuf::OneofFull for MHJAPKEOAIK {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TrainPartyPendingAction as ::protobuf::MessageFull>::descriptor().oneof_by_name("MHJAPKEOAIK").unwrap()).clone()
        }
    }

    impl MHJAPKEOAIK {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<MHJAPKEOAIK>("MHJAPKEOAIK")
        }
    }
}

// @@protoc_insertion_point(message:JIGMPADFPHE)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct JIGMPADFPHE {
    // message fields
    // @@protoc_insertion_point(field:JIGMPADFPHE.PBALFFCFPJD)
    pub PBALFFCFPJD: u32,
    // @@protoc_insertion_point(field:JIGMPADFPHE.HJCGEIDBICC)
    pub HJCGEIDBICC: bool,
    // special fields
    // @@protoc_insertion_point(special_field:JIGMPADFPHE.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a JIGMPADFPHE {
    fn default() -> &'a JIGMPADFPHE {
        <JIGMPADFPHE as ::protobuf::Message>::default_instance()
    }
}

impl JIGMPADFPHE {
    pub fn new() -> JIGMPADFPHE {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PBALFFCFPJD",
            |m: &JIGMPADFPHE| { &m.PBALFFCFPJD },
            |m: &mut JIGMPADFPHE| { &mut m.PBALFFCFPJD },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "HJCGEIDBICC",
            |m: &JIGMPADFPHE| { &m.HJCGEIDBICC },
            |m: &mut JIGMPADFPHE| { &mut m.HJCGEIDBICC },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JIGMPADFPHE>(
            "JIGMPADFPHE",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for JIGMPADFPHE {
    const NAME: &'static str = "JIGMPADFPHE";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.PBALFFCFPJD = is.read_uint32()?;
                },
                40 => {
                    self.HJCGEIDBICC = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.PBALFFCFPJD != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.PBALFFCFPJD);
        }
        if self.HJCGEIDBICC != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.PBALFFCFPJD != 0 {
            os.write_uint32(10, self.PBALFFCFPJD)?;
        }
        if self.HJCGEIDBICC != false {
            os.write_bool(5, self.HJCGEIDBICC)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> JIGMPADFPHE {
        JIGMPADFPHE::new()
    }

    fn clear(&mut self) {
        self.PBALFFCFPJD = 0;
        self.HJCGEIDBICC = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static JIGMPADFPHE {
        static instance: JIGMPADFPHE = JIGMPADFPHE {
            PBALFFCFPJD: 0,
            HJCGEIDBICC: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for JIGMPADFPHE {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("JIGMPADFPHE").unwrap()).clone()
    }
}

impl ::std::fmt::Display for JIGMPADFPHE {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JIGMPADFPHE {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EEIADCHLFNB)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EEIADCHLFNB {
    // message fields
    // @@protoc_insertion_point(field:EEIADCHLFNB.KJCDHKMKOPK)
    pub KJCDHKMKOPK: ::std::vec::Vec<super::JIGMPADFPHE::JIGMPADFPHE>,
    // @@protoc_insertion_point(field:EEIADCHLFNB.AFOAGCODJLK)
    pub AFOAGCODJLK: ::protobuf::EnumOrUnknown<super::EJLFEABGGID::EJLFEABGGID>,
    // @@protoc_insertion_point(field:EEIADCHLFNB.event_id)
    pub event_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:EEIADCHLFNB.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EEIADCHLFNB {
    fn default() -> &'a EEIADCHLFNB {
        <EEIADCHLFNB as ::protobuf::Message>::default_instance()
    }
}

impl EEIADCHLFNB {
    pub fn new() -> EEIADCHLFNB {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "KJCDHKMKOPK",
            |m: &EEIADCHLFNB| { &m.KJCDHKMKOPK },
            |m: &mut EEIADCHLFNB| { &mut m.KJCDHKMKOPK },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "AFOAGCODJLK",
            |m: &EEIADCHLFNB| { &m.AFOAGCODJLK },
            |m: &mut EEIADCHLFNB| { &mut m.AFOAGCODJLK },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "event_id",
            |m: &EEIADCHLFNB| { &m.event_id },
            |m: &mut EEIADCHLFNB| { &mut m.event_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EEIADCHLFNB>(
            "EEIADCHLFNB",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EEIADCHLFNB {
    const NAME: &'static str = "EEIADCHLFNB";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                114 => {
                    self.KJCDHKMKOPK.push(is.read_message()?);
                },
                96 => {
                    self.AFOAGCODJLK = is.read_enum_or_unknown()?;
                },
                80 => {
                    self.event_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.KJCDHKMKOPK {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.AFOAGCODJLK != ::protobuf::EnumOrUnknown::new(super::EJLFEABGGID::EJLFEABGGID::kDialogueEventNone) {
            my_size += ::protobuf::rt::int32_size(12, self.AFOAGCODJLK.value());
        }
        if self.event_id != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.event_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.KJCDHKMKOPK {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        if self.AFOAGCODJLK != ::protobuf::EnumOrUnknown::new(super::EJLFEABGGID::EJLFEABGGID::kDialogueEventNone) {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&self.AFOAGCODJLK))?;
        }
        if self.event_id != 0 {
            os.write_uint32(10, self.event_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EEIADCHLFNB {
        EEIADCHLFNB::new()
    }

    fn clear(&mut self) {
        self.KJCDHKMKOPK.clear();
        self.AFOAGCODJLK = ::protobuf::EnumOrUnknown::new(super::EJLFEABGGID::EJLFEABGGID::kDialogueEventNone);
        self.event_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EEIADCHLFNB {
        static instance: EEIADCHLFNB = EEIADCHLFNB {
            KJCDHKMKOPK: ::std::vec::Vec::new(),
            AFOAGCODJLK: ::protobuf::EnumOrUnknown::from_i32(0),
            event_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EEIADCHLFNB {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EEIADCHLFNB").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EEIADCHLFNB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EEIADCHLFNB {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NIBBILKHHHE)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NIBBILKHHHE {
    // message fields
    // @@protoc_insertion_point(field:NIBBILKHHHE.PBALFFCFPJD)
    pub PBALFFCFPJD: u32,
    // special fields
    // @@protoc_insertion_point(special_field:NIBBILKHHHE.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NIBBILKHHHE {
    fn default() -> &'a NIBBILKHHHE {
        <NIBBILKHHHE as ::protobuf::Message>::default_instance()
    }
}

impl NIBBILKHHHE {
    pub fn new() -> NIBBILKHHHE {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PBALFFCFPJD",
            |m: &NIBBILKHHHE| { &m.PBALFFCFPJD },
            |m: &mut NIBBILKHHHE| { &mut m.PBALFFCFPJD },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NIBBILKHHHE>(
            "NIBBILKHHHE",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NIBBILKHHHE {
    const NAME: &'static str = "NIBBILKHHHE";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.PBALFFCFPJD = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.PBALFFCFPJD != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.PBALFFCFPJD);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.PBALFFCFPJD != 0 {
            os.write_uint32(6, self.PBALFFCFPJD)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NIBBILKHHHE {
        NIBBILKHHHE::new()
    }

    fn clear(&mut self) {
        self.PBALFFCFPJD = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NIBBILKHHHE {
        static instance: NIBBILKHHHE = NIBBILKHHHE {
            PBALFFCFPJD: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NIBBILKHHHE {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NIBBILKHHHE").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NIBBILKHHHE {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NIBBILKHHHE {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:KBFEOIAJLJC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KBFEOIAJLJC {
    // message fields
    // @@protoc_insertion_point(field:KBFEOIAJLJC.NCPFPAMHAOE)
    pub NCPFPAMHAOE: u32,
    // @@protoc_insertion_point(field:KBFEOIAJLJC.MOCKIOPKEKE)
    pub MOCKIOPKEKE: u32,
    // @@protoc_insertion_point(field:KBFEOIAJLJC.level)
    pub level: u32,
    // special fields
    // @@protoc_insertion_point(special_field:KBFEOIAJLJC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KBFEOIAJLJC {
    fn default() -> &'a KBFEOIAJLJC {
        <KBFEOIAJLJC as ::protobuf::Message>::default_instance()
    }
}

impl KBFEOIAJLJC {
    pub fn new() -> KBFEOIAJLJC {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NCPFPAMHAOE",
            |m: &KBFEOIAJLJC| { &m.NCPFPAMHAOE },
            |m: &mut KBFEOIAJLJC| { &mut m.NCPFPAMHAOE },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MOCKIOPKEKE",
            |m: &KBFEOIAJLJC| { &m.MOCKIOPKEKE },
            |m: &mut KBFEOIAJLJC| { &mut m.MOCKIOPKEKE },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "level",
            |m: &KBFEOIAJLJC| { &m.level },
            |m: &mut KBFEOIAJLJC| { &mut m.level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KBFEOIAJLJC>(
            "KBFEOIAJLJC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KBFEOIAJLJC {
    const NAME: &'static str = "KBFEOIAJLJC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                112 => {
                    self.NCPFPAMHAOE = is.read_uint32()?;
                },
                48 => {
                    self.MOCKIOPKEKE = is.read_uint32()?;
                },
                56 => {
                    self.level = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.NCPFPAMHAOE != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.NCPFPAMHAOE);
        }
        if self.MOCKIOPKEKE != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.MOCKIOPKEKE);
        }
        if self.level != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.level);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.NCPFPAMHAOE != 0 {
            os.write_uint32(14, self.NCPFPAMHAOE)?;
        }
        if self.MOCKIOPKEKE != 0 {
            os.write_uint32(6, self.MOCKIOPKEKE)?;
        }
        if self.level != 0 {
            os.write_uint32(7, self.level)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KBFEOIAJLJC {
        KBFEOIAJLJC::new()
    }

    fn clear(&mut self) {
        self.NCPFPAMHAOE = 0;
        self.MOCKIOPKEKE = 0;
        self.level = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KBFEOIAJLJC {
        static instance: KBFEOIAJLJC = KBFEOIAJLJC {
            NCPFPAMHAOE: 0,
            MOCKIOPKEKE: 0,
            level: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KBFEOIAJLJC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KBFEOIAJLJC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KBFEOIAJLJC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KBFEOIAJLJC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BOMJDHMAAJM)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BOMJDHMAAJM {
    // message fields
    // @@protoc_insertion_point(field:BOMJDHMAAJM.passenger_id)
    pub passenger_id: u32,
    // @@protoc_insertion_point(field:BOMJDHMAAJM.KLBCINEMHBD)
    pub KLBCINEMHBD: ::std::vec::Vec<super::KBFEOIAJLJC::KBFEOIAJLJC>,
    // special fields
    // @@protoc_insertion_point(special_field:BOMJDHMAAJM.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BOMJDHMAAJM {
    fn default() -> &'a BOMJDHMAAJM {
        <BOMJDHMAAJM as ::protobuf::Message>::default_instance()
    }
}

impl BOMJDHMAAJM {
    pub fn new() -> BOMJDHMAAJM {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "passenger_id",
            |m: &BOMJDHMAAJM| { &m.passenger_id },
            |m: &mut BOMJDHMAAJM| { &mut m.passenger_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "KLBCINEMHBD",
            |m: &BOMJDHMAAJM| { &m.KLBCINEMHBD },
            |m: &mut BOMJDHMAAJM| { &mut m.KLBCINEMHBD },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BOMJDHMAAJM>(
            "BOMJDHMAAJM",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BOMJDHMAAJM {
    const NAME: &'static str = "BOMJDHMAAJM";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                96 => {
                    self.passenger_id = is.read_uint32()?;
                },
                34 => {
                    self.KLBCINEMHBD.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.passenger_id != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.passenger_id);
        }
        for value in &self.KLBCINEMHBD {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.passenger_id != 0 {
            os.write_uint32(12, self.passenger_id)?;
        }
        for v in &self.KLBCINEMHBD {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BOMJDHMAAJM {
        BOMJDHMAAJM::new()
    }

    fn clear(&mut self) {
        self.passenger_id = 0;
        self.KLBCINEMHBD.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BOMJDHMAAJM {
        static instance: BOMJDHMAAJM = BOMJDHMAAJM {
            passenger_id: 0,
            KLBCINEMHBD: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BOMJDHMAAJM {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BOMJDHMAAJM").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BOMJDHMAAJM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BOMJDHMAAJM {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyReplaceSkillAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyReplaceSkillAction {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyReplaceSkillAction.CKHOODLCGPK)
    pub CKHOODLCGPK: u32,
    // @@protoc_insertion_point(field:TrainPartyReplaceSkillAction.replaced_skill_list)
    pub replaced_skill_list: ::std::vec::Vec<TrainPartyPassengerSkillInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyReplaceSkillAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyReplaceSkillAction {
    fn default() -> &'a TrainPartyReplaceSkillAction {
        <TrainPartyReplaceSkillAction as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyReplaceSkillAction {
    pub fn new() -> TrainPartyReplaceSkillAction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CKHOODLCGPK",
            |m: &TrainPartyReplaceSkillAction| { &m.CKHOODLCGPK },
            |m: &mut TrainPartyReplaceSkillAction| { &mut m.CKHOODLCGPK },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "replaced_skill_list",
            |m: &TrainPartyReplaceSkillAction| { &m.replaced_skill_list },
            |m: &mut TrainPartyReplaceSkillAction| { &mut m.replaced_skill_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyReplaceSkillAction>(
            "TrainPartyReplaceSkillAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyReplaceSkillAction {
    const NAME: &'static str = "TrainPartyReplaceSkillAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                104 => {
                    self.CKHOODLCGPK = is.read_uint32()?;
                },
                122 => {
                    self.replaced_skill_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.CKHOODLCGPK != 0 {
            my_size += ::protobuf::rt::uint32_size(13, self.CKHOODLCGPK);
        }
        for value in &self.replaced_skill_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.CKHOODLCGPK != 0 {
            os.write_uint32(13, self.CKHOODLCGPK)?;
        }
        for v in &self.replaced_skill_list {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyReplaceSkillAction {
        TrainPartyReplaceSkillAction::new()
    }

    fn clear(&mut self) {
        self.CKHOODLCGPK = 0;
        self.replaced_skill_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyReplaceSkillAction {
        static instance: TrainPartyReplaceSkillAction = TrainPartyReplaceSkillAction {
            CKHOODLCGPK: 0,
            replaced_skill_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyReplaceSkillAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyReplaceSkillAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyReplaceSkillAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyReplaceSkillAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ICMFJIEIEBM)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ICMFJIEIEBM {
    // message fields
    // @@protoc_insertion_point(field:ICMFJIEIEBM.EJALDBPBMPI)
    pub EJALDBPBMPI: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ICMFJIEIEBM.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ICMFJIEIEBM {
    fn default() -> &'a ICMFJIEIEBM {
        <ICMFJIEIEBM as ::protobuf::Message>::default_instance()
    }
}

impl ICMFJIEIEBM {
    pub fn new() -> ICMFJIEIEBM {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "EJALDBPBMPI",
            |m: &ICMFJIEIEBM| { &m.EJALDBPBMPI },
            |m: &mut ICMFJIEIEBM| { &mut m.EJALDBPBMPI },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ICMFJIEIEBM>(
            "ICMFJIEIEBM",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ICMFJIEIEBM {
    const NAME: &'static str = "ICMFJIEIEBM";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.EJALDBPBMPI = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.EJALDBPBMPI != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.EJALDBPBMPI);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.EJALDBPBMPI != 0 {
            os.write_uint32(2, self.EJALDBPBMPI)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ICMFJIEIEBM {
        ICMFJIEIEBM::new()
    }

    fn clear(&mut self) {
        self.EJALDBPBMPI = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ICMFJIEIEBM {
        static instance: ICMFJIEIEBM = ICMFJIEIEBM {
            EJALDBPBMPI: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ICMFJIEIEBM {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ICMFJIEIEBM").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ICMFJIEIEBM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ICMFJIEIEBM {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyReplaceSkillActionResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyReplaceSkillActionResult {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyReplaceSkillActionResult.skill_info_list)
    pub skill_info_list: ::std::vec::Vec<TrainPartyPassengerSkillInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyReplaceSkillActionResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyReplaceSkillActionResult {
    fn default() -> &'a TrainPartyReplaceSkillActionResult {
        <TrainPartyReplaceSkillActionResult as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyReplaceSkillActionResult {
    pub fn new() -> TrainPartyReplaceSkillActionResult {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "skill_info_list",
            |m: &TrainPartyReplaceSkillActionResult| { &m.skill_info_list },
            |m: &mut TrainPartyReplaceSkillActionResult| { &mut m.skill_info_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyReplaceSkillActionResult>(
            "TrainPartyReplaceSkillActionResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyReplaceSkillActionResult {
    const NAME: &'static str = "TrainPartyReplaceSkillActionResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                58 => {
                    self.skill_info_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.skill_info_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.skill_info_list {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyReplaceSkillActionResult {
        TrainPartyReplaceSkillActionResult::new()
    }

    fn clear(&mut self) {
        self.skill_info_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyReplaceSkillActionResult {
        static instance: TrainPartyReplaceSkillActionResult = TrainPartyReplaceSkillActionResult {
            skill_info_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyReplaceSkillActionResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyReplaceSkillActionResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyReplaceSkillActionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyReplaceSkillActionResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyMeetingPassengerCardInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyMeetingPassengerCardInfo {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyMeetingPassengerCardInfo.unique_id)
    pub unique_id: u32,
    // @@protoc_insertion_point(field:TrainPartyMeetingPassengerCardInfo.DDELOEPNMPM)
    pub DDELOEPNMPM: u32,
    // @@protoc_insertion_point(field:TrainPartyMeetingPassengerCardInfo.passenger_id)
    pub passenger_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyMeetingPassengerCardInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyMeetingPassengerCardInfo {
    fn default() -> &'a TrainPartyMeetingPassengerCardInfo {
        <TrainPartyMeetingPassengerCardInfo as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyMeetingPassengerCardInfo {
    pub fn new() -> TrainPartyMeetingPassengerCardInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &TrainPartyMeetingPassengerCardInfo| { &m.unique_id },
            |m: &mut TrainPartyMeetingPassengerCardInfo| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DDELOEPNMPM",
            |m: &TrainPartyMeetingPassengerCardInfo| { &m.DDELOEPNMPM },
            |m: &mut TrainPartyMeetingPassengerCardInfo| { &mut m.DDELOEPNMPM },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "passenger_id",
            |m: &TrainPartyMeetingPassengerCardInfo| { &m.passenger_id },
            |m: &mut TrainPartyMeetingPassengerCardInfo| { &mut m.passenger_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyMeetingPassengerCardInfo>(
            "TrainPartyMeetingPassengerCardInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyMeetingPassengerCardInfo {
    const NAME: &'static str = "TrainPartyMeetingPassengerCardInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.unique_id = is.read_uint32()?;
                },
                48 => {
                    self.DDELOEPNMPM = is.read_uint32()?;
                },
                16 => {
                    self.passenger_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.unique_id != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.unique_id);
        }
        if self.DDELOEPNMPM != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.DDELOEPNMPM);
        }
        if self.passenger_id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.passenger_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.unique_id != 0 {
            os.write_uint32(10, self.unique_id)?;
        }
        if self.DDELOEPNMPM != 0 {
            os.write_uint32(6, self.DDELOEPNMPM)?;
        }
        if self.passenger_id != 0 {
            os.write_uint32(2, self.passenger_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyMeetingPassengerCardInfo {
        TrainPartyMeetingPassengerCardInfo::new()
    }

    fn clear(&mut self) {
        self.unique_id = 0;
        self.DDELOEPNMPM = 0;
        self.passenger_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyMeetingPassengerCardInfo {
        static instance: TrainPartyMeetingPassengerCardInfo = TrainPartyMeetingPassengerCardInfo {
            unique_id: 0,
            DDELOEPNMPM: 0,
            passenger_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyMeetingPassengerCardInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyMeetingPassengerCardInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyMeetingPassengerCardInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyMeetingPassengerCardInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyMeetingLeftCardInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyMeetingLeftCardInfo {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyMeetingLeftCardInfo.num)
    pub num: u32,
    // @@protoc_insertion_point(field:TrainPartyMeetingLeftCardInfo.passenger_id)
    pub passenger_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyMeetingLeftCardInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyMeetingLeftCardInfo {
    fn default() -> &'a TrainPartyMeetingLeftCardInfo {
        <TrainPartyMeetingLeftCardInfo as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyMeetingLeftCardInfo {
    pub fn new() -> TrainPartyMeetingLeftCardInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num",
            |m: &TrainPartyMeetingLeftCardInfo| { &m.num },
            |m: &mut TrainPartyMeetingLeftCardInfo| { &mut m.num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "passenger_id",
            |m: &TrainPartyMeetingLeftCardInfo| { &m.passenger_id },
            |m: &mut TrainPartyMeetingLeftCardInfo| { &mut m.passenger_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyMeetingLeftCardInfo>(
            "TrainPartyMeetingLeftCardInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyMeetingLeftCardInfo {
    const NAME: &'static str = "TrainPartyMeetingLeftCardInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.num = is.read_uint32()?;
                },
                88 => {
                    self.passenger_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.num != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.num);
        }
        if self.passenger_id != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.passenger_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.num != 0 {
            os.write_uint32(6, self.num)?;
        }
        if self.passenger_id != 0 {
            os.write_uint32(11, self.passenger_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyMeetingLeftCardInfo {
        TrainPartyMeetingLeftCardInfo::new()
    }

    fn clear(&mut self) {
        self.num = 0;
        self.passenger_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyMeetingLeftCardInfo {
        static instance: TrainPartyMeetingLeftCardInfo = TrainPartyMeetingLeftCardInfo {
            num: 0,
            passenger_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyMeetingLeftCardInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyMeetingLeftCardInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyMeetingLeftCardInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyMeetingLeftCardInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyMeetingData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyMeetingData {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyMeetingData.DEABGMBGMPP)
    pub DEABGMBGMPP: u32,
    // @@protoc_insertion_point(field:TrainPartyMeetingData.left_card_info_list)
    pub left_card_info_list: ::std::vec::Vec<TrainPartyMeetingLeftCardInfo>,
    // @@protoc_insertion_point(field:TrainPartyMeetingData.PCHFKBKLDMJ)
    pub PCHFKBKLDMJ: u32,
    // @@protoc_insertion_point(field:TrainPartyMeetingData.OADOFHHHOEJ)
    pub OADOFHHHOEJ: u32,
    // @@protoc_insertion_point(field:TrainPartyMeetingData.EKDNBEKFECL)
    pub EKDNBEKFECL: u32,
    // @@protoc_insertion_point(field:TrainPartyMeetingData.AAGJLMHLJPK)
    pub AAGJLMHLJPK: ::std::vec::Vec<super::KHIIKMDCABJ::KHIIKMDCABJ>,
    // @@protoc_insertion_point(field:TrainPartyMeetingData.passenger_card_list)
    pub passenger_card_list: ::std::vec::Vec<TrainPartyMeetingPassengerCardInfo>,
    // @@protoc_insertion_point(field:TrainPartyMeetingData.BHKMEGPLPFA)
    pub BHKMEGPLPFA: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyMeetingData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyMeetingData {
    fn default() -> &'a TrainPartyMeetingData {
        <TrainPartyMeetingData as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyMeetingData {
    pub fn new() -> TrainPartyMeetingData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DEABGMBGMPP",
            |m: &TrainPartyMeetingData| { &m.DEABGMBGMPP },
            |m: &mut TrainPartyMeetingData| { &mut m.DEABGMBGMPP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "left_card_info_list",
            |m: &TrainPartyMeetingData| { &m.left_card_info_list },
            |m: &mut TrainPartyMeetingData| { &mut m.left_card_info_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PCHFKBKLDMJ",
            |m: &TrainPartyMeetingData| { &m.PCHFKBKLDMJ },
            |m: &mut TrainPartyMeetingData| { &mut m.PCHFKBKLDMJ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OADOFHHHOEJ",
            |m: &TrainPartyMeetingData| { &m.OADOFHHHOEJ },
            |m: &mut TrainPartyMeetingData| { &mut m.OADOFHHHOEJ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "EKDNBEKFECL",
            |m: &TrainPartyMeetingData| { &m.EKDNBEKFECL },
            |m: &mut TrainPartyMeetingData| { &mut m.EKDNBEKFECL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "AAGJLMHLJPK",
            |m: &TrainPartyMeetingData| { &m.AAGJLMHLJPK },
            |m: &mut TrainPartyMeetingData| { &mut m.AAGJLMHLJPK },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "passenger_card_list",
            |m: &TrainPartyMeetingData| { &m.passenger_card_list },
            |m: &mut TrainPartyMeetingData| { &mut m.passenger_card_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "BHKMEGPLPFA",
            |m: &TrainPartyMeetingData| { &m.BHKMEGPLPFA },
            |m: &mut TrainPartyMeetingData| { &mut m.BHKMEGPLPFA },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyMeetingData>(
            "TrainPartyMeetingData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyMeetingData {
    const NAME: &'static str = "TrainPartyMeetingData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.DEABGMBGMPP = is.read_uint32()?;
                },
                34 => {
                    self.left_card_info_list.push(is.read_message()?);
                },
                64 => {
                    self.PCHFKBKLDMJ = is.read_uint32()?;
                },
                88 => {
                    self.OADOFHHHOEJ = is.read_uint32()?;
                },
                56 => {
                    self.EKDNBEKFECL = is.read_uint32()?;
                },
                18 => {
                    self.AAGJLMHLJPK.push(is.read_message()?);
                },
                50 => {
                    self.passenger_card_list.push(is.read_message()?);
                },
                40 => {
                    self.BHKMEGPLPFA = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.DEABGMBGMPP != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.DEABGMBGMPP);
        }
        for value in &self.left_card_info_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.PCHFKBKLDMJ != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.PCHFKBKLDMJ);
        }
        if self.OADOFHHHOEJ != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.OADOFHHHOEJ);
        }
        if self.EKDNBEKFECL != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.EKDNBEKFECL);
        }
        for value in &self.AAGJLMHLJPK {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.passenger_card_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.BHKMEGPLPFA != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.BHKMEGPLPFA);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.DEABGMBGMPP != 0 {
            os.write_uint32(10, self.DEABGMBGMPP)?;
        }
        for v in &self.left_card_info_list {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if self.PCHFKBKLDMJ != 0 {
            os.write_uint32(8, self.PCHFKBKLDMJ)?;
        }
        if self.OADOFHHHOEJ != 0 {
            os.write_uint32(11, self.OADOFHHHOEJ)?;
        }
        if self.EKDNBEKFECL != 0 {
            os.write_uint32(7, self.EKDNBEKFECL)?;
        }
        for v in &self.AAGJLMHLJPK {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.passenger_card_list {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if self.BHKMEGPLPFA != 0 {
            os.write_uint32(5, self.BHKMEGPLPFA)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyMeetingData {
        TrainPartyMeetingData::new()
    }

    fn clear(&mut self) {
        self.DEABGMBGMPP = 0;
        self.left_card_info_list.clear();
        self.PCHFKBKLDMJ = 0;
        self.OADOFHHHOEJ = 0;
        self.EKDNBEKFECL = 0;
        self.AAGJLMHLJPK.clear();
        self.passenger_card_list.clear();
        self.BHKMEGPLPFA = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyMeetingData {
        static instance: TrainPartyMeetingData = TrainPartyMeetingData {
            DEABGMBGMPP: 0,
            left_card_info_list: ::std::vec::Vec::new(),
            PCHFKBKLDMJ: 0,
            OADOFHHHOEJ: 0,
            EKDNBEKFECL: 0,
            AAGJLMHLJPK: ::std::vec::Vec::new(),
            passenger_card_list: ::std::vec::Vec::new(),
            BHKMEGPLPFA: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyMeetingData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyMeetingData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyMeetingData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyMeetingData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PlaySkillBrief)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlaySkillBrief {
    // message fields
    // @@protoc_insertion_point(field:PlaySkillBrief.skill_type)
    pub skill_type: ::protobuf::EnumOrUnknown<TrainPartyMtSkillType>,
    // @@protoc_insertion_point(field:PlaySkillBrief.skill_id)
    pub skill_id: u32,
    // @@protoc_insertion_point(field:PlaySkillBrief.skill_param)
    pub skill_param: u32,
    // special fields
    // @@protoc_insertion_point(special_field:PlaySkillBrief.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlaySkillBrief {
    fn default() -> &'a PlaySkillBrief {
        <PlaySkillBrief as ::protobuf::Message>::default_instance()
    }
}

impl PlaySkillBrief {
    pub fn new() -> PlaySkillBrief {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "skill_type",
            |m: &PlaySkillBrief| { &m.skill_type },
            |m: &mut PlaySkillBrief| { &mut m.skill_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "skill_id",
            |m: &PlaySkillBrief| { &m.skill_id },
            |m: &mut PlaySkillBrief| { &mut m.skill_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "skill_param",
            |m: &PlaySkillBrief| { &m.skill_param },
            |m: &mut PlaySkillBrief| { &mut m.skill_param },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlaySkillBrief>(
            "PlaySkillBrief",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlaySkillBrief {
    const NAME: &'static str = "PlaySkillBrief";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                40 => {
                    self.skill_type = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.skill_id = is.read_uint32()?;
                },
                16 => {
                    self.skill_param = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.skill_type != ::protobuf::EnumOrUnknown::new(TrainPartyMtSkillType::kMtSkillNone) {
            my_size += ::protobuf::rt::int32_size(5, self.skill_type.value());
        }
        if self.skill_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.skill_id);
        }
        if self.skill_param != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.skill_param);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.skill_type != ::protobuf::EnumOrUnknown::new(TrainPartyMtSkillType::kMtSkillNone) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.skill_type))?;
        }
        if self.skill_id != 0 {
            os.write_uint32(4, self.skill_id)?;
        }
        if self.skill_param != 0 {
            os.write_uint32(2, self.skill_param)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlaySkillBrief {
        PlaySkillBrief::new()
    }

    fn clear(&mut self) {
        self.skill_type = ::protobuf::EnumOrUnknown::new(TrainPartyMtSkillType::kMtSkillNone);
        self.skill_id = 0;
        self.skill_param = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlaySkillBrief {
        static instance: PlaySkillBrief = PlaySkillBrief {
            skill_type: ::protobuf::EnumOrUnknown::from_i32(0),
            skill_id: 0,
            skill_param: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlaySkillBrief {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlaySkillBrief").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlaySkillBrief {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlaySkillBrief {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PlayCardBrief)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlayCardBrief {
    // message fields
    // @@protoc_insertion_point(field:PlayCardBrief.base_value)
    pub base_value: u32,
    // @@protoc_insertion_point(field:PlayCardBrief.unique_id)
    pub unique_id: u32,
    // @@protoc_insertion_point(field:PlayCardBrief.skill_brief_list)
    pub skill_brief_list: ::std::vec::Vec<super::PlaySkillBrief::PlaySkillBrief>,
    // special fields
    // @@protoc_insertion_point(special_field:PlayCardBrief.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlayCardBrief {
    fn default() -> &'a PlayCardBrief {
        <PlayCardBrief as ::protobuf::Message>::default_instance()
    }
}

impl PlayCardBrief {
    pub fn new() -> PlayCardBrief {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "base_value",
            |m: &PlayCardBrief| { &m.base_value },
            |m: &mut PlayCardBrief| { &mut m.base_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &PlayCardBrief| { &m.unique_id },
            |m: &mut PlayCardBrief| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "skill_brief_list",
            |m: &PlayCardBrief| { &m.skill_brief_list },
            |m: &mut PlayCardBrief| { &mut m.skill_brief_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayCardBrief>(
            "PlayCardBrief",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlayCardBrief {
    const NAME: &'static str = "PlayCardBrief";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.base_value = is.read_uint32()?;
                },
                80 => {
                    self.unique_id = is.read_uint32()?;
                },
                58 => {
                    self.skill_brief_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.base_value != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.base_value);
        }
        if self.unique_id != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.unique_id);
        }
        for value in &self.skill_brief_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.base_value != 0 {
            os.write_uint32(6, self.base_value)?;
        }
        if self.unique_id != 0 {
            os.write_uint32(10, self.unique_id)?;
        }
        for v in &self.skill_brief_list {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlayCardBrief {
        PlayCardBrief::new()
    }

    fn clear(&mut self) {
        self.base_value = 0;
        self.unique_id = 0;
        self.skill_brief_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlayCardBrief {
        static instance: PlayCardBrief = PlayCardBrief {
            base_value: 0,
            unique_id: 0,
            skill_brief_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlayCardBrief {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlayCardBrief").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlayCardBrief {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayCardBrief {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyMeetingSettleResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyMeetingSettleResult {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyMeetingSettleResult.JPCFLGNMCOL)
    pub JPCFLGNMCOL: ::protobuf::MessageField<super::ItemList::ItemList>,
    // @@protoc_insertion_point(field:TrainPartyMeetingSettleResult.OGEFFHHNMLE)
    pub OGEFFHHNMLE: u32,
    // @@protoc_insertion_point(field:TrainPartyMeetingSettleResult.JAMJNDMKMJI)
    pub JAMJNDMKMJI: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyMeetingSettleResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyMeetingSettleResult {
    fn default() -> &'a TrainPartyMeetingSettleResult {
        <TrainPartyMeetingSettleResult as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyMeetingSettleResult {
    pub fn new() -> TrainPartyMeetingSettleResult {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::ItemList::ItemList>(
            "JPCFLGNMCOL",
            |m: &TrainPartyMeetingSettleResult| { &m.JPCFLGNMCOL },
            |m: &mut TrainPartyMeetingSettleResult| { &mut m.JPCFLGNMCOL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OGEFFHHNMLE",
            |m: &TrainPartyMeetingSettleResult| { &m.OGEFFHHNMLE },
            |m: &mut TrainPartyMeetingSettleResult| { &mut m.OGEFFHHNMLE },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "JAMJNDMKMJI",
            |m: &TrainPartyMeetingSettleResult| { &m.JAMJNDMKMJI },
            |m: &mut TrainPartyMeetingSettleResult| { &mut m.JAMJNDMKMJI },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyMeetingSettleResult>(
            "TrainPartyMeetingSettleResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyMeetingSettleResult {
    const NAME: &'static str = "TrainPartyMeetingSettleResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.JPCFLGNMCOL)?;
                },
                64 => {
                    self.OGEFFHHNMLE = is.read_uint32()?;
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.JAMJNDMKMJI)?;
                },
                56 => {
                    self.JAMJNDMKMJI.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.JPCFLGNMCOL.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.OGEFFHHNMLE != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.OGEFFHHNMLE);
        }
        for value in &self.JAMJNDMKMJI {
            my_size += ::protobuf::rt::uint32_size(7, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.JPCFLGNMCOL.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if self.OGEFFHHNMLE != 0 {
            os.write_uint32(8, self.OGEFFHHNMLE)?;
        }
        for v in &self.JAMJNDMKMJI {
            os.write_uint32(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyMeetingSettleResult {
        TrainPartyMeetingSettleResult::new()
    }

    fn clear(&mut self) {
        self.JPCFLGNMCOL.clear();
        self.OGEFFHHNMLE = 0;
        self.JAMJNDMKMJI.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyMeetingSettleResult {
        static instance: TrainPartyMeetingSettleResult = TrainPartyMeetingSettleResult {
            JPCFLGNMCOL: ::protobuf::MessageField::none(),
            OGEFFHHNMLE: 0,
            JAMJNDMKMJI: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyMeetingSettleResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyMeetingSettleResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyMeetingSettleResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyMeetingSettleResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HPIPKEEKBDO)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HPIPKEEKBDO {
    // message fields
    // @@protoc_insertion_point(field:HPIPKEEKBDO.CAEFKFMHLEC)
    pub CAEFKFMHLEC: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:HPIPKEEKBDO.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HPIPKEEKBDO {
    fn default() -> &'a HPIPKEEKBDO {
        <HPIPKEEKBDO as ::protobuf::Message>::default_instance()
    }
}

impl HPIPKEEKBDO {
    pub fn new() -> HPIPKEEKBDO {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "CAEFKFMHLEC",
            |m: &HPIPKEEKBDO| { &m.CAEFKFMHLEC },
            |m: &mut HPIPKEEKBDO| { &mut m.CAEFKFMHLEC },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HPIPKEEKBDO>(
            "HPIPKEEKBDO",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HPIPKEEKBDO {
    const NAME: &'static str = "HPIPKEEKBDO";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.CAEFKFMHLEC)?;
                },
                8 => {
                    self.CAEFKFMHLEC.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.CAEFKFMHLEC {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.CAEFKFMHLEC {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HPIPKEEKBDO {
        HPIPKEEKBDO::new()
    }

    fn clear(&mut self) {
        self.CAEFKFMHLEC.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HPIPKEEKBDO {
        static instance: HPIPKEEKBDO = HPIPKEEKBDO {
            CAEFKFMHLEC: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HPIPKEEKBDO {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HPIPKEEKBDO").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HPIPKEEKBDO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HPIPKEEKBDO {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyMeetingUseCardInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyMeetingUseCardInfo {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyMeetingUseCardInfo.passenger_card_list)
    pub passenger_card_list: ::std::vec::Vec<TrainPartyMeetingPassengerCardInfo>,
    // @@protoc_insertion_point(field:TrainPartyMeetingUseCardInfo.PCHFKBKLDMJ)
    pub PCHFKBKLDMJ: u32,
    // @@protoc_insertion_point(field:TrainPartyMeetingUseCardInfo.left_card_info_list)
    pub left_card_info_list: ::std::vec::Vec<TrainPartyMeetingLeftCardInfo>,
    // @@protoc_insertion_point(field:TrainPartyMeetingUseCardInfo.score)
    pub score: u32,
    // @@protoc_insertion_point(field:TrainPartyMeetingUseCardInfo.PKCCIHJKJPM)
    pub PKCCIHJKJPM: ::std::vec::Vec<super::PlayCardBrief::PlayCardBrief>,
    // @@protoc_insertion_point(field:TrainPartyMeetingUseCardInfo.EKDNBEKFECL)
    pub EKDNBEKFECL: u32,
    // @@protoc_insertion_point(field:TrainPartyMeetingUseCardInfo.settle_result)
    pub settle_result: ::protobuf::MessageField<TrainPartyMeetingSettleResult>,
    // @@protoc_insertion_point(field:TrainPartyMeetingUseCardInfo.meeting_count_info)
    pub meeting_count_info: ::protobuf::MessageField<TrainPartyMeetingCountInfo>,
    // @@protoc_insertion_point(field:TrainPartyMeetingUseCardInfo.play_skill_brief_list)
    pub play_skill_brief_list: ::std::vec::Vec<super::PlaySkillBrief::PlaySkillBrief>,
    // @@protoc_insertion_point(field:TrainPartyMeetingUseCardInfo.meeting_category)
    pub meeting_category: ::protobuf::EnumOrUnknown<TrainPartyMtCategory>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyMeetingUseCardInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyMeetingUseCardInfo {
    fn default() -> &'a TrainPartyMeetingUseCardInfo {
        <TrainPartyMeetingUseCardInfo as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyMeetingUseCardInfo {
    pub fn new() -> TrainPartyMeetingUseCardInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "passenger_card_list",
            |m: &TrainPartyMeetingUseCardInfo| { &m.passenger_card_list },
            |m: &mut TrainPartyMeetingUseCardInfo| { &mut m.passenger_card_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PCHFKBKLDMJ",
            |m: &TrainPartyMeetingUseCardInfo| { &m.PCHFKBKLDMJ },
            |m: &mut TrainPartyMeetingUseCardInfo| { &mut m.PCHFKBKLDMJ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "left_card_info_list",
            |m: &TrainPartyMeetingUseCardInfo| { &m.left_card_info_list },
            |m: &mut TrainPartyMeetingUseCardInfo| { &mut m.left_card_info_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "score",
            |m: &TrainPartyMeetingUseCardInfo| { &m.score },
            |m: &mut TrainPartyMeetingUseCardInfo| { &mut m.score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "PKCCIHJKJPM",
            |m: &TrainPartyMeetingUseCardInfo| { &m.PKCCIHJKJPM },
            |m: &mut TrainPartyMeetingUseCardInfo| { &mut m.PKCCIHJKJPM },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "EKDNBEKFECL",
            |m: &TrainPartyMeetingUseCardInfo| { &m.EKDNBEKFECL },
            |m: &mut TrainPartyMeetingUseCardInfo| { &mut m.EKDNBEKFECL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyMeetingSettleResult>(
            "settle_result",
            |m: &TrainPartyMeetingUseCardInfo| { &m.settle_result },
            |m: &mut TrainPartyMeetingUseCardInfo| { &mut m.settle_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyMeetingCountInfo>(
            "meeting_count_info",
            |m: &TrainPartyMeetingUseCardInfo| { &m.meeting_count_info },
            |m: &mut TrainPartyMeetingUseCardInfo| { &mut m.meeting_count_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "play_skill_brief_list",
            |m: &TrainPartyMeetingUseCardInfo| { &m.play_skill_brief_list },
            |m: &mut TrainPartyMeetingUseCardInfo| { &mut m.play_skill_brief_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "meeting_category",
            |m: &TrainPartyMeetingUseCardInfo| { &m.meeting_category },
            |m: &mut TrainPartyMeetingUseCardInfo| { &mut m.meeting_category },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyMeetingUseCardInfo>(
            "TrainPartyMeetingUseCardInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyMeetingUseCardInfo {
    const NAME: &'static str = "TrainPartyMeetingUseCardInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    self.passenger_card_list.push(is.read_message()?);
                },
                112 => {
                    self.PCHFKBKLDMJ = is.read_uint32()?;
                },
                106 => {
                    self.left_card_info_list.push(is.read_message()?);
                },
                16 => {
                    self.score = is.read_uint32()?;
                },
                10 => {
                    self.PKCCIHJKJPM.push(is.read_message()?);
                },
                40 => {
                    self.EKDNBEKFECL = is.read_uint32()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.settle_result)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.meeting_count_info)?;
                },
                58 => {
                    self.play_skill_brief_list.push(is.read_message()?);
                },
                120 => {
                    self.meeting_category = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.passenger_card_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.PCHFKBKLDMJ != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.PCHFKBKLDMJ);
        }
        for value in &self.left_card_info_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.score != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.score);
        }
        for value in &self.PKCCIHJKJPM {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.EKDNBEKFECL != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.EKDNBEKFECL);
        }
        if let Some(v) = self.settle_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.meeting_count_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.play_skill_brief_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.meeting_category != ::protobuf::EnumOrUnknown::new(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(15, self.meeting_category.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.passenger_card_list {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if self.PCHFKBKLDMJ != 0 {
            os.write_uint32(14, self.PCHFKBKLDMJ)?;
        }
        for v in &self.left_card_info_list {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        if self.score != 0 {
            os.write_uint32(2, self.score)?;
        }
        for v in &self.PKCCIHJKJPM {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.EKDNBEKFECL != 0 {
            os.write_uint32(5, self.EKDNBEKFECL)?;
        }
        if let Some(v) = self.settle_result.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.meeting_count_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        for v in &self.play_skill_brief_list {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if self.meeting_category != ::protobuf::EnumOrUnknown::new(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_NONE) {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&self.meeting_category))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyMeetingUseCardInfo {
        TrainPartyMeetingUseCardInfo::new()
    }

    fn clear(&mut self) {
        self.passenger_card_list.clear();
        self.PCHFKBKLDMJ = 0;
        self.left_card_info_list.clear();
        self.score = 0;
        self.PKCCIHJKJPM.clear();
        self.EKDNBEKFECL = 0;
        self.settle_result.clear();
        self.meeting_count_info.clear();
        self.play_skill_brief_list.clear();
        self.meeting_category = ::protobuf::EnumOrUnknown::new(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyMeetingUseCardInfo {
        static instance: TrainPartyMeetingUseCardInfo = TrainPartyMeetingUseCardInfo {
            passenger_card_list: ::std::vec::Vec::new(),
            PCHFKBKLDMJ: 0,
            left_card_info_list: ::std::vec::Vec::new(),
            score: 0,
            PKCCIHJKJPM: ::std::vec::Vec::new(),
            EKDNBEKFECL: 0,
            settle_result: ::protobuf::MessageField::none(),
            meeting_count_info: ::protobuf::MessageField::none(),
            play_skill_brief_list: ::std::vec::Vec::new(),
            meeting_category: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyMeetingUseCardInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyMeetingUseCardInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyMeetingUseCardInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyMeetingUseCardInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:COAOOLIBOHF)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct COAOOLIBOHF {
    // message fields
    // @@protoc_insertion_point(field:COAOOLIBOHF.CAEFKFMHLEC)
    pub CAEFKFMHLEC: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:COAOOLIBOHF.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a COAOOLIBOHF {
    fn default() -> &'a COAOOLIBOHF {
        <COAOOLIBOHF as ::protobuf::Message>::default_instance()
    }
}

impl COAOOLIBOHF {
    pub fn new() -> COAOOLIBOHF {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "CAEFKFMHLEC",
            |m: &COAOOLIBOHF| { &m.CAEFKFMHLEC },
            |m: &mut COAOOLIBOHF| { &mut m.CAEFKFMHLEC },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<COAOOLIBOHF>(
            "COAOOLIBOHF",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for COAOOLIBOHF {
    const NAME: &'static str = "COAOOLIBOHF";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.CAEFKFMHLEC)?;
                },
                80 => {
                    self.CAEFKFMHLEC.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.CAEFKFMHLEC {
            my_size += ::protobuf::rt::uint32_size(10, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.CAEFKFMHLEC {
            os.write_uint32(10, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> COAOOLIBOHF {
        COAOOLIBOHF::new()
    }

    fn clear(&mut self) {
        self.CAEFKFMHLEC.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static COAOOLIBOHF {
        static instance: COAOOLIBOHF = COAOOLIBOHF {
            CAEFKFMHLEC: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for COAOOLIBOHF {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("COAOOLIBOHF").unwrap()).clone()
    }
}

impl ::std::fmt::Display for COAOOLIBOHF {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for COAOOLIBOHF {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyMeetingRollInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyMeetingRollInfo {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyMeetingRollInfo.passenger_card_list)
    pub passenger_card_list: ::std::vec::Vec<TrainPartyMeetingPassengerCardInfo>,
    // @@protoc_insertion_point(field:TrainPartyMeetingRollInfo.DEABGMBGMPP)
    pub DEABGMBGMPP: u32,
    // @@protoc_insertion_point(field:TrainPartyMeetingRollInfo.JLJIDMGPCFD)
    pub JLJIDMGPCFD: ::std::vec::Vec<super::PlaySkillBrief::PlaySkillBrief>,
    // @@protoc_insertion_point(field:TrainPartyMeetingRollInfo.left_card_info_list)
    pub left_card_info_list: ::std::vec::Vec<TrainPartyMeetingLeftCardInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyMeetingRollInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyMeetingRollInfo {
    fn default() -> &'a TrainPartyMeetingRollInfo {
        <TrainPartyMeetingRollInfo as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyMeetingRollInfo {
    pub fn new() -> TrainPartyMeetingRollInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "passenger_card_list",
            |m: &TrainPartyMeetingRollInfo| { &m.passenger_card_list },
            |m: &mut TrainPartyMeetingRollInfo| { &mut m.passenger_card_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DEABGMBGMPP",
            |m: &TrainPartyMeetingRollInfo| { &m.DEABGMBGMPP },
            |m: &mut TrainPartyMeetingRollInfo| { &mut m.DEABGMBGMPP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "JLJIDMGPCFD",
            |m: &TrainPartyMeetingRollInfo| { &m.JLJIDMGPCFD },
            |m: &mut TrainPartyMeetingRollInfo| { &mut m.JLJIDMGPCFD },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "left_card_info_list",
            |m: &TrainPartyMeetingRollInfo| { &m.left_card_info_list },
            |m: &mut TrainPartyMeetingRollInfo| { &mut m.left_card_info_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyMeetingRollInfo>(
            "TrainPartyMeetingRollInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyMeetingRollInfo {
    const NAME: &'static str = "TrainPartyMeetingRollInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    self.passenger_card_list.push(is.read_message()?);
                },
                40 => {
                    self.DEABGMBGMPP = is.read_uint32()?;
                },
                90 => {
                    self.JLJIDMGPCFD.push(is.read_message()?);
                },
                66 => {
                    self.left_card_info_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.passenger_card_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.DEABGMBGMPP != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.DEABGMBGMPP);
        }
        for value in &self.JLJIDMGPCFD {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.left_card_info_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.passenger_card_list {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if self.DEABGMBGMPP != 0 {
            os.write_uint32(5, self.DEABGMBGMPP)?;
        }
        for v in &self.JLJIDMGPCFD {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.left_card_info_list {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyMeetingRollInfo {
        TrainPartyMeetingRollInfo::new()
    }

    fn clear(&mut self) {
        self.passenger_card_list.clear();
        self.DEABGMBGMPP = 0;
        self.JLJIDMGPCFD.clear();
        self.left_card_info_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyMeetingRollInfo {
        static instance: TrainPartyMeetingRollInfo = TrainPartyMeetingRollInfo {
            passenger_card_list: ::std::vec::Vec::new(),
            DEABGMBGMPP: 0,
            JLJIDMGPCFD: ::std::vec::Vec::new(),
            left_card_info_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyMeetingRollInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyMeetingRollInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyMeetingRollInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyMeetingRollInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyHandlePendingActionCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyHandlePendingActionCsReq {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyHandlePendingActionCsReq.LMFHNELKFOC)
    pub LMFHNELKFOC: u32,
    // message oneof groups
    pub train_party_action: ::std::option::Option<train_party_handle_pending_action_cs_req::Train_party_action>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyHandlePendingActionCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyHandlePendingActionCsReq {
    fn default() -> &'a TrainPartyHandlePendingActionCsReq {
        <TrainPartyHandlePendingActionCsReq as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyHandlePendingActionCsReq {
    pub fn new() -> TrainPartyHandlePendingActionCsReq {
        ::std::default::Default::default()
    }

    // .NIBBILKHHHE GFLJGKBPCGB = 1763;

    pub fn GFLJGKBPCGB(&self) -> &super::NIBBILKHHHE::NIBBILKHHHE {
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::GFLJGKBPCGB(ref v)) => v,
            _ => <super::NIBBILKHHHE::NIBBILKHHHE as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_GFLJGKBPCGB(&mut self) {
        self.train_party_action = ::std::option::Option::None;
    }

    pub fn has_GFLJGKBPCGB(&self) -> bool {
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::GFLJGKBPCGB(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_GFLJGKBPCGB(&mut self, v: super::NIBBILKHHHE::NIBBILKHHHE) {
        self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::GFLJGKBPCGB(v))
    }

    // Mutable pointer to the field.
    pub fn mut_GFLJGKBPCGB(&mut self) -> &mut super::NIBBILKHHHE::NIBBILKHHHE {
        if let ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::GFLJGKBPCGB(_)) = self.train_party_action {
        } else {
            self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::GFLJGKBPCGB(super::NIBBILKHHHE::NIBBILKHHHE::new()));
        }
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::GFLJGKBPCGB(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_GFLJGKBPCGB(&mut self) -> super::NIBBILKHHHE::NIBBILKHHHE {
        if self.has_GFLJGKBPCGB() {
            match self.train_party_action.take() {
                ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::GFLJGKBPCGB(v)) => v,
                _ => panic!(),
            }
        } else {
            super::NIBBILKHHHE::NIBBILKHHHE::new()
        }
    }

    // .ICMFJIEIEBM EPPNHJCNFCI = 154;

    pub fn EPPNHJCNFCI(&self) -> &super::ICMFJIEIEBM::ICMFJIEIEBM {
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::EPPNHJCNFCI(ref v)) => v,
            _ => <super::ICMFJIEIEBM::ICMFJIEIEBM as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_EPPNHJCNFCI(&mut self) {
        self.train_party_action = ::std::option::Option::None;
    }

    pub fn has_EPPNHJCNFCI(&self) -> bool {
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::EPPNHJCNFCI(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_EPPNHJCNFCI(&mut self, v: super::ICMFJIEIEBM::ICMFJIEIEBM) {
        self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::EPPNHJCNFCI(v))
    }

    // Mutable pointer to the field.
    pub fn mut_EPPNHJCNFCI(&mut self) -> &mut super::ICMFJIEIEBM::ICMFJIEIEBM {
        if let ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::EPPNHJCNFCI(_)) = self.train_party_action {
        } else {
            self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::EPPNHJCNFCI(super::ICMFJIEIEBM::ICMFJIEIEBM::new()));
        }
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::EPPNHJCNFCI(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_EPPNHJCNFCI(&mut self) -> super::ICMFJIEIEBM::ICMFJIEIEBM {
        if self.has_EPPNHJCNFCI() {
            match self.train_party_action.take() {
                ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::EPPNHJCNFCI(v)) => v,
                _ => panic!(),
            }
        } else {
            super::ICMFJIEIEBM::ICMFJIEIEBM::new()
        }
    }

    // .HPIPKEEKBDO BMOCCJHIFAK = 656;

    pub fn BMOCCJHIFAK(&self) -> &super::HPIPKEEKBDO::HPIPKEEKBDO {
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::BMOCCJHIFAK(ref v)) => v,
            _ => <super::HPIPKEEKBDO::HPIPKEEKBDO as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_BMOCCJHIFAK(&mut self) {
        self.train_party_action = ::std::option::Option::None;
    }

    pub fn has_BMOCCJHIFAK(&self) -> bool {
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::BMOCCJHIFAK(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_BMOCCJHIFAK(&mut self, v: super::HPIPKEEKBDO::HPIPKEEKBDO) {
        self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::BMOCCJHIFAK(v))
    }

    // Mutable pointer to the field.
    pub fn mut_BMOCCJHIFAK(&mut self) -> &mut super::HPIPKEEKBDO::HPIPKEEKBDO {
        if let ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::BMOCCJHIFAK(_)) = self.train_party_action {
        } else {
            self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::BMOCCJHIFAK(super::HPIPKEEKBDO::HPIPKEEKBDO::new()));
        }
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::BMOCCJHIFAK(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_BMOCCJHIFAK(&mut self) -> super::HPIPKEEKBDO::HPIPKEEKBDO {
        if self.has_BMOCCJHIFAK() {
            match self.train_party_action.take() {
                ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::BMOCCJHIFAK(v)) => v,
                _ => panic!(),
            }
        } else {
            super::HPIPKEEKBDO::HPIPKEEKBDO::new()
        }
    }

    // .COAOOLIBOHF MGEKAIONENB = 366;

    pub fn MGEKAIONENB(&self) -> &super::COAOOLIBOHF::COAOOLIBOHF {
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::MGEKAIONENB(ref v)) => v,
            _ => <super::COAOOLIBOHF::COAOOLIBOHF as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_MGEKAIONENB(&mut self) {
        self.train_party_action = ::std::option::Option::None;
    }

    pub fn has_MGEKAIONENB(&self) -> bool {
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::MGEKAIONENB(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_MGEKAIONENB(&mut self, v: super::COAOOLIBOHF::COAOOLIBOHF) {
        self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::MGEKAIONENB(v))
    }

    // Mutable pointer to the field.
    pub fn mut_MGEKAIONENB(&mut self) -> &mut super::COAOOLIBOHF::COAOOLIBOHF {
        if let ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::MGEKAIONENB(_)) = self.train_party_action {
        } else {
            self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::MGEKAIONENB(super::COAOOLIBOHF::COAOOLIBOHF::new()));
        }
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::MGEKAIONENB(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_MGEKAIONENB(&mut self) -> super::COAOOLIBOHF::COAOOLIBOHF {
        if self.has_MGEKAIONENB() {
            match self.train_party_action.take() {
                ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::MGEKAIONENB(v)) => v,
                _ => panic!(),
            }
        } else {
            super::COAOOLIBOHF::COAOOLIBOHF::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::NIBBILKHHHE::NIBBILKHHHE>(
            "GFLJGKBPCGB",
            TrainPartyHandlePendingActionCsReq::has_GFLJGKBPCGB,
            TrainPartyHandlePendingActionCsReq::GFLJGKBPCGB,
            TrainPartyHandlePendingActionCsReq::mut_GFLJGKBPCGB,
            TrainPartyHandlePendingActionCsReq::set_GFLJGKBPCGB,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::ICMFJIEIEBM::ICMFJIEIEBM>(
            "EPPNHJCNFCI",
            TrainPartyHandlePendingActionCsReq::has_EPPNHJCNFCI,
            TrainPartyHandlePendingActionCsReq::EPPNHJCNFCI,
            TrainPartyHandlePendingActionCsReq::mut_EPPNHJCNFCI,
            TrainPartyHandlePendingActionCsReq::set_EPPNHJCNFCI,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::HPIPKEEKBDO::HPIPKEEKBDO>(
            "BMOCCJHIFAK",
            TrainPartyHandlePendingActionCsReq::has_BMOCCJHIFAK,
            TrainPartyHandlePendingActionCsReq::BMOCCJHIFAK,
            TrainPartyHandlePendingActionCsReq::mut_BMOCCJHIFAK,
            TrainPartyHandlePendingActionCsReq::set_BMOCCJHIFAK,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::COAOOLIBOHF::COAOOLIBOHF>(
            "MGEKAIONENB",
            TrainPartyHandlePendingActionCsReq::has_MGEKAIONENB,
            TrainPartyHandlePendingActionCsReq::MGEKAIONENB,
            TrainPartyHandlePendingActionCsReq::mut_MGEKAIONENB,
            TrainPartyHandlePendingActionCsReq::set_MGEKAIONENB,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LMFHNELKFOC",
            |m: &TrainPartyHandlePendingActionCsReq| { &m.LMFHNELKFOC },
            |m: &mut TrainPartyHandlePendingActionCsReq| { &mut m.LMFHNELKFOC },
        ));
        oneofs.push(train_party_handle_pending_action_cs_req::Train_party_action::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyHandlePendingActionCsReq>(
            "TrainPartyHandlePendingActionCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyHandlePendingActionCsReq {
    const NAME: &'static str = "TrainPartyHandlePendingActionCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                14106 => {
                    self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::GFLJGKBPCGB(is.read_message()?));
                },
                1234 => {
                    self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::EPPNHJCNFCI(is.read_message()?));
                },
                5250 => {
                    self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::BMOCCJHIFAK(is.read_message()?));
                },
                2930 => {
                    self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_cs_req::Train_party_action::MGEKAIONENB(is.read_message()?));
                },
                56 => {
                    self.LMFHNELKFOC = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.LMFHNELKFOC != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.LMFHNELKFOC);
        }
        if let ::std::option::Option::Some(ref v) = self.train_party_action {
            match v {
                &train_party_handle_pending_action_cs_req::Train_party_action::GFLJGKBPCGB(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &train_party_handle_pending_action_cs_req::Train_party_action::EPPNHJCNFCI(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &train_party_handle_pending_action_cs_req::Train_party_action::BMOCCJHIFAK(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &train_party_handle_pending_action_cs_req::Train_party_action::MGEKAIONENB(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.LMFHNELKFOC != 0 {
            os.write_uint32(7, self.LMFHNELKFOC)?;
        }
        if let ::std::option::Option::Some(ref v) = self.train_party_action {
            match v {
                &train_party_handle_pending_action_cs_req::Train_party_action::GFLJGKBPCGB(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1763, v, os)?;
                },
                &train_party_handle_pending_action_cs_req::Train_party_action::EPPNHJCNFCI(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(154, v, os)?;
                },
                &train_party_handle_pending_action_cs_req::Train_party_action::BMOCCJHIFAK(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(656, v, os)?;
                },
                &train_party_handle_pending_action_cs_req::Train_party_action::MGEKAIONENB(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(366, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyHandlePendingActionCsReq {
        TrainPartyHandlePendingActionCsReq::new()
    }

    fn clear(&mut self) {
        self.train_party_action = ::std::option::Option::None;
        self.train_party_action = ::std::option::Option::None;
        self.train_party_action = ::std::option::Option::None;
        self.train_party_action = ::std::option::Option::None;
        self.LMFHNELKFOC = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyHandlePendingActionCsReq {
        static instance: TrainPartyHandlePendingActionCsReq = TrainPartyHandlePendingActionCsReq {
            LMFHNELKFOC: 0,
            train_party_action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyHandlePendingActionCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyHandlePendingActionCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyHandlePendingActionCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyHandlePendingActionCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TrainPartyHandlePendingActionCsReq`
pub mod train_party_handle_pending_action_cs_req {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:TrainPartyHandlePendingActionCsReq.train_party_action)
    pub enum Train_party_action {
        // @@protoc_insertion_point(oneof_field:TrainPartyHandlePendingActionCsReq.GFLJGKBPCGB)
        GFLJGKBPCGB(super::super::NIBBILKHHHE::NIBBILKHHHE),
        // @@protoc_insertion_point(oneof_field:TrainPartyHandlePendingActionCsReq.EPPNHJCNFCI)
        EPPNHJCNFCI(super::super::ICMFJIEIEBM::ICMFJIEIEBM),
        // @@protoc_insertion_point(oneof_field:TrainPartyHandlePendingActionCsReq.BMOCCJHIFAK)
        BMOCCJHIFAK(super::super::HPIPKEEKBDO::HPIPKEEKBDO),
        // @@protoc_insertion_point(oneof_field:TrainPartyHandlePendingActionCsReq.MGEKAIONENB)
        MGEKAIONENB(super::super::COAOOLIBOHF::COAOOLIBOHF),
    }

    impl ::protobuf::Oneof for Train_party_action {
    }

    impl ::protobuf::OneofFull for Train_party_action {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TrainPartyHandlePendingActionCsReq as ::protobuf::MessageFull>::descriptor().oneof_by_name("train_party_action").unwrap()).clone()
        }
    }

    impl Train_party_action {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Train_party_action>("train_party_action")
        }
    }
}

// @@protoc_insertion_point(message:TrainPartyHandlePendingActionScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyHandlePendingActionScRsp {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyHandlePendingActionScRsp.LFJLHJHPLGI)
    pub LFJLHJHPLGI: bool,
    // @@protoc_insertion_point(field:TrainPartyHandlePendingActionScRsp.train_party_settle_data)
    pub train_party_settle_data: ::protobuf::MessageField<TrainPartySettleData>,
    // @@protoc_insertion_point(field:TrainPartyHandlePendingActionScRsp.LMFHNELKFOC)
    pub LMFHNELKFOC: u32,
    // @@protoc_insertion_point(field:TrainPartyHandlePendingActionScRsp.retcode)
    pub retcode: u32,
    // message oneof groups
    pub train_party_action: ::std::option::Option<train_party_handle_pending_action_sc_rsp::Train_party_action>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyHandlePendingActionScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyHandlePendingActionScRsp {
    fn default() -> &'a TrainPartyHandlePendingActionScRsp {
        <TrainPartyHandlePendingActionScRsp as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyHandlePendingActionScRsp {
    pub fn new() -> TrainPartyHandlePendingActionScRsp {
        ::std::default::Default::default()
    }

    // .TrainPartyReplaceSkillActionResult replace_skill_action = 1506;

    pub fn replace_skill_action(&self) -> &TrainPartyReplaceSkillActionResult {
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::ReplaceSkillAction(ref v)) => v,
            _ => <TrainPartyReplaceSkillActionResult as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_replace_skill_action(&mut self) {
        self.train_party_action = ::std::option::Option::None;
    }

    pub fn has_replace_skill_action(&self) -> bool {
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::ReplaceSkillAction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_replace_skill_action(&mut self, v: TrainPartyReplaceSkillActionResult) {
        self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::ReplaceSkillAction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_replace_skill_action(&mut self) -> &mut TrainPartyReplaceSkillActionResult {
        if let ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::ReplaceSkillAction(_)) = self.train_party_action {
        } else {
            self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::ReplaceSkillAction(TrainPartyReplaceSkillActionResult::new()));
        }
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::ReplaceSkillAction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_replace_skill_action(&mut self) -> TrainPartyReplaceSkillActionResult {
        if self.has_replace_skill_action() {
            match self.train_party_action.take() {
                ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::ReplaceSkillAction(v)) => v,
                _ => panic!(),
            }
        } else {
            TrainPartyReplaceSkillActionResult::new()
        }
    }

    // .TrainPartyMeetingUseCardInfo use_card_action = 69;

    pub fn use_card_action(&self) -> &TrainPartyMeetingUseCardInfo {
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::UseCardAction(ref v)) => v,
            _ => <TrainPartyMeetingUseCardInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_use_card_action(&mut self) {
        self.train_party_action = ::std::option::Option::None;
    }

    pub fn has_use_card_action(&self) -> bool {
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::UseCardAction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_use_card_action(&mut self, v: TrainPartyMeetingUseCardInfo) {
        self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::UseCardAction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_use_card_action(&mut self) -> &mut TrainPartyMeetingUseCardInfo {
        if let ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::UseCardAction(_)) = self.train_party_action {
        } else {
            self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::UseCardAction(TrainPartyMeetingUseCardInfo::new()));
        }
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::UseCardAction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_use_card_action(&mut self) -> TrainPartyMeetingUseCardInfo {
        if self.has_use_card_action() {
            match self.train_party_action.take() {
                ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::UseCardAction(v)) => v,
                _ => panic!(),
            }
        } else {
            TrainPartyMeetingUseCardInfo::new()
        }
    }

    // .TrainPartyMeetingRollInfo roll_action = 366;

    pub fn roll_action(&self) -> &TrainPartyMeetingRollInfo {
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::RollAction(ref v)) => v,
            _ => <TrainPartyMeetingRollInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_roll_action(&mut self) {
        self.train_party_action = ::std::option::Option::None;
    }

    pub fn has_roll_action(&self) -> bool {
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::RollAction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_roll_action(&mut self, v: TrainPartyMeetingRollInfo) {
        self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::RollAction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_roll_action(&mut self) -> &mut TrainPartyMeetingRollInfo {
        if let ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::RollAction(_)) = self.train_party_action {
        } else {
            self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::RollAction(TrainPartyMeetingRollInfo::new()));
        }
        match self.train_party_action {
            ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::RollAction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_roll_action(&mut self) -> TrainPartyMeetingRollInfo {
        if self.has_roll_action() {
            match self.train_party_action.take() {
                ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::RollAction(v)) => v,
                _ => panic!(),
            }
        } else {
            TrainPartyMeetingRollInfo::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TrainPartyReplaceSkillActionResult>(
            "replace_skill_action",
            TrainPartyHandlePendingActionScRsp::has_replace_skill_action,
            TrainPartyHandlePendingActionScRsp::replace_skill_action,
            TrainPartyHandlePendingActionScRsp::mut_replace_skill_action,
            TrainPartyHandlePendingActionScRsp::set_replace_skill_action,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TrainPartyMeetingUseCardInfo>(
            "use_card_action",
            TrainPartyHandlePendingActionScRsp::has_use_card_action,
            TrainPartyHandlePendingActionScRsp::use_card_action,
            TrainPartyHandlePendingActionScRsp::mut_use_card_action,
            TrainPartyHandlePendingActionScRsp::set_use_card_action,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TrainPartyMeetingRollInfo>(
            "roll_action",
            TrainPartyHandlePendingActionScRsp::has_roll_action,
            TrainPartyHandlePendingActionScRsp::roll_action,
            TrainPartyHandlePendingActionScRsp::mut_roll_action,
            TrainPartyHandlePendingActionScRsp::set_roll_action,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LFJLHJHPLGI",
            |m: &TrainPartyHandlePendingActionScRsp| { &m.LFJLHJHPLGI },
            |m: &mut TrainPartyHandlePendingActionScRsp| { &mut m.LFJLHJHPLGI },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartySettleData>(
            "train_party_settle_data",
            |m: &TrainPartyHandlePendingActionScRsp| { &m.train_party_settle_data },
            |m: &mut TrainPartyHandlePendingActionScRsp| { &mut m.train_party_settle_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LMFHNELKFOC",
            |m: &TrainPartyHandlePendingActionScRsp| { &m.LMFHNELKFOC },
            |m: &mut TrainPartyHandlePendingActionScRsp| { &mut m.LMFHNELKFOC },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &TrainPartyHandlePendingActionScRsp| { &m.retcode },
            |m: &mut TrainPartyHandlePendingActionScRsp| { &mut m.retcode },
        ));
        oneofs.push(train_party_handle_pending_action_sc_rsp::Train_party_action::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyHandlePendingActionScRsp>(
            "TrainPartyHandlePendingActionScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyHandlePendingActionScRsp {
    const NAME: &'static str = "TrainPartyHandlePendingActionScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                12050 => {
                    self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::ReplaceSkillAction(is.read_message()?));
                },
                554 => {
                    self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::UseCardAction(is.read_message()?));
                },
                2930 => {
                    self.train_party_action = ::std::option::Option::Some(train_party_handle_pending_action_sc_rsp::Train_party_action::RollAction(is.read_message()?));
                },
                24 => {
                    self.LFJLHJHPLGI = is.read_bool()?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.train_party_settle_data)?;
                },
                32 => {
                    self.LMFHNELKFOC = is.read_uint32()?;
                },
                48 => {
                    self.retcode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.LFJLHJHPLGI != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.train_party_settle_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.LMFHNELKFOC != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.LMFHNELKFOC);
        }
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.retcode);
        }
        if let ::std::option::Option::Some(ref v) = self.train_party_action {
            match v {
                &train_party_handle_pending_action_sc_rsp::Train_party_action::ReplaceSkillAction(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &train_party_handle_pending_action_sc_rsp::Train_party_action::UseCardAction(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &train_party_handle_pending_action_sc_rsp::Train_party_action::RollAction(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.LFJLHJHPLGI != false {
            os.write_bool(3, self.LFJLHJHPLGI)?;
        }
        if let Some(v) = self.train_party_settle_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if self.LMFHNELKFOC != 0 {
            os.write_uint32(4, self.LMFHNELKFOC)?;
        }
        if self.retcode != 0 {
            os.write_uint32(6, self.retcode)?;
        }
        if let ::std::option::Option::Some(ref v) = self.train_party_action {
            match v {
                &train_party_handle_pending_action_sc_rsp::Train_party_action::ReplaceSkillAction(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1506, v, os)?;
                },
                &train_party_handle_pending_action_sc_rsp::Train_party_action::UseCardAction(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(69, v, os)?;
                },
                &train_party_handle_pending_action_sc_rsp::Train_party_action::RollAction(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(366, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyHandlePendingActionScRsp {
        TrainPartyHandlePendingActionScRsp::new()
    }

    fn clear(&mut self) {
        self.train_party_action = ::std::option::Option::None;
        self.train_party_action = ::std::option::Option::None;
        self.train_party_action = ::std::option::Option::None;
        self.LFJLHJHPLGI = false;
        self.train_party_settle_data.clear();
        self.LMFHNELKFOC = 0;
        self.retcode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyHandlePendingActionScRsp {
        static instance: TrainPartyHandlePendingActionScRsp = TrainPartyHandlePendingActionScRsp {
            LFJLHJHPLGI: false,
            train_party_settle_data: ::protobuf::MessageField::none(),
            LMFHNELKFOC: 0,
            retcode: 0,
            train_party_action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyHandlePendingActionScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyHandlePendingActionScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyHandlePendingActionScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyHandlePendingActionScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TrainPartyHandlePendingActionScRsp`
pub mod train_party_handle_pending_action_sc_rsp {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:TrainPartyHandlePendingActionScRsp.train_party_action)
    pub enum Train_party_action {
        // @@protoc_insertion_point(oneof_field:TrainPartyHandlePendingActionScRsp.replace_skill_action)
        ReplaceSkillAction(super::TrainPartyReplaceSkillActionResult),
        // @@protoc_insertion_point(oneof_field:TrainPartyHandlePendingActionScRsp.use_card_action)
        UseCardAction(super::TrainPartyMeetingUseCardInfo),
        // @@protoc_insertion_point(oneof_field:TrainPartyHandlePendingActionScRsp.roll_action)
        RollAction(super::TrainPartyMeetingRollInfo),
    }

    impl ::protobuf::Oneof for Train_party_action {
    }

    impl ::protobuf::OneofFull for Train_party_action {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TrainPartyHandlePendingActionScRsp as ::protobuf::MessageFull>::descriptor().oneof_by_name("train_party_action").unwrap()).clone()
        }
    }

    impl Train_party_action {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Train_party_action>("train_party_action")
        }
    }
}

// @@protoc_insertion_point(message:TrainPartyBuildStartStepCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyBuildStartStepCsReq {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyBuildStartStepCsReq.area_id)
    pub area_id: u32,
    // @@protoc_insertion_point(field:TrainPartyBuildStartStepCsReq.build_slot_info)
    pub build_slot_info: ::protobuf::MessageField<TrainPartyBuildSlotInfo>,
    // @@protoc_insertion_point(field:TrainPartyBuildStartStepCsReq.step_id)
    pub step_id: u32,
    // @@protoc_insertion_point(field:TrainPartyBuildStartStepCsReq.goal_id)
    pub goal_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyBuildStartStepCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyBuildStartStepCsReq {
    fn default() -> &'a TrainPartyBuildStartStepCsReq {
        <TrainPartyBuildStartStepCsReq as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyBuildStartStepCsReq {
    pub fn new() -> TrainPartyBuildStartStepCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "area_id",
            |m: &TrainPartyBuildStartStepCsReq| { &m.area_id },
            |m: &mut TrainPartyBuildStartStepCsReq| { &mut m.area_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyBuildSlotInfo>(
            "build_slot_info",
            |m: &TrainPartyBuildStartStepCsReq| { &m.build_slot_info },
            |m: &mut TrainPartyBuildStartStepCsReq| { &mut m.build_slot_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "step_id",
            |m: &TrainPartyBuildStartStepCsReq| { &m.step_id },
            |m: &mut TrainPartyBuildStartStepCsReq| { &mut m.step_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "goal_id",
            |m: &TrainPartyBuildStartStepCsReq| { &m.goal_id },
            |m: &mut TrainPartyBuildStartStepCsReq| { &mut m.goal_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyBuildStartStepCsReq>(
            "TrainPartyBuildStartStepCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyBuildStartStepCsReq {
    const NAME: &'static str = "TrainPartyBuildStartStepCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.area_id = is.read_uint32()?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.build_slot_info)?;
                },
                112 => {
                    self.step_id = is.read_uint32()?;
                },
                64 => {
                    self.goal_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.area_id != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.area_id);
        }
        if let Some(v) = self.build_slot_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.step_id != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.step_id);
        }
        if self.goal_id != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.goal_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.area_id != 0 {
            os.write_uint32(10, self.area_id)?;
        }
        if let Some(v) = self.build_slot_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if self.step_id != 0 {
            os.write_uint32(14, self.step_id)?;
        }
        if self.goal_id != 0 {
            os.write_uint32(8, self.goal_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyBuildStartStepCsReq {
        TrainPartyBuildStartStepCsReq::new()
    }

    fn clear(&mut self) {
        self.area_id = 0;
        self.build_slot_info.clear();
        self.step_id = 0;
        self.goal_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyBuildStartStepCsReq {
        static instance: TrainPartyBuildStartStepCsReq = TrainPartyBuildStartStepCsReq {
            area_id: 0,
            build_slot_info: ::protobuf::MessageField::none(),
            step_id: 0,
            goal_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyBuildStartStepCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyBuildStartStepCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyBuildStartStepCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyBuildStartStepCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyBuildStartStepScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyBuildStartStepScRsp {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyBuildStartStepScRsp.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:TrainPartyBuildStartStepScRsp.funds)
    pub funds: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyBuildStartStepScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyBuildStartStepScRsp {
    fn default() -> &'a TrainPartyBuildStartStepScRsp {
        <TrainPartyBuildStartStepScRsp as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyBuildStartStepScRsp {
    pub fn new() -> TrainPartyBuildStartStepScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &TrainPartyBuildStartStepScRsp| { &m.retcode },
            |m: &mut TrainPartyBuildStartStepScRsp| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "funds",
            |m: &TrainPartyBuildStartStepScRsp| { &m.funds },
            |m: &mut TrainPartyBuildStartStepScRsp| { &mut m.funds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyBuildStartStepScRsp>(
            "TrainPartyBuildStartStepScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyBuildStartStepScRsp {
    const NAME: &'static str = "TrainPartyBuildStartStepScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                72 => {
                    self.retcode = is.read_uint32()?;
                },
                16 => {
                    self.funds = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.retcode);
        }
        if self.funds != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.funds);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(9, self.retcode)?;
        }
        if self.funds != 0 {
            os.write_uint32(2, self.funds)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyBuildStartStepScRsp {
        TrainPartyBuildStartStepScRsp::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.funds = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyBuildStartStepScRsp {
        static instance: TrainPartyBuildStartStepScRsp = TrainPartyBuildStartStepScRsp {
            retcode: 0,
            funds: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyBuildStartStepScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyBuildStartStepScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyBuildStartStepScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyBuildStartStepScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyBuildDiyCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyBuildDiyCsReq {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyBuildDiyCsReq.area_id)
    pub area_id: u32,
    // @@protoc_insertion_point(field:TrainPartyBuildDiyCsReq.dynamic_prop_id)
    pub dynamic_prop_id: u32,
    // @@protoc_insertion_point(field:TrainPartyBuildDiyCsReq.slot_id)
    pub slot_id: u32,
    // @@protoc_insertion_point(field:TrainPartyBuildDiyCsReq.HEMODCFENHP)
    pub HEMODCFENHP: bool,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyBuildDiyCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyBuildDiyCsReq {
    fn default() -> &'a TrainPartyBuildDiyCsReq {
        <TrainPartyBuildDiyCsReq as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyBuildDiyCsReq {
    pub fn new() -> TrainPartyBuildDiyCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "area_id",
            |m: &TrainPartyBuildDiyCsReq| { &m.area_id },
            |m: &mut TrainPartyBuildDiyCsReq| { &mut m.area_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dynamic_prop_id",
            |m: &TrainPartyBuildDiyCsReq| { &m.dynamic_prop_id },
            |m: &mut TrainPartyBuildDiyCsReq| { &mut m.dynamic_prop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot_id",
            |m: &TrainPartyBuildDiyCsReq| { &m.slot_id },
            |m: &mut TrainPartyBuildDiyCsReq| { &mut m.slot_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "HEMODCFENHP",
            |m: &TrainPartyBuildDiyCsReq| { &m.HEMODCFENHP },
            |m: &mut TrainPartyBuildDiyCsReq| { &mut m.HEMODCFENHP },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyBuildDiyCsReq>(
            "TrainPartyBuildDiyCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyBuildDiyCsReq {
    const NAME: &'static str = "TrainPartyBuildDiyCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.area_id = is.read_uint32()?;
                },
                32 => {
                    self.dynamic_prop_id = is.read_uint32()?;
                },
                112 => {
                    self.slot_id = is.read_uint32()?;
                },
                64 => {
                    self.HEMODCFENHP = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.area_id != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.area_id);
        }
        if self.dynamic_prop_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.dynamic_prop_id);
        }
        if self.slot_id != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.slot_id);
        }
        if self.HEMODCFENHP != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.area_id != 0 {
            os.write_uint32(10, self.area_id)?;
        }
        if self.dynamic_prop_id != 0 {
            os.write_uint32(4, self.dynamic_prop_id)?;
        }
        if self.slot_id != 0 {
            os.write_uint32(14, self.slot_id)?;
        }
        if self.HEMODCFENHP != false {
            os.write_bool(8, self.HEMODCFENHP)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyBuildDiyCsReq {
        TrainPartyBuildDiyCsReq::new()
    }

    fn clear(&mut self) {
        self.area_id = 0;
        self.dynamic_prop_id = 0;
        self.slot_id = 0;
        self.HEMODCFENHP = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyBuildDiyCsReq {
        static instance: TrainPartyBuildDiyCsReq = TrainPartyBuildDiyCsReq {
            area_id: 0,
            dynamic_prop_id: 0,
            slot_id: 0,
            HEMODCFENHP: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyBuildDiyCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyBuildDiyCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyBuildDiyCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyBuildDiyCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyBuildDiyScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyBuildDiyScRsp {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyBuildDiyScRsp.HEMODCFENHP)
    pub HEMODCFENHP: bool,
    // @@protoc_insertion_point(field:TrainPartyBuildDiyScRsp.build_slot_list)
    pub build_slot_list: ::std::vec::Vec<TrainPartyBuildSlotInfo>,
    // @@protoc_insertion_point(field:TrainPartyBuildDiyScRsp.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:TrainPartyBuildDiyScRsp.area_id)
    pub area_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyBuildDiyScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyBuildDiyScRsp {
    fn default() -> &'a TrainPartyBuildDiyScRsp {
        <TrainPartyBuildDiyScRsp as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyBuildDiyScRsp {
    pub fn new() -> TrainPartyBuildDiyScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "HEMODCFENHP",
            |m: &TrainPartyBuildDiyScRsp| { &m.HEMODCFENHP },
            |m: &mut TrainPartyBuildDiyScRsp| { &mut m.HEMODCFENHP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "build_slot_list",
            |m: &TrainPartyBuildDiyScRsp| { &m.build_slot_list },
            |m: &mut TrainPartyBuildDiyScRsp| { &mut m.build_slot_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &TrainPartyBuildDiyScRsp| { &m.retcode },
            |m: &mut TrainPartyBuildDiyScRsp| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "area_id",
            |m: &TrainPartyBuildDiyScRsp| { &m.area_id },
            |m: &mut TrainPartyBuildDiyScRsp| { &mut m.area_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyBuildDiyScRsp>(
            "TrainPartyBuildDiyScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyBuildDiyScRsp {
    const NAME: &'static str = "TrainPartyBuildDiyScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                88 => {
                    self.HEMODCFENHP = is.read_bool()?;
                },
                74 => {
                    self.build_slot_list.push(is.read_message()?);
                },
                16 => {
                    self.retcode = is.read_uint32()?;
                },
                56 => {
                    self.area_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.HEMODCFENHP != false {
            my_size += 1 + 1;
        }
        for value in &self.build_slot_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.retcode);
        }
        if self.area_id != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.area_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.HEMODCFENHP != false {
            os.write_bool(11, self.HEMODCFENHP)?;
        }
        for v in &self.build_slot_list {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if self.retcode != 0 {
            os.write_uint32(2, self.retcode)?;
        }
        if self.area_id != 0 {
            os.write_uint32(7, self.area_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyBuildDiyScRsp {
        TrainPartyBuildDiyScRsp::new()
    }

    fn clear(&mut self) {
        self.HEMODCFENHP = false;
        self.build_slot_list.clear();
        self.retcode = 0;
        self.area_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyBuildDiyScRsp {
        static instance: TrainPartyBuildDiyScRsp = TrainPartyBuildDiyScRsp {
            HEMODCFENHP: false,
            build_slot_list: ::std::vec::Vec::new(),
            retcode: 0,
            area_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyBuildDiyScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyBuildDiyScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyBuildDiyScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyBuildDiyScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BFIHFFONJIH)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BFIHFFONJIH {
    // message fields
    // @@protoc_insertion_point(field:BFIHFFONJIH.FBBNKCFEIIC)
    pub FBBNKCFEIIC: u32,
    // @@protoc_insertion_point(field:BFIHFFONJIH.build_step_list)
    pub build_step_list: ::std::vec::Vec<TrainPartyBuildStepInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:BFIHFFONJIH.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BFIHFFONJIH {
    fn default() -> &'a BFIHFFONJIH {
        <BFIHFFONJIH as ::protobuf::Message>::default_instance()
    }
}

impl BFIHFFONJIH {
    pub fn new() -> BFIHFFONJIH {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "FBBNKCFEIIC",
            |m: &BFIHFFONJIH| { &m.FBBNKCFEIIC },
            |m: &mut BFIHFFONJIH| { &mut m.FBBNKCFEIIC },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "build_step_list",
            |m: &BFIHFFONJIH| { &m.build_step_list },
            |m: &mut BFIHFFONJIH| { &mut m.build_step_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BFIHFFONJIH>(
            "BFIHFFONJIH",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BFIHFFONJIH {
    const NAME: &'static str = "BFIHFFONJIH";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.FBBNKCFEIIC = is.read_uint32()?;
                },
                50 => {
                    self.build_step_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.FBBNKCFEIIC != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.FBBNKCFEIIC);
        }
        for value in &self.build_step_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.FBBNKCFEIIC != 0 {
            os.write_uint32(4, self.FBBNKCFEIIC)?;
        }
        for v in &self.build_step_list {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BFIHFFONJIH {
        BFIHFFONJIH::new()
    }

    fn clear(&mut self) {
        self.FBBNKCFEIIC = 0;
        self.build_step_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BFIHFFONJIH {
        static instance: BFIHFFONJIH = BFIHFFONJIH {
            FBBNKCFEIIC: 0,
            build_step_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BFIHFFONJIH {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BFIHFFONJIH").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BFIHFFONJIH {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BFIHFFONJIH {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HHCFGIJPHLC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HHCFGIJPHLC {
    // message fields
    // @@protoc_insertion_point(field:HHCFGIJPHLC.progress)
    pub progress: u32,
    // @@protoc_insertion_point(field:HHCFGIJPHLC.build_step_list)
    pub build_step_list: ::std::vec::Vec<TrainPartyBuildStepInfo>,
    // @@protoc_insertion_point(field:HHCFGIJPHLC.goal_id)
    pub goal_id: u32,
    // @@protoc_insertion_point(field:HHCFGIJPHLC.area_id)
    pub area_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:HHCFGIJPHLC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HHCFGIJPHLC {
    fn default() -> &'a HHCFGIJPHLC {
        <HHCFGIJPHLC as ::protobuf::Message>::default_instance()
    }
}

impl HHCFGIJPHLC {
    pub fn new() -> HHCFGIJPHLC {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "progress",
            |m: &HHCFGIJPHLC| { &m.progress },
            |m: &mut HHCFGIJPHLC| { &mut m.progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "build_step_list",
            |m: &HHCFGIJPHLC| { &m.build_step_list },
            |m: &mut HHCFGIJPHLC| { &mut m.build_step_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "goal_id",
            |m: &HHCFGIJPHLC| { &m.goal_id },
            |m: &mut HHCFGIJPHLC| { &mut m.goal_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "area_id",
            |m: &HHCFGIJPHLC| { &m.area_id },
            |m: &mut HHCFGIJPHLC| { &mut m.area_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HHCFGIJPHLC>(
            "HHCFGIJPHLC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HHCFGIJPHLC {
    const NAME: &'static str = "HHCFGIJPHLC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.progress = is.read_uint32()?;
                },
                74 => {
                    self.build_step_list.push(is.read_message()?);
                },
                104 => {
                    self.goal_id = is.read_uint32()?;
                },
                120 => {
                    self.area_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.progress != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.progress);
        }
        for value in &self.build_step_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.goal_id != 0 {
            my_size += ::protobuf::rt::uint32_size(13, self.goal_id);
        }
        if self.area_id != 0 {
            my_size += ::protobuf::rt::uint32_size(15, self.area_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.progress != 0 {
            os.write_uint32(3, self.progress)?;
        }
        for v in &self.build_step_list {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if self.goal_id != 0 {
            os.write_uint32(13, self.goal_id)?;
        }
        if self.area_id != 0 {
            os.write_uint32(15, self.area_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HHCFGIJPHLC {
        HHCFGIJPHLC::new()
    }

    fn clear(&mut self) {
        self.progress = 0;
        self.build_step_list.clear();
        self.goal_id = 0;
        self.area_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HHCFGIJPHLC {
        static instance: HHCFGIJPHLC = HHCFGIJPHLC {
            progress: 0,
            build_step_list: ::std::vec::Vec::new(),
            goal_id: 0,
            area_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HHCFGIJPHLC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HHCFGIJPHLC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HHCFGIJPHLC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HHCFGIJPHLC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NKFHBMJAOBM)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NKFHBMJAOBM {
    // message fields
    // @@protoc_insertion_point(field:NKFHBMJAOBM.CFJKBJHNIJM)
    pub CFJKBJHNIJM: u32,
    // @@protoc_insertion_point(field:NKFHBMJAOBM.build_level)
    pub build_level: u32,
    // special fields
    // @@protoc_insertion_point(special_field:NKFHBMJAOBM.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NKFHBMJAOBM {
    fn default() -> &'a NKFHBMJAOBM {
        <NKFHBMJAOBM as ::protobuf::Message>::default_instance()
    }
}

impl NKFHBMJAOBM {
    pub fn new() -> NKFHBMJAOBM {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CFJKBJHNIJM",
            |m: &NKFHBMJAOBM| { &m.CFJKBJHNIJM },
            |m: &mut NKFHBMJAOBM| { &mut m.CFJKBJHNIJM },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "build_level",
            |m: &NKFHBMJAOBM| { &m.build_level },
            |m: &mut NKFHBMJAOBM| { &mut m.build_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NKFHBMJAOBM>(
            "NKFHBMJAOBM",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NKFHBMJAOBM {
    const NAME: &'static str = "NKFHBMJAOBM";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.CFJKBJHNIJM = is.read_uint32()?;
                },
                72 => {
                    self.build_level = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.CFJKBJHNIJM != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.CFJKBJHNIJM);
        }
        if self.build_level != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.build_level);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.CFJKBJHNIJM != 0 {
            os.write_uint32(3, self.CFJKBJHNIJM)?;
        }
        if self.build_level != 0 {
            os.write_uint32(9, self.build_level)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NKFHBMJAOBM {
        NKFHBMJAOBM::new()
    }

    fn clear(&mut self) {
        self.CFJKBJHNIJM = 0;
        self.build_level = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NKFHBMJAOBM {
        static instance: NKFHBMJAOBM = NKFHBMJAOBM {
            CFJKBJHNIJM: 0,
            build_level: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NKFHBMJAOBM {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NKFHBMJAOBM").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NKFHBMJAOBM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NKFHBMJAOBM {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:IFDLBAFMEKG)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IFDLBAFMEKG {
    // message fields
    // @@protoc_insertion_point(field:IFDLBAFMEKG.CLLDMNPOOPJ)
    pub CLLDMNPOOPJ: u32,
    // special fields
    // @@protoc_insertion_point(special_field:IFDLBAFMEKG.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IFDLBAFMEKG {
    fn default() -> &'a IFDLBAFMEKG {
        <IFDLBAFMEKG as ::protobuf::Message>::default_instance()
    }
}

impl IFDLBAFMEKG {
    pub fn new() -> IFDLBAFMEKG {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CLLDMNPOOPJ",
            |m: &IFDLBAFMEKG| { &m.CLLDMNPOOPJ },
            |m: &mut IFDLBAFMEKG| { &mut m.CLLDMNPOOPJ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IFDLBAFMEKG>(
            "IFDLBAFMEKG",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IFDLBAFMEKG {
    const NAME: &'static str = "IFDLBAFMEKG";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                120 => {
                    self.CLLDMNPOOPJ = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.CLLDMNPOOPJ != 0 {
            my_size += ::protobuf::rt::uint32_size(15, self.CLLDMNPOOPJ);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.CLLDMNPOOPJ != 0 {
            os.write_uint32(15, self.CLLDMNPOOPJ)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IFDLBAFMEKG {
        IFDLBAFMEKG::new()
    }

    fn clear(&mut self) {
        self.CLLDMNPOOPJ = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IFDLBAFMEKG {
        static instance: IFDLBAFMEKG = IFDLBAFMEKG {
            CLLDMNPOOPJ: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IFDLBAFMEKG {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IFDLBAFMEKG").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IFDLBAFMEKG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IFDLBAFMEKG {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:IGNFNKHNIEL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IGNFNKHNIEL {
    // message fields
    // @@protoc_insertion_point(field:IGNFNKHNIEL.CDJFDJIAING)
    pub CDJFDJIAING: u32,
    // special fields
    // @@protoc_insertion_point(special_field:IGNFNKHNIEL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IGNFNKHNIEL {
    fn default() -> &'a IGNFNKHNIEL {
        <IGNFNKHNIEL as ::protobuf::Message>::default_instance()
    }
}

impl IGNFNKHNIEL {
    pub fn new() -> IGNFNKHNIEL {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CDJFDJIAING",
            |m: &IGNFNKHNIEL| { &m.CDJFDJIAING },
            |m: &mut IGNFNKHNIEL| { &mut m.CDJFDJIAING },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IGNFNKHNIEL>(
            "IGNFNKHNIEL",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IGNFNKHNIEL {
    const NAME: &'static str = "IGNFNKHNIEL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.CDJFDJIAING = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.CDJFDJIAING != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.CDJFDJIAING);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.CDJFDJIAING != 0 {
            os.write_uint32(4, self.CDJFDJIAING)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IGNFNKHNIEL {
        IGNFNKHNIEL::new()
    }

    fn clear(&mut self) {
        self.CDJFDJIAING = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IGNFNKHNIEL {
        static instance: IGNFNKHNIEL = IGNFNKHNIEL {
            CDJFDJIAING: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IGNFNKHNIEL {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IGNFNKHNIEL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IGNFNKHNIEL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IGNFNKHNIEL {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EIMDBGMFDOB)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EIMDBGMFDOB {
    // message fields
    // @@protoc_insertion_point(field:EIMDBGMFDOB.ODKNCMOKFGO)
    pub ODKNCMOKFGO: u32,
    // @@protoc_insertion_point(field:EIMDBGMFDOB.area_id)
    pub area_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:EIMDBGMFDOB.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EIMDBGMFDOB {
    fn default() -> &'a EIMDBGMFDOB {
        <EIMDBGMFDOB as ::protobuf::Message>::default_instance()
    }
}

impl EIMDBGMFDOB {
    pub fn new() -> EIMDBGMFDOB {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ODKNCMOKFGO",
            |m: &EIMDBGMFDOB| { &m.ODKNCMOKFGO },
            |m: &mut EIMDBGMFDOB| { &mut m.ODKNCMOKFGO },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "area_id",
            |m: &EIMDBGMFDOB| { &m.area_id },
            |m: &mut EIMDBGMFDOB| { &mut m.area_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EIMDBGMFDOB>(
            "EIMDBGMFDOB",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EIMDBGMFDOB {
    const NAME: &'static str = "EIMDBGMFDOB";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.ODKNCMOKFGO = is.read_uint32()?;
                },
                40 => {
                    self.area_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ODKNCMOKFGO != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.ODKNCMOKFGO);
        }
        if self.area_id != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.area_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ODKNCMOKFGO != 0 {
            os.write_uint32(4, self.ODKNCMOKFGO)?;
        }
        if self.area_id != 0 {
            os.write_uint32(5, self.area_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EIMDBGMFDOB {
        EIMDBGMFDOB::new()
    }

    fn clear(&mut self) {
        self.ODKNCMOKFGO = 0;
        self.area_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EIMDBGMFDOB {
        static instance: EIMDBGMFDOB = EIMDBGMFDOB {
            ODKNCMOKFGO: 0,
            area_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EIMDBGMFDOB {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EIMDBGMFDOB").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EIMDBGMFDOB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EIMDBGMFDOB {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:AICEBLJDHJL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AICEBLJDHJL {
    // message fields
    // @@protoc_insertion_point(field:AICEBLJDHJL.dynamic_prop_id)
    pub dynamic_prop_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:AICEBLJDHJL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AICEBLJDHJL {
    fn default() -> &'a AICEBLJDHJL {
        <AICEBLJDHJL as ::protobuf::Message>::default_instance()
    }
}

impl AICEBLJDHJL {
    pub fn new() -> AICEBLJDHJL {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dynamic_prop_id",
            |m: &AICEBLJDHJL| { &m.dynamic_prop_id },
            |m: &mut AICEBLJDHJL| { &mut m.dynamic_prop_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AICEBLJDHJL>(
            "AICEBLJDHJL",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AICEBLJDHJL {
    const NAME: &'static str = "AICEBLJDHJL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dynamic_prop_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.dynamic_prop_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.dynamic_prop_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.dynamic_prop_id != 0 {
            os.write_uint32(1, self.dynamic_prop_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AICEBLJDHJL {
        AICEBLJDHJL::new()
    }

    fn clear(&mut self) {
        self.dynamic_prop_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AICEBLJDHJL {
        static instance: AICEBLJDHJL = AICEBLJDHJL {
            dynamic_prop_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AICEBLJDHJL {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AICEBLJDHJL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AICEBLJDHJL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AICEBLJDHJL {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GOIBHEOAHNG)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GOIBHEOAHNG {
    // message fields
    // @@protoc_insertion_point(field:GOIBHEOAHNG.BIJHIEOKFBD)
    pub BIJHIEOKFBD: u32,
    // special fields
    // @@protoc_insertion_point(special_field:GOIBHEOAHNG.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GOIBHEOAHNG {
    fn default() -> &'a GOIBHEOAHNG {
        <GOIBHEOAHNG as ::protobuf::Message>::default_instance()
    }
}

impl GOIBHEOAHNG {
    pub fn new() -> GOIBHEOAHNG {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "BIJHIEOKFBD",
            |m: &GOIBHEOAHNG| { &m.BIJHIEOKFBD },
            |m: &mut GOIBHEOAHNG| { &mut m.BIJHIEOKFBD },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GOIBHEOAHNG>(
            "GOIBHEOAHNG",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GOIBHEOAHNG {
    const NAME: &'static str = "GOIBHEOAHNG";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                64 => {
                    self.BIJHIEOKFBD = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.BIJHIEOKFBD != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.BIJHIEOKFBD);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.BIJHIEOKFBD != 0 {
            os.write_uint32(8, self.BIJHIEOKFBD)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GOIBHEOAHNG {
        GOIBHEOAHNG::new()
    }

    fn clear(&mut self) {
        self.BIJHIEOKFBD = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GOIBHEOAHNG {
        static instance: GOIBHEOAHNG = GOIBHEOAHNG {
            BIJHIEOKFBD: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GOIBHEOAHNG {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GOIBHEOAHNG").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GOIBHEOAHNG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GOIBHEOAHNG {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BAEECFDDJCH)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BAEECFDDJCH {
    // message fields
    // @@protoc_insertion_point(field:BAEECFDDJCH.build_progress)
    pub build_progress: u32,
    // special fields
    // @@protoc_insertion_point(special_field:BAEECFDDJCH.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BAEECFDDJCH {
    fn default() -> &'a BAEECFDDJCH {
        <BAEECFDDJCH as ::protobuf::Message>::default_instance()
    }
}

impl BAEECFDDJCH {
    pub fn new() -> BAEECFDDJCH {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "build_progress",
            |m: &BAEECFDDJCH| { &m.build_progress },
            |m: &mut BAEECFDDJCH| { &mut m.build_progress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BAEECFDDJCH>(
            "BAEECFDDJCH",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BAEECFDDJCH {
    const NAME: &'static str = "BAEECFDDJCH";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                64 => {
                    self.build_progress = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.build_progress != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.build_progress);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.build_progress != 0 {
            os.write_uint32(8, self.build_progress)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BAEECFDDJCH {
        BAEECFDDJCH::new()
    }

    fn clear(&mut self) {
        self.build_progress = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BAEECFDDJCH {
        static instance: BAEECFDDJCH = BAEECFDDJCH {
            build_progress: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BAEECFDDJCH {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BAEECFDDJCH").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BAEECFDDJCH {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BAEECFDDJCH {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LKKHDLLPMEL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LKKHDLLPMEL {
    // message fields
    // @@protoc_insertion_point(field:LKKHDLLPMEL.area_id)
    pub area_id: u32,
    // @@protoc_insertion_point(field:LKKHDLLPMEL.build_step_list)
    pub build_step_list: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:LKKHDLLPMEL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LKKHDLLPMEL {
    fn default() -> &'a LKKHDLLPMEL {
        <LKKHDLLPMEL as ::protobuf::Message>::default_instance()
    }
}

impl LKKHDLLPMEL {
    pub fn new() -> LKKHDLLPMEL {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "area_id",
            |m: &LKKHDLLPMEL| { &m.area_id },
            |m: &mut LKKHDLLPMEL| { &mut m.area_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "build_step_list",
            |m: &LKKHDLLPMEL| { &m.build_step_list },
            |m: &mut LKKHDLLPMEL| { &mut m.build_step_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LKKHDLLPMEL>(
            "LKKHDLLPMEL",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LKKHDLLPMEL {
    const NAME: &'static str = "LKKHDLLPMEL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.area_id = is.read_uint32()?;
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.build_step_list)?;
                },
                48 => {
                    self.build_step_list.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.area_id != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.area_id);
        }
        for value in &self.build_step_list {
            my_size += ::protobuf::rt::uint32_size(6, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.area_id != 0 {
            os.write_uint32(10, self.area_id)?;
        }
        for v in &self.build_step_list {
            os.write_uint32(6, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LKKHDLLPMEL {
        LKKHDLLPMEL::new()
    }

    fn clear(&mut self) {
        self.area_id = 0;
        self.build_step_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LKKHDLLPMEL {
        static instance: LKKHDLLPMEL = LKKHDLLPMEL {
            area_id: 0,
            build_step_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LKKHDLLPMEL {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LKKHDLLPMEL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LKKHDLLPMEL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LKKHDLLPMEL {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ACJOMKMLBOO)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ACJOMKMLBOO {
    // message fields
    // @@protoc_insertion_point(field:ACJOMKMLBOO.area_info_list)
    pub area_info_list: ::std::vec::Vec<super::LKKHDLLPMEL::LKKHDLLPMEL>,
    // special fields
    // @@protoc_insertion_point(special_field:ACJOMKMLBOO.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ACJOMKMLBOO {
    fn default() -> &'a ACJOMKMLBOO {
        <ACJOMKMLBOO as ::protobuf::Message>::default_instance()
    }
}

impl ACJOMKMLBOO {
    pub fn new() -> ACJOMKMLBOO {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "area_info_list",
            |m: &ACJOMKMLBOO| { &m.area_info_list },
            |m: &mut ACJOMKMLBOO| { &mut m.area_info_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ACJOMKMLBOO>(
            "ACJOMKMLBOO",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ACJOMKMLBOO {
    const NAME: &'static str = "ACJOMKMLBOO";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                98 => {
                    self.area_info_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.area_info_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.area_info_list {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ACJOMKMLBOO {
        ACJOMKMLBOO::new()
    }

    fn clear(&mut self) {
        self.area_info_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ACJOMKMLBOO {
        static instance: ACJOMKMLBOO = ACJOMKMLBOO {
            area_info_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ACJOMKMLBOO {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ACJOMKMLBOO").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ACJOMKMLBOO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ACJOMKMLBOO {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ECEOEEEJIOC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ECEOEEEJIOC {
    // message oneof groups
    pub OMNKNOLIHNB: ::std::option::Option<eceoeeejioc::OMNKNOLIHNB>,
    // special fields
    // @@protoc_insertion_point(special_field:ECEOEEEJIOC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ECEOEEEJIOC {
    fn default() -> &'a ECEOEEEJIOC {
        <ECEOEEEJIOC as ::protobuf::Message>::default_instance()
    }
}

impl ECEOEEEJIOC {
    pub fn new() -> ECEOEEEJIOC {
        ::std::default::Default::default()
    }

    // .GOIBHEOAHNG LOFHHANCPBG = 1748;

    pub fn LOFHHANCPBG(&self) -> &super::GOIBHEOAHNG::GOIBHEOAHNG {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::LOFHHANCPBG(ref v)) => v,
            _ => <super::GOIBHEOAHNG::GOIBHEOAHNG as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_LOFHHANCPBG(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_LOFHHANCPBG(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::LOFHHANCPBG(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_LOFHHANCPBG(&mut self, v: super::GOIBHEOAHNG::GOIBHEOAHNG) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::LOFHHANCPBG(v))
    }

    // Mutable pointer to the field.
    pub fn mut_LOFHHANCPBG(&mut self) -> &mut super::GOIBHEOAHNG::GOIBHEOAHNG {
        if let ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::LOFHHANCPBG(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::LOFHHANCPBG(super::GOIBHEOAHNG::GOIBHEOAHNG::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::LOFHHANCPBG(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_LOFHHANCPBG(&mut self) -> super::GOIBHEOAHNG::GOIBHEOAHNG {
        if self.has_LOFHHANCPBG() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::LOFHHANCPBG(v)) => v,
                _ => panic!(),
            }
        } else {
            super::GOIBHEOAHNG::GOIBHEOAHNG::new()
        }
    }

    // .BFIHFFONJIH KIJLCJBJICP = 671;

    pub fn KIJLCJBJICP(&self) -> &super::BFIHFFONJIH::BFIHFFONJIH {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::KIJLCJBJICP(ref v)) => v,
            _ => <super::BFIHFFONJIH::BFIHFFONJIH as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_KIJLCJBJICP(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_KIJLCJBJICP(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::KIJLCJBJICP(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_KIJLCJBJICP(&mut self, v: super::BFIHFFONJIH::BFIHFFONJIH) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::KIJLCJBJICP(v))
    }

    // Mutable pointer to the field.
    pub fn mut_KIJLCJBJICP(&mut self) -> &mut super::BFIHFFONJIH::BFIHFFONJIH {
        if let ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::KIJLCJBJICP(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::KIJLCJBJICP(super::BFIHFFONJIH::BFIHFFONJIH::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::KIJLCJBJICP(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_KIJLCJBJICP(&mut self) -> super::BFIHFFONJIH::BFIHFFONJIH {
        if self.has_KIJLCJBJICP() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::KIJLCJBJICP(v)) => v,
                _ => panic!(),
            }
        } else {
            super::BFIHFFONJIH::BFIHFFONJIH::new()
        }
    }

    // .HHCFGIJPHLC JHJHDIHDJIM = 1489;

    pub fn JHJHDIHDJIM(&self) -> &super::HHCFGIJPHLC::HHCFGIJPHLC {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::JHJHDIHDJIM(ref v)) => v,
            _ => <super::HHCFGIJPHLC::HHCFGIJPHLC as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_JHJHDIHDJIM(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_JHJHDIHDJIM(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::JHJHDIHDJIM(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_JHJHDIHDJIM(&mut self, v: super::HHCFGIJPHLC::HHCFGIJPHLC) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::JHJHDIHDJIM(v))
    }

    // Mutable pointer to the field.
    pub fn mut_JHJHDIHDJIM(&mut self) -> &mut super::HHCFGIJPHLC::HHCFGIJPHLC {
        if let ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::JHJHDIHDJIM(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::JHJHDIHDJIM(super::HHCFGIJPHLC::HHCFGIJPHLC::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::JHJHDIHDJIM(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_JHJHDIHDJIM(&mut self) -> super::HHCFGIJPHLC::HHCFGIJPHLC {
        if self.has_JHJHDIHDJIM() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::JHJHDIHDJIM(v)) => v,
                _ => panic!(),
            }
        } else {
            super::HHCFGIJPHLC::HHCFGIJPHLC::new()
        }
    }

    // .NKFHBMJAOBM JFBBLDGBEDH = 98;

    pub fn JFBBLDGBEDH(&self) -> &super::NKFHBMJAOBM::NKFHBMJAOBM {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::JFBBLDGBEDH(ref v)) => v,
            _ => <super::NKFHBMJAOBM::NKFHBMJAOBM as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_JFBBLDGBEDH(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_JFBBLDGBEDH(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::JFBBLDGBEDH(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_JFBBLDGBEDH(&mut self, v: super::NKFHBMJAOBM::NKFHBMJAOBM) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::JFBBLDGBEDH(v))
    }

    // Mutable pointer to the field.
    pub fn mut_JFBBLDGBEDH(&mut self) -> &mut super::NKFHBMJAOBM::NKFHBMJAOBM {
        if let ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::JFBBLDGBEDH(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::JFBBLDGBEDH(super::NKFHBMJAOBM::NKFHBMJAOBM::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::JFBBLDGBEDH(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_JFBBLDGBEDH(&mut self) -> super::NKFHBMJAOBM::NKFHBMJAOBM {
        if self.has_JFBBLDGBEDH() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::JFBBLDGBEDH(v)) => v,
                _ => panic!(),
            }
        } else {
            super::NKFHBMJAOBM::NKFHBMJAOBM::new()
        }
    }

    // .IFDLBAFMEKG EBOJDHDENKA = 791;

    pub fn EBOJDHDENKA(&self) -> &super::IFDLBAFMEKG::IFDLBAFMEKG {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::EBOJDHDENKA(ref v)) => v,
            _ => <super::IFDLBAFMEKG::IFDLBAFMEKG as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_EBOJDHDENKA(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_EBOJDHDENKA(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::EBOJDHDENKA(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_EBOJDHDENKA(&mut self, v: super::IFDLBAFMEKG::IFDLBAFMEKG) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::EBOJDHDENKA(v))
    }

    // Mutable pointer to the field.
    pub fn mut_EBOJDHDENKA(&mut self) -> &mut super::IFDLBAFMEKG::IFDLBAFMEKG {
        if let ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::EBOJDHDENKA(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::EBOJDHDENKA(super::IFDLBAFMEKG::IFDLBAFMEKG::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::EBOJDHDENKA(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_EBOJDHDENKA(&mut self) -> super::IFDLBAFMEKG::IFDLBAFMEKG {
        if self.has_EBOJDHDENKA() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::EBOJDHDENKA(v)) => v,
                _ => panic!(),
            }
        } else {
            super::IFDLBAFMEKG::IFDLBAFMEKG::new()
        }
    }

    // .EIMDBGMFDOB BIIMCNKIEPD = 1938;

    pub fn BIIMCNKIEPD(&self) -> &super::EIMDBGMFDOB::EIMDBGMFDOB {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::BIIMCNKIEPD(ref v)) => v,
            _ => <super::EIMDBGMFDOB::EIMDBGMFDOB as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_BIIMCNKIEPD(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_BIIMCNKIEPD(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::BIIMCNKIEPD(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_BIIMCNKIEPD(&mut self, v: super::EIMDBGMFDOB::EIMDBGMFDOB) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::BIIMCNKIEPD(v))
    }

    // Mutable pointer to the field.
    pub fn mut_BIIMCNKIEPD(&mut self) -> &mut super::EIMDBGMFDOB::EIMDBGMFDOB {
        if let ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::BIIMCNKIEPD(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::BIIMCNKIEPD(super::EIMDBGMFDOB::EIMDBGMFDOB::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::BIIMCNKIEPD(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_BIIMCNKIEPD(&mut self) -> super::EIMDBGMFDOB::EIMDBGMFDOB {
        if self.has_BIIMCNKIEPD() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::BIIMCNKIEPD(v)) => v,
                _ => panic!(),
            }
        } else {
            super::EIMDBGMFDOB::EIMDBGMFDOB::new()
        }
    }

    // .AICEBLJDHJL BFKEEKCOODN = 447;

    pub fn BFKEEKCOODN(&self) -> &super::AICEBLJDHJL::AICEBLJDHJL {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::BFKEEKCOODN(ref v)) => v,
            _ => <super::AICEBLJDHJL::AICEBLJDHJL as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_BFKEEKCOODN(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_BFKEEKCOODN(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::BFKEEKCOODN(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_BFKEEKCOODN(&mut self, v: super::AICEBLJDHJL::AICEBLJDHJL) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::BFKEEKCOODN(v))
    }

    // Mutable pointer to the field.
    pub fn mut_BFKEEKCOODN(&mut self) -> &mut super::AICEBLJDHJL::AICEBLJDHJL {
        if let ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::BFKEEKCOODN(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::BFKEEKCOODN(super::AICEBLJDHJL::AICEBLJDHJL::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::BFKEEKCOODN(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_BFKEEKCOODN(&mut self) -> super::AICEBLJDHJL::AICEBLJDHJL {
        if self.has_BFKEEKCOODN() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::BFKEEKCOODN(v)) => v,
                _ => panic!(),
            }
        } else {
            super::AICEBLJDHJL::AICEBLJDHJL::new()
        }
    }

    // .IGNFNKHNIEL PMNEMJCNFEJ = 520;

    pub fn PMNEMJCNFEJ(&self) -> &super::IGNFNKHNIEL::IGNFNKHNIEL {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::PMNEMJCNFEJ(ref v)) => v,
            _ => <super::IGNFNKHNIEL::IGNFNKHNIEL as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_PMNEMJCNFEJ(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_PMNEMJCNFEJ(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::PMNEMJCNFEJ(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_PMNEMJCNFEJ(&mut self, v: super::IGNFNKHNIEL::IGNFNKHNIEL) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::PMNEMJCNFEJ(v))
    }

    // Mutable pointer to the field.
    pub fn mut_PMNEMJCNFEJ(&mut self) -> &mut super::IGNFNKHNIEL::IGNFNKHNIEL {
        if let ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::PMNEMJCNFEJ(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::PMNEMJCNFEJ(super::IGNFNKHNIEL::IGNFNKHNIEL::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::PMNEMJCNFEJ(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_PMNEMJCNFEJ(&mut self) -> super::IGNFNKHNIEL::IGNFNKHNIEL {
        if self.has_PMNEMJCNFEJ() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::PMNEMJCNFEJ(v)) => v,
                _ => panic!(),
            }
        } else {
            super::IGNFNKHNIEL::IGNFNKHNIEL::new()
        }
    }

    // .BAEECFDDJCH MMEGPPCJFGG = 1407;

    pub fn MMEGPPCJFGG(&self) -> &super::BAEECFDDJCH::BAEECFDDJCH {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::MMEGPPCJFGG(ref v)) => v,
            _ => <super::BAEECFDDJCH::BAEECFDDJCH as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_MMEGPPCJFGG(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_MMEGPPCJFGG(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::MMEGPPCJFGG(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_MMEGPPCJFGG(&mut self, v: super::BAEECFDDJCH::BAEECFDDJCH) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::MMEGPPCJFGG(v))
    }

    // Mutable pointer to the field.
    pub fn mut_MMEGPPCJFGG(&mut self) -> &mut super::BAEECFDDJCH::BAEECFDDJCH {
        if let ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::MMEGPPCJFGG(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::MMEGPPCJFGG(super::BAEECFDDJCH::BAEECFDDJCH::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::MMEGPPCJFGG(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_MMEGPPCJFGG(&mut self) -> super::BAEECFDDJCH::BAEECFDDJCH {
        if self.has_MMEGPPCJFGG() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::MMEGPPCJFGG(v)) => v,
                _ => panic!(),
            }
        } else {
            super::BAEECFDDJCH::BAEECFDDJCH::new()
        }
    }

    // .ACJOMKMLBOO MCEEKAJKCIG = 844;

    pub fn MCEEKAJKCIG(&self) -> &super::ACJOMKMLBOO::ACJOMKMLBOO {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::MCEEKAJKCIG(ref v)) => v,
            _ => <super::ACJOMKMLBOO::ACJOMKMLBOO as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_MCEEKAJKCIG(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
    }

    pub fn has_MCEEKAJKCIG(&self) -> bool {
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::MCEEKAJKCIG(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_MCEEKAJKCIG(&mut self, v: super::ACJOMKMLBOO::ACJOMKMLBOO) {
        self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::MCEEKAJKCIG(v))
    }

    // Mutable pointer to the field.
    pub fn mut_MCEEKAJKCIG(&mut self) -> &mut super::ACJOMKMLBOO::ACJOMKMLBOO {
        if let ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::MCEEKAJKCIG(_)) = self.OMNKNOLIHNB {
        } else {
            self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::MCEEKAJKCIG(super::ACJOMKMLBOO::ACJOMKMLBOO::new()));
        }
        match self.OMNKNOLIHNB {
            ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::MCEEKAJKCIG(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_MCEEKAJKCIG(&mut self) -> super::ACJOMKMLBOO::ACJOMKMLBOO {
        if self.has_MCEEKAJKCIG() {
            match self.OMNKNOLIHNB.take() {
                ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::MCEEKAJKCIG(v)) => v,
                _ => panic!(),
            }
        } else {
            super::ACJOMKMLBOO::ACJOMKMLBOO::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::GOIBHEOAHNG::GOIBHEOAHNG>(
            "LOFHHANCPBG",
            ECEOEEEJIOC::has_LOFHHANCPBG,
            ECEOEEEJIOC::LOFHHANCPBG,
            ECEOEEEJIOC::mut_LOFHHANCPBG,
            ECEOEEEJIOC::set_LOFHHANCPBG,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::BFIHFFONJIH::BFIHFFONJIH>(
            "KIJLCJBJICP",
            ECEOEEEJIOC::has_KIJLCJBJICP,
            ECEOEEEJIOC::KIJLCJBJICP,
            ECEOEEEJIOC::mut_KIJLCJBJICP,
            ECEOEEEJIOC::set_KIJLCJBJICP,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::HHCFGIJPHLC::HHCFGIJPHLC>(
            "JHJHDIHDJIM",
            ECEOEEEJIOC::has_JHJHDIHDJIM,
            ECEOEEEJIOC::JHJHDIHDJIM,
            ECEOEEEJIOC::mut_JHJHDIHDJIM,
            ECEOEEEJIOC::set_JHJHDIHDJIM,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::NKFHBMJAOBM::NKFHBMJAOBM>(
            "JFBBLDGBEDH",
            ECEOEEEJIOC::has_JFBBLDGBEDH,
            ECEOEEEJIOC::JFBBLDGBEDH,
            ECEOEEEJIOC::mut_JFBBLDGBEDH,
            ECEOEEEJIOC::set_JFBBLDGBEDH,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::IFDLBAFMEKG::IFDLBAFMEKG>(
            "EBOJDHDENKA",
            ECEOEEEJIOC::has_EBOJDHDENKA,
            ECEOEEEJIOC::EBOJDHDENKA,
            ECEOEEEJIOC::mut_EBOJDHDENKA,
            ECEOEEEJIOC::set_EBOJDHDENKA,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::EIMDBGMFDOB::EIMDBGMFDOB>(
            "BIIMCNKIEPD",
            ECEOEEEJIOC::has_BIIMCNKIEPD,
            ECEOEEEJIOC::BIIMCNKIEPD,
            ECEOEEEJIOC::mut_BIIMCNKIEPD,
            ECEOEEEJIOC::set_BIIMCNKIEPD,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::AICEBLJDHJL::AICEBLJDHJL>(
            "BFKEEKCOODN",
            ECEOEEEJIOC::has_BFKEEKCOODN,
            ECEOEEEJIOC::BFKEEKCOODN,
            ECEOEEEJIOC::mut_BFKEEKCOODN,
            ECEOEEEJIOC::set_BFKEEKCOODN,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::IGNFNKHNIEL::IGNFNKHNIEL>(
            "PMNEMJCNFEJ",
            ECEOEEEJIOC::has_PMNEMJCNFEJ,
            ECEOEEEJIOC::PMNEMJCNFEJ,
            ECEOEEEJIOC::mut_PMNEMJCNFEJ,
            ECEOEEEJIOC::set_PMNEMJCNFEJ,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::BAEECFDDJCH::BAEECFDDJCH>(
            "MMEGPPCJFGG",
            ECEOEEEJIOC::has_MMEGPPCJFGG,
            ECEOEEEJIOC::MMEGPPCJFGG,
            ECEOEEEJIOC::mut_MMEGPPCJFGG,
            ECEOEEEJIOC::set_MMEGPPCJFGG,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::ACJOMKMLBOO::ACJOMKMLBOO>(
            "MCEEKAJKCIG",
            ECEOEEEJIOC::has_MCEEKAJKCIG,
            ECEOEEEJIOC::MCEEKAJKCIG,
            ECEOEEEJIOC::mut_MCEEKAJKCIG,
            ECEOEEEJIOC::set_MCEEKAJKCIG,
        ));
        oneofs.push(eceoeeejioc::OMNKNOLIHNB::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ECEOEEEJIOC>(
            "ECEOEEEJIOC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ECEOEEEJIOC {
    const NAME: &'static str = "ECEOEEEJIOC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13986 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::LOFHHANCPBG(is.read_message()?));
                },
                5370 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::KIJLCJBJICP(is.read_message()?));
                },
                11914 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::JHJHDIHDJIM(is.read_message()?));
                },
                786 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::JFBBLDGBEDH(is.read_message()?));
                },
                6330 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::EBOJDHDENKA(is.read_message()?));
                },
                15506 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::BIIMCNKIEPD(is.read_message()?));
                },
                3578 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::BFKEEKCOODN(is.read_message()?));
                },
                4162 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::PMNEMJCNFEJ(is.read_message()?));
                },
                11258 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::MMEGPPCJFGG(is.read_message()?));
                },
                6754 => {
                    self.OMNKNOLIHNB = ::std::option::Option::Some(eceoeeejioc::OMNKNOLIHNB::MCEEKAJKCIG(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.OMNKNOLIHNB {
            match v {
                &eceoeeejioc::OMNKNOLIHNB::LOFHHANCPBG(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &eceoeeejioc::OMNKNOLIHNB::KIJLCJBJICP(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &eceoeeejioc::OMNKNOLIHNB::JHJHDIHDJIM(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &eceoeeejioc::OMNKNOLIHNB::JFBBLDGBEDH(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &eceoeeejioc::OMNKNOLIHNB::EBOJDHDENKA(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &eceoeeejioc::OMNKNOLIHNB::BIIMCNKIEPD(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &eceoeeejioc::OMNKNOLIHNB::BFKEEKCOODN(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &eceoeeejioc::OMNKNOLIHNB::PMNEMJCNFEJ(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &eceoeeejioc::OMNKNOLIHNB::MMEGPPCJFGG(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &eceoeeejioc::OMNKNOLIHNB::MCEEKAJKCIG(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.OMNKNOLIHNB {
            match v {
                &eceoeeejioc::OMNKNOLIHNB::LOFHHANCPBG(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1748, v, os)?;
                },
                &eceoeeejioc::OMNKNOLIHNB::KIJLCJBJICP(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(671, v, os)?;
                },
                &eceoeeejioc::OMNKNOLIHNB::JHJHDIHDJIM(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1489, v, os)?;
                },
                &eceoeeejioc::OMNKNOLIHNB::JFBBLDGBEDH(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(98, v, os)?;
                },
                &eceoeeejioc::OMNKNOLIHNB::EBOJDHDENKA(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(791, v, os)?;
                },
                &eceoeeejioc::OMNKNOLIHNB::BIIMCNKIEPD(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1938, v, os)?;
                },
                &eceoeeejioc::OMNKNOLIHNB::BFKEEKCOODN(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(447, v, os)?;
                },
                &eceoeeejioc::OMNKNOLIHNB::PMNEMJCNFEJ(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(520, v, os)?;
                },
                &eceoeeejioc::OMNKNOLIHNB::MMEGPPCJFGG(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1407, v, os)?;
                },
                &eceoeeejioc::OMNKNOLIHNB::MCEEKAJKCIG(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(844, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ECEOEEEJIOC {
        ECEOEEEJIOC::new()
    }

    fn clear(&mut self) {
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.OMNKNOLIHNB = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ECEOEEEJIOC {
        static instance: ECEOEEEJIOC = ECEOEEEJIOC {
            OMNKNOLIHNB: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ECEOEEEJIOC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ECEOEEEJIOC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ECEOEEEJIOC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ECEOEEEJIOC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ECEOEEEJIOC`
pub mod eceoeeejioc {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:ECEOEEEJIOC.OMNKNOLIHNB)
    pub enum OMNKNOLIHNB {
        // @@protoc_insertion_point(oneof_field:ECEOEEEJIOC.LOFHHANCPBG)
        LOFHHANCPBG(super::super::GOIBHEOAHNG::GOIBHEOAHNG),
        // @@protoc_insertion_point(oneof_field:ECEOEEEJIOC.KIJLCJBJICP)
        KIJLCJBJICP(super::super::BFIHFFONJIH::BFIHFFONJIH),
        // @@protoc_insertion_point(oneof_field:ECEOEEEJIOC.JHJHDIHDJIM)
        JHJHDIHDJIM(super::super::HHCFGIJPHLC::HHCFGIJPHLC),
        // @@protoc_insertion_point(oneof_field:ECEOEEEJIOC.JFBBLDGBEDH)
        JFBBLDGBEDH(super::super::NKFHBMJAOBM::NKFHBMJAOBM),
        // @@protoc_insertion_point(oneof_field:ECEOEEEJIOC.EBOJDHDENKA)
        EBOJDHDENKA(super::super::IFDLBAFMEKG::IFDLBAFMEKG),
        // @@protoc_insertion_point(oneof_field:ECEOEEEJIOC.BIIMCNKIEPD)
        BIIMCNKIEPD(super::super::EIMDBGMFDOB::EIMDBGMFDOB),
        // @@protoc_insertion_point(oneof_field:ECEOEEEJIOC.BFKEEKCOODN)
        BFKEEKCOODN(super::super::AICEBLJDHJL::AICEBLJDHJL),
        // @@protoc_insertion_point(oneof_field:ECEOEEEJIOC.PMNEMJCNFEJ)
        PMNEMJCNFEJ(super::super::IGNFNKHNIEL::IGNFNKHNIEL),
        // @@protoc_insertion_point(oneof_field:ECEOEEEJIOC.MMEGPPCJFGG)
        MMEGPPCJFGG(super::super::BAEECFDDJCH::BAEECFDDJCH),
        // @@protoc_insertion_point(oneof_field:ECEOEEEJIOC.MCEEKAJKCIG)
        MCEEKAJKCIG(super::super::ACJOMKMLBOO::ACJOMKMLBOO),
    }

    impl ::protobuf::Oneof for OMNKNOLIHNB {
    }

    impl ::protobuf::OneofFull for OMNKNOLIHNB {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ECEOEEEJIOC as ::protobuf::MessageFull>::descriptor().oneof_by_name("OMNKNOLIHNB").unwrap()).clone()
        }
    }

    impl OMNKNOLIHNB {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<OMNKNOLIHNB>("OMNKNOLIHNB")
        }
    }
}

// @@protoc_insertion_point(message:TrainPartyBuildingUpdateNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyBuildingUpdateNotify {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyBuildingUpdateNotify.JLNMJIFIALA)
    pub JLNMJIFIALA: ::std::vec::Vec<super::ECEOEEEJIOC::ECEOEEEJIOC>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyBuildingUpdateNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyBuildingUpdateNotify {
    fn default() -> &'a TrainPartyBuildingUpdateNotify {
        <TrainPartyBuildingUpdateNotify as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyBuildingUpdateNotify {
    pub fn new() -> TrainPartyBuildingUpdateNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "JLNMJIFIALA",
            |m: &TrainPartyBuildingUpdateNotify| { &m.JLNMJIFIALA },
            |m: &mut TrainPartyBuildingUpdateNotify| { &mut m.JLNMJIFIALA },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyBuildingUpdateNotify>(
            "TrainPartyBuildingUpdateNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyBuildingUpdateNotify {
    const NAME: &'static str = "TrainPartyBuildingUpdateNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.JLNMJIFIALA.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.JLNMJIFIALA {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.JLNMJIFIALA {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyBuildingUpdateNotify {
        TrainPartyBuildingUpdateNotify::new()
    }

    fn clear(&mut self) {
        self.JLNMJIFIALA.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyBuildingUpdateNotify {
        static instance: TrainPartyBuildingUpdateNotify = TrainPartyBuildingUpdateNotify {
            JLNMJIFIALA: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyBuildingUpdateNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyBuildingUpdateNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyBuildingUpdateNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyBuildingUpdateNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyEnterCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyEnterCsReq {
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyEnterCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyEnterCsReq {
    fn default() -> &'a TrainPartyEnterCsReq {
        <TrainPartyEnterCsReq as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyEnterCsReq {
    pub fn new() -> TrainPartyEnterCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyEnterCsReq>(
            "TrainPartyEnterCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyEnterCsReq {
    const NAME: &'static str = "TrainPartyEnterCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyEnterCsReq {
        TrainPartyEnterCsReq::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyEnterCsReq {
        static instance: TrainPartyEnterCsReq = TrainPartyEnterCsReq {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyEnterCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyEnterCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyEnterCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyEnterCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyEnterScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyEnterScRsp {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyEnterScRsp.retcode)
    pub retcode: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyEnterScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyEnterScRsp {
    fn default() -> &'a TrainPartyEnterScRsp {
        <TrainPartyEnterScRsp as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyEnterScRsp {
    pub fn new() -> TrainPartyEnterScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &TrainPartyEnterScRsp| { &m.retcode },
            |m: &mut TrainPartyEnterScRsp| { &mut m.retcode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyEnterScRsp>(
            "TrainPartyEnterScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyEnterScRsp {
    const NAME: &'static str = "TrainPartyEnterScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                40 => {
                    self.retcode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.retcode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(5, self.retcode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyEnterScRsp {
        TrainPartyEnterScRsp::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyEnterScRsp {
        static instance: TrainPartyEnterScRsp = TrainPartyEnterScRsp {
            retcode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyEnterScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyEnterScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyEnterScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyEnterScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyLeaveCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyLeaveCsReq {
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyLeaveCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyLeaveCsReq {
    fn default() -> &'a TrainPartyLeaveCsReq {
        <TrainPartyLeaveCsReq as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyLeaveCsReq {
    pub fn new() -> TrainPartyLeaveCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyLeaveCsReq>(
            "TrainPartyLeaveCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyLeaveCsReq {
    const NAME: &'static str = "TrainPartyLeaveCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyLeaveCsReq {
        TrainPartyLeaveCsReq::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyLeaveCsReq {
        static instance: TrainPartyLeaveCsReq = TrainPartyLeaveCsReq {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyLeaveCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyLeaveCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyLeaveCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyLeaveCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyLeaveScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyLeaveScRsp {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyLeaveScRsp.retcode)
    pub retcode: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyLeaveScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyLeaveScRsp {
    fn default() -> &'a TrainPartyLeaveScRsp {
        <TrainPartyLeaveScRsp as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyLeaveScRsp {
    pub fn new() -> TrainPartyLeaveScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &TrainPartyLeaveScRsp| { &m.retcode },
            |m: &mut TrainPartyLeaveScRsp| { &mut m.retcode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyLeaveScRsp>(
            "TrainPartyLeaveScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyLeaveScRsp {
    const NAME: &'static str = "TrainPartyLeaveScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                56 => {
                    self.retcode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.retcode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(7, self.retcode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyLeaveScRsp {
        TrainPartyLeaveScRsp::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyLeaveScRsp {
        static instance: TrainPartyLeaveScRsp = TrainPartyLeaveScRsp {
            retcode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyLeaveScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyLeaveScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyLeaveScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyLeaveScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:KHIIKMDCABJ)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KHIIKMDCABJ {
    // message fields
    // @@protoc_insertion_point(field:KHIIKMDCABJ.level)
    pub level: u32,
    // @@protoc_insertion_point(field:KHIIKMDCABJ.IAHEKFKNFCD)
    pub IAHEKFKNFCD: ::protobuf::EnumOrUnknown<TrainPartyMtCategory>,
    // special fields
    // @@protoc_insertion_point(special_field:KHIIKMDCABJ.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KHIIKMDCABJ {
    fn default() -> &'a KHIIKMDCABJ {
        <KHIIKMDCABJ as ::protobuf::Message>::default_instance()
    }
}

impl KHIIKMDCABJ {
    pub fn new() -> KHIIKMDCABJ {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "level",
            |m: &KHIIKMDCABJ| { &m.level },
            |m: &mut KHIIKMDCABJ| { &mut m.level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "IAHEKFKNFCD",
            |m: &KHIIKMDCABJ| { &m.IAHEKFKNFCD },
            |m: &mut KHIIKMDCABJ| { &mut m.IAHEKFKNFCD },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KHIIKMDCABJ>(
            "KHIIKMDCABJ",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KHIIKMDCABJ {
    const NAME: &'static str = "KHIIKMDCABJ";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.level = is.read_uint32()?;
                },
                120 => {
                    self.IAHEKFKNFCD = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.level != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.level);
        }
        if self.IAHEKFKNFCD != ::protobuf::EnumOrUnknown::new(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(15, self.IAHEKFKNFCD.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.level != 0 {
            os.write_uint32(2, self.level)?;
        }
        if self.IAHEKFKNFCD != ::protobuf::EnumOrUnknown::new(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_NONE) {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&self.IAHEKFKNFCD))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KHIIKMDCABJ {
        KHIIKMDCABJ::new()
    }

    fn clear(&mut self) {
        self.level = 0;
        self.IAHEKFKNFCD = ::protobuf::EnumOrUnknown::new(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KHIIKMDCABJ {
        static instance: KHIIKMDCABJ = KHIIKMDCABJ {
            level: 0,
            IAHEKFKNFCD: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KHIIKMDCABJ {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KHIIKMDCABJ").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KHIIKMDCABJ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KHIIKMDCABJ {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyUnlockBuildAreaCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyUnlockBuildAreaCsReq {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyUnlockBuildAreaCsReq.area_id)
    pub area_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyUnlockBuildAreaCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyUnlockBuildAreaCsReq {
    fn default() -> &'a TrainPartyUnlockBuildAreaCsReq {
        <TrainPartyUnlockBuildAreaCsReq as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyUnlockBuildAreaCsReq {
    pub fn new() -> TrainPartyUnlockBuildAreaCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "area_id",
            |m: &TrainPartyUnlockBuildAreaCsReq| { &m.area_id },
            |m: &mut TrainPartyUnlockBuildAreaCsReq| { &mut m.area_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyUnlockBuildAreaCsReq>(
            "TrainPartyUnlockBuildAreaCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyUnlockBuildAreaCsReq {
    const NAME: &'static str = "TrainPartyUnlockBuildAreaCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                56 => {
                    self.area_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.area_id != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.area_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.area_id != 0 {
            os.write_uint32(7, self.area_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyUnlockBuildAreaCsReq {
        TrainPartyUnlockBuildAreaCsReq::new()
    }

    fn clear(&mut self) {
        self.area_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyUnlockBuildAreaCsReq {
        static instance: TrainPartyUnlockBuildAreaCsReq = TrainPartyUnlockBuildAreaCsReq {
            area_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyUnlockBuildAreaCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyUnlockBuildAreaCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyUnlockBuildAreaCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyUnlockBuildAreaCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyUnlockBuildAreaScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyUnlockBuildAreaScRsp {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyUnlockBuildAreaScRsp.area_id)
    pub area_id: u32,
    // @@protoc_insertion_point(field:TrainPartyUnlockBuildAreaScRsp.retcode)
    pub retcode: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyUnlockBuildAreaScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyUnlockBuildAreaScRsp {
    fn default() -> &'a TrainPartyUnlockBuildAreaScRsp {
        <TrainPartyUnlockBuildAreaScRsp as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyUnlockBuildAreaScRsp {
    pub fn new() -> TrainPartyUnlockBuildAreaScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "area_id",
            |m: &TrainPartyUnlockBuildAreaScRsp| { &m.area_id },
            |m: &mut TrainPartyUnlockBuildAreaScRsp| { &mut m.area_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &TrainPartyUnlockBuildAreaScRsp| { &m.retcode },
            |m: &mut TrainPartyUnlockBuildAreaScRsp| { &mut m.retcode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyUnlockBuildAreaScRsp>(
            "TrainPartyUnlockBuildAreaScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyUnlockBuildAreaScRsp {
    const NAME: &'static str = "TrainPartyUnlockBuildAreaScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.area_id = is.read_uint32()?;
                },
                96 => {
                    self.retcode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.area_id != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.area_id);
        }
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.retcode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.area_id != 0 {
            os.write_uint32(6, self.area_id)?;
        }
        if self.retcode != 0 {
            os.write_uint32(12, self.retcode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyUnlockBuildAreaScRsp {
        TrainPartyUnlockBuildAreaScRsp::new()
    }

    fn clear(&mut self) {
        self.area_id = 0;
        self.retcode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyUnlockBuildAreaScRsp {
        static instance: TrainPartyUnlockBuildAreaScRsp = TrainPartyUnlockBuildAreaScRsp {
            area_id: 0,
            retcode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyUnlockBuildAreaScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyUnlockBuildAreaScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyUnlockBuildAreaScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyUnlockBuildAreaScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyGamePlaySettleNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyGamePlaySettleNotify {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyGamePlaySettleNotify.passenger_persistent)
    pub passenger_persistent: ::protobuf::MessageField<TrainPartyPersistentPassenger>,
    // @@protoc_insertion_point(field:TrainPartyGamePlaySettleNotify.attempts)
    pub attempts: u32,
    // @@protoc_insertion_point(field:TrainPartyGamePlaySettleNotify.room_unlock)
    pub room_unlock: u32,
    // @@protoc_insertion_point(field:TrainPartyGamePlaySettleNotify.BFBPHDKHHKO)
    pub BFBPHDKHHKO: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyGamePlaySettleNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyGamePlaySettleNotify {
    fn default() -> &'a TrainPartyGamePlaySettleNotify {
        <TrainPartyGamePlaySettleNotify as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyGamePlaySettleNotify {
    pub fn new() -> TrainPartyGamePlaySettleNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyPersistentPassenger>(
            "passenger_persistent",
            |m: &TrainPartyGamePlaySettleNotify| { &m.passenger_persistent },
            |m: &mut TrainPartyGamePlaySettleNotify| { &mut m.passenger_persistent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "attempts",
            |m: &TrainPartyGamePlaySettleNotify| { &m.attempts },
            |m: &mut TrainPartyGamePlaySettleNotify| { &mut m.attempts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "room_unlock",
            |m: &TrainPartyGamePlaySettleNotify| { &m.room_unlock },
            |m: &mut TrainPartyGamePlaySettleNotify| { &mut m.room_unlock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "BFBPHDKHHKO",
            |m: &TrainPartyGamePlaySettleNotify| { &m.BFBPHDKHHKO },
            |m: &mut TrainPartyGamePlaySettleNotify| { &mut m.BFBPHDKHHKO },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyGamePlaySettleNotify>(
            "TrainPartyGamePlaySettleNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyGamePlaySettleNotify {
    const NAME: &'static str = "TrainPartyGamePlaySettleNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.passenger_persistent)?;
                },
                72 => {
                    self.attempts = is.read_uint32()?;
                },
                112 => {
                    self.room_unlock = is.read_uint32()?;
                },
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.BFBPHDKHHKO)?;
                },
                8 => {
                    self.BFBPHDKHHKO.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.passenger_persistent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.attempts != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.attempts);
        }
        if self.room_unlock != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.room_unlock);
        }
        for value in &self.BFBPHDKHHKO {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.passenger_persistent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.attempts != 0 {
            os.write_uint32(9, self.attempts)?;
        }
        if self.room_unlock != 0 {
            os.write_uint32(14, self.room_unlock)?;
        }
        for v in &self.BFBPHDKHHKO {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyGamePlaySettleNotify {
        TrainPartyGamePlaySettleNotify::new()
    }

    fn clear(&mut self) {
        self.passenger_persistent.clear();
        self.attempts = 0;
        self.room_unlock = 0;
        self.BFBPHDKHHKO.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyGamePlaySettleNotify {
        static instance: TrainPartyGamePlaySettleNotify = TrainPartyGamePlaySettleNotify {
            passenger_persistent: ::protobuf::MessageField::none(),
            attempts: 0,
            room_unlock: 0,
            BFBPHDKHHKO: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyGamePlaySettleNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyGamePlaySettleNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyGamePlaySettleNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyGamePlaySettleNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyGamePlayStartCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyGamePlayStartCsReq {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyGamePlayStartCsReq.passenger_data_list)
    pub passenger_data_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:TrainPartyGamePlayStartCsReq.KNPFNNGBAIC)
    pub KNPFNNGBAIC: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyGamePlayStartCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyGamePlayStartCsReq {
    fn default() -> &'a TrainPartyGamePlayStartCsReq {
        <TrainPartyGamePlayStartCsReq as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyGamePlayStartCsReq {
    pub fn new() -> TrainPartyGamePlayStartCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "passenger_data_list",
            |m: &TrainPartyGamePlayStartCsReq| { &m.passenger_data_list },
            |m: &mut TrainPartyGamePlayStartCsReq| { &mut m.passenger_data_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "KNPFNNGBAIC",
            |m: &TrainPartyGamePlayStartCsReq| { &m.KNPFNNGBAIC },
            |m: &mut TrainPartyGamePlayStartCsReq| { &mut m.KNPFNNGBAIC },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyGamePlayStartCsReq>(
            "TrainPartyGamePlayStartCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyGamePlayStartCsReq {
    const NAME: &'static str = "TrainPartyGamePlayStartCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.passenger_data_list)?;
                },
                80 => {
                    self.passenger_data_list.push(is.read_uint32()?);
                },
                96 => {
                    self.KNPFNNGBAIC = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.passenger_data_list {
            my_size += ::protobuf::rt::uint32_size(10, *value);
        };
        if self.KNPFNNGBAIC != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.KNPFNNGBAIC);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.passenger_data_list {
            os.write_uint32(10, *v)?;
        };
        if self.KNPFNNGBAIC != 0 {
            os.write_uint32(12, self.KNPFNNGBAIC)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyGamePlayStartCsReq {
        TrainPartyGamePlayStartCsReq::new()
    }

    fn clear(&mut self) {
        self.passenger_data_list.clear();
        self.KNPFNNGBAIC = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyGamePlayStartCsReq {
        static instance: TrainPartyGamePlayStartCsReq = TrainPartyGamePlayStartCsReq {
            passenger_data_list: ::std::vec::Vec::new(),
            KNPFNNGBAIC: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyGamePlayStartCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyGamePlayStartCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyGamePlayStartCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyGamePlayStartCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyGamePlayStartScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyGamePlayStartScRsp {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyGamePlayStartScRsp.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:TrainPartyGamePlayStartScRsp.train_party_gameplay_data)
    pub train_party_gameplay_data: ::protobuf::MessageField<TrainPartyGameplayData>,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyGamePlayStartScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyGamePlayStartScRsp {
    fn default() -> &'a TrainPartyGamePlayStartScRsp {
        <TrainPartyGamePlayStartScRsp as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyGamePlayStartScRsp {
    pub fn new() -> TrainPartyGamePlayStartScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &TrainPartyGamePlayStartScRsp| { &m.retcode },
            |m: &mut TrainPartyGamePlayStartScRsp| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainPartyGameplayData>(
            "train_party_gameplay_data",
            |m: &TrainPartyGamePlayStartScRsp| { &m.train_party_gameplay_data },
            |m: &mut TrainPartyGamePlayStartScRsp| { &mut m.train_party_gameplay_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyGamePlayStartScRsp>(
            "TrainPartyGamePlayStartScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyGamePlayStartScRsp {
    const NAME: &'static str = "TrainPartyGamePlayStartScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.retcode = is.read_uint32()?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.train_party_gameplay_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.retcode);
        }
        if let Some(v) = self.train_party_gameplay_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(2, self.retcode)?;
        }
        if let Some(v) = self.train_party_gameplay_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyGamePlayStartScRsp {
        TrainPartyGamePlayStartScRsp::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.train_party_gameplay_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyGamePlayStartScRsp {
        static instance: TrainPartyGamePlayStartScRsp = TrainPartyGamePlayStartScRsp {
            retcode: 0,
            train_party_gameplay_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyGamePlayStartScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyGamePlayStartScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyGamePlayStartScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyGamePlayStartScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyUpdatePosEnvCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyUpdatePosEnvCsReq {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyUpdatePosEnvCsReq.NPKLLEHIOAL)
    pub NPKLLEHIOAL: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyUpdatePosEnvCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyUpdatePosEnvCsReq {
    fn default() -> &'a TrainPartyUpdatePosEnvCsReq {
        <TrainPartyUpdatePosEnvCsReq as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyUpdatePosEnvCsReq {
    pub fn new() -> TrainPartyUpdatePosEnvCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NPKLLEHIOAL",
            |m: &TrainPartyUpdatePosEnvCsReq| { &m.NPKLLEHIOAL },
            |m: &mut TrainPartyUpdatePosEnvCsReq| { &mut m.NPKLLEHIOAL },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyUpdatePosEnvCsReq>(
            "TrainPartyUpdatePosEnvCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyUpdatePosEnvCsReq {
    const NAME: &'static str = "TrainPartyUpdatePosEnvCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                96 => {
                    self.NPKLLEHIOAL = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.NPKLLEHIOAL != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.NPKLLEHIOAL);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.NPKLLEHIOAL != 0 {
            os.write_uint32(12, self.NPKLLEHIOAL)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyUpdatePosEnvCsReq {
        TrainPartyUpdatePosEnvCsReq::new()
    }

    fn clear(&mut self) {
        self.NPKLLEHIOAL = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyUpdatePosEnvCsReq {
        static instance: TrainPartyUpdatePosEnvCsReq = TrainPartyUpdatePosEnvCsReq {
            NPKLLEHIOAL: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyUpdatePosEnvCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyUpdatePosEnvCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyUpdatePosEnvCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyUpdatePosEnvCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyUpdatePosEnvScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyUpdatePosEnvScRsp {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyUpdatePosEnvScRsp.NPKLLEHIOAL)
    pub NPKLLEHIOAL: u32,
    // @@protoc_insertion_point(field:TrainPartyUpdatePosEnvScRsp.retcode)
    pub retcode: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyUpdatePosEnvScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyUpdatePosEnvScRsp {
    fn default() -> &'a TrainPartyUpdatePosEnvScRsp {
        <TrainPartyUpdatePosEnvScRsp as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyUpdatePosEnvScRsp {
    pub fn new() -> TrainPartyUpdatePosEnvScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NPKLLEHIOAL",
            |m: &TrainPartyUpdatePosEnvScRsp| { &m.NPKLLEHIOAL },
            |m: &mut TrainPartyUpdatePosEnvScRsp| { &mut m.NPKLLEHIOAL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &TrainPartyUpdatePosEnvScRsp| { &m.retcode },
            |m: &mut TrainPartyUpdatePosEnvScRsp| { &mut m.retcode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyUpdatePosEnvScRsp>(
            "TrainPartyUpdatePosEnvScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyUpdatePosEnvScRsp {
    const NAME: &'static str = "TrainPartyUpdatePosEnvScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.NPKLLEHIOAL = is.read_uint32()?;
                },
                72 => {
                    self.retcode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.NPKLLEHIOAL != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.NPKLLEHIOAL);
        }
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.retcode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.NPKLLEHIOAL != 0 {
            os.write_uint32(3, self.NPKLLEHIOAL)?;
        }
        if self.retcode != 0 {
            os.write_uint32(9, self.retcode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyUpdatePosEnvScRsp {
        TrainPartyUpdatePosEnvScRsp::new()
    }

    fn clear(&mut self) {
        self.NPKLLEHIOAL = 0;
        self.retcode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyUpdatePosEnvScRsp {
        static instance: TrainPartyUpdatePosEnvScRsp = TrainPartyUpdatePosEnvScRsp {
            NPKLLEHIOAL: 0,
            retcode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyUpdatePosEnvScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyUpdatePosEnvScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyUpdatePosEnvScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyUpdatePosEnvScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyAddBuildDynamicBuffCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyAddBuildDynamicBuffCsReq {
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyAddBuildDynamicBuffCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyAddBuildDynamicBuffCsReq {
    fn default() -> &'a TrainPartyAddBuildDynamicBuffCsReq {
        <TrainPartyAddBuildDynamicBuffCsReq as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyAddBuildDynamicBuffCsReq {
    pub fn new() -> TrainPartyAddBuildDynamicBuffCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyAddBuildDynamicBuffCsReq>(
            "TrainPartyAddBuildDynamicBuffCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyAddBuildDynamicBuffCsReq {
    const NAME: &'static str = "TrainPartyAddBuildDynamicBuffCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyAddBuildDynamicBuffCsReq {
        TrainPartyAddBuildDynamicBuffCsReq::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyAddBuildDynamicBuffCsReq {
        static instance: TrainPartyAddBuildDynamicBuffCsReq = TrainPartyAddBuildDynamicBuffCsReq {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyAddBuildDynamicBuffCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyAddBuildDynamicBuffCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyAddBuildDynamicBuffCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyAddBuildDynamicBuffCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyAddBuildDynamicBuffScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyAddBuildDynamicBuffScRsp {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyAddBuildDynamicBuffScRsp.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:TrainPartyAddBuildDynamicBuffScRsp.buff_id)
    pub buff_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyAddBuildDynamicBuffScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyAddBuildDynamicBuffScRsp {
    fn default() -> &'a TrainPartyAddBuildDynamicBuffScRsp {
        <TrainPartyAddBuildDynamicBuffScRsp as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyAddBuildDynamicBuffScRsp {
    pub fn new() -> TrainPartyAddBuildDynamicBuffScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &TrainPartyAddBuildDynamicBuffScRsp| { &m.retcode },
            |m: &mut TrainPartyAddBuildDynamicBuffScRsp| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buff_id",
            |m: &TrainPartyAddBuildDynamicBuffScRsp| { &m.buff_id },
            |m: &mut TrainPartyAddBuildDynamicBuffScRsp| { &mut m.buff_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyAddBuildDynamicBuffScRsp>(
            "TrainPartyAddBuildDynamicBuffScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyAddBuildDynamicBuffScRsp {
    const NAME: &'static str = "TrainPartyAddBuildDynamicBuffScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.retcode = is.read_uint32()?;
                },
                48 => {
                    self.buff_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.retcode);
        }
        if self.buff_id != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.buff_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(1, self.retcode)?;
        }
        if self.buff_id != 0 {
            os.write_uint32(6, self.buff_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyAddBuildDynamicBuffScRsp {
        TrainPartyAddBuildDynamicBuffScRsp::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.buff_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyAddBuildDynamicBuffScRsp {
        static instance: TrainPartyAddBuildDynamicBuffScRsp = TrainPartyAddBuildDynamicBuffScRsp {
            retcode: 0,
            buff_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyAddBuildDynamicBuffScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyAddBuildDynamicBuffScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyAddBuildDynamicBuffScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyAddBuildDynamicBuffScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyTakeBuildLevelAwardCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyTakeBuildLevelAwardCsReq {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyTakeBuildLevelAwardCsReq.BJFLLFADCIH)
    pub BJFLLFADCIH: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyTakeBuildLevelAwardCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyTakeBuildLevelAwardCsReq {
    fn default() -> &'a TrainPartyTakeBuildLevelAwardCsReq {
        <TrainPartyTakeBuildLevelAwardCsReq as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyTakeBuildLevelAwardCsReq {
    pub fn new() -> TrainPartyTakeBuildLevelAwardCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "BJFLLFADCIH",
            |m: &TrainPartyTakeBuildLevelAwardCsReq| { &m.BJFLLFADCIH },
            |m: &mut TrainPartyTakeBuildLevelAwardCsReq| { &mut m.BJFLLFADCIH },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyTakeBuildLevelAwardCsReq>(
            "TrainPartyTakeBuildLevelAwardCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyTakeBuildLevelAwardCsReq {
    const NAME: &'static str = "TrainPartyTakeBuildLevelAwardCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                96 => {
                    self.BJFLLFADCIH = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.BJFLLFADCIH != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.BJFLLFADCIH);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.BJFLLFADCIH != 0 {
            os.write_uint32(12, self.BJFLLFADCIH)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyTakeBuildLevelAwardCsReq {
        TrainPartyTakeBuildLevelAwardCsReq::new()
    }

    fn clear(&mut self) {
        self.BJFLLFADCIH = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyTakeBuildLevelAwardCsReq {
        static instance: TrainPartyTakeBuildLevelAwardCsReq = TrainPartyTakeBuildLevelAwardCsReq {
            BJFLLFADCIH: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyTakeBuildLevelAwardCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyTakeBuildLevelAwardCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyTakeBuildLevelAwardCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyTakeBuildLevelAwardCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrainPartyTakeBuildLevelAwardScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainPartyTakeBuildLevelAwardScRsp {
    // message fields
    // @@protoc_insertion_point(field:TrainPartyTakeBuildLevelAwardScRsp.item_list)
    pub item_list: ::protobuf::MessageField<super::ItemList::ItemList>,
    // @@protoc_insertion_point(field:TrainPartyTakeBuildLevelAwardScRsp.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:TrainPartyTakeBuildLevelAwardScRsp.BJFLLFADCIH)
    pub BJFLLFADCIH: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TrainPartyTakeBuildLevelAwardScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainPartyTakeBuildLevelAwardScRsp {
    fn default() -> &'a TrainPartyTakeBuildLevelAwardScRsp {
        <TrainPartyTakeBuildLevelAwardScRsp as ::protobuf::Message>::default_instance()
    }
}

impl TrainPartyTakeBuildLevelAwardScRsp {
    pub fn new() -> TrainPartyTakeBuildLevelAwardScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::ItemList::ItemList>(
            "item_list",
            |m: &TrainPartyTakeBuildLevelAwardScRsp| { &m.item_list },
            |m: &mut TrainPartyTakeBuildLevelAwardScRsp| { &mut m.item_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &TrainPartyTakeBuildLevelAwardScRsp| { &m.retcode },
            |m: &mut TrainPartyTakeBuildLevelAwardScRsp| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "BJFLLFADCIH",
            |m: &TrainPartyTakeBuildLevelAwardScRsp| { &m.BJFLLFADCIH },
            |m: &mut TrainPartyTakeBuildLevelAwardScRsp| { &mut m.BJFLLFADCIH },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainPartyTakeBuildLevelAwardScRsp>(
            "TrainPartyTakeBuildLevelAwardScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainPartyTakeBuildLevelAwardScRsp {
    const NAME: &'static str = "TrainPartyTakeBuildLevelAwardScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.item_list)?;
                },
                104 => {
                    self.retcode = is.read_uint32()?;
                },
                96 => {
                    self.BJFLLFADCIH = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(13, self.retcode);
        }
        if self.BJFLLFADCIH != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.BJFLLFADCIH);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_list.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.retcode != 0 {
            os.write_uint32(13, self.retcode)?;
        }
        if self.BJFLLFADCIH != 0 {
            os.write_uint32(12, self.BJFLLFADCIH)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainPartyTakeBuildLevelAwardScRsp {
        TrainPartyTakeBuildLevelAwardScRsp::new()
    }

    fn clear(&mut self) {
        self.item_list.clear();
        self.retcode = 0;
        self.BJFLLFADCIH = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainPartyTakeBuildLevelAwardScRsp {
        static instance: TrainPartyTakeBuildLevelAwardScRsp = TrainPartyTakeBuildLevelAwardScRsp {
            item_list: ::protobuf::MessageField::none(),
            retcode: 0,
            BJFLLFADCIH: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainPartyTakeBuildLevelAwardScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainPartyTakeBuildLevelAwardScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainPartyTakeBuildLevelAwardScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainPartyTakeBuildLevelAwardScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TrainPartyBuildStatus)
pub enum TrainPartyBuildStatus {
    // @@protoc_insertion_point(enum_value:TrainPartyBuildStatus.BuildGoalStepNone)
    BuildGoalStepNone = 0,
    // @@protoc_insertion_point(enum_value:TrainPartyBuildStatus.BuildGoalStepIdle)
    BuildGoalStepIdle = 1,
    // @@protoc_insertion_point(enum_value:TrainPartyBuildStatus.BuildGoalStepStart)
    BuildGoalStepStart = 2,
    // @@protoc_insertion_point(enum_value:TrainPartyBuildStatus.BuildGoalStepFinish)
    BuildGoalStepFinish = 3,
}

impl ::protobuf::Enum for TrainPartyBuildStatus {
    const NAME: &'static str = "TrainPartyBuildStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TrainPartyBuildStatus> {
        match value {
            0 => ::std::option::Option::Some(TrainPartyBuildStatus::BuildGoalStepNone),
            1 => ::std::option::Option::Some(TrainPartyBuildStatus::BuildGoalStepIdle),
            2 => ::std::option::Option::Some(TrainPartyBuildStatus::BuildGoalStepStart),
            3 => ::std::option::Option::Some(TrainPartyBuildStatus::BuildGoalStepFinish),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TrainPartyBuildStatus> {
        match str {
            "BuildGoalStepNone" => ::std::option::Option::Some(TrainPartyBuildStatus::BuildGoalStepNone),
            "BuildGoalStepIdle" => ::std::option::Option::Some(TrainPartyBuildStatus::BuildGoalStepIdle),
            "BuildGoalStepStart" => ::std::option::Option::Some(TrainPartyBuildStatus::BuildGoalStepStart),
            "BuildGoalStepFinish" => ::std::option::Option::Some(TrainPartyBuildStatus::BuildGoalStepFinish),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TrainPartyBuildStatus] = &[
        TrainPartyBuildStatus::BuildGoalStepNone,
        TrainPartyBuildStatus::BuildGoalStepIdle,
        TrainPartyBuildStatus::BuildGoalStepStart,
        TrainPartyBuildStatus::BuildGoalStepFinish,
    ];
}

impl ::protobuf::EnumFull for TrainPartyBuildStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TrainPartyBuildStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TrainPartyBuildStatus {
    fn default() -> Self {
        TrainPartyBuildStatus::BuildGoalStepNone
    }
}

impl TrainPartyBuildStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TrainPartyBuildStatus>("TrainPartyBuildStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TrainPartyUpdateSrc)
pub enum TrainPartyUpdateSrc {
    // @@protoc_insertion_point(enum_value:TrainPartyUpdateSrc.kTrainPartySrcNone)
    kTrainPartySrcNone = 0,
    // @@protoc_insertion_point(enum_value:TrainPartyUpdateSrc.kTrainPartySrcCard)
    kTrainPartySrcCard = 1,
    // @@protoc_insertion_point(enum_value:TrainPartyUpdateSrc.kTrainPartySrcGrid)
    kTrainPartySrcGrid = 2,
    // @@protoc_insertion_point(enum_value:TrainPartyUpdateSrc.kTrainPartySrcPam)
    kTrainPartySrcPam = 3,
    // @@protoc_insertion_point(enum_value:TrainPartyUpdateSrc.kTrainPartySrcPassenger)
    kTrainPartySrcPassenger = 4,
    // @@protoc_insertion_point(enum_value:TrainPartyUpdateSrc.kTrainPartySrcBuilding)
    kTrainPartySrcBuilding = 5,
}

impl ::protobuf::Enum for TrainPartyUpdateSrc {
    const NAME: &'static str = "TrainPartyUpdateSrc";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TrainPartyUpdateSrc> {
        match value {
            0 => ::std::option::Option::Some(TrainPartyUpdateSrc::kTrainPartySrcNone),
            1 => ::std::option::Option::Some(TrainPartyUpdateSrc::kTrainPartySrcCard),
            2 => ::std::option::Option::Some(TrainPartyUpdateSrc::kTrainPartySrcGrid),
            3 => ::std::option::Option::Some(TrainPartyUpdateSrc::kTrainPartySrcPam),
            4 => ::std::option::Option::Some(TrainPartyUpdateSrc::kTrainPartySrcPassenger),
            5 => ::std::option::Option::Some(TrainPartyUpdateSrc::kTrainPartySrcBuilding),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TrainPartyUpdateSrc> {
        match str {
            "kTrainPartySrcNone" => ::std::option::Option::Some(TrainPartyUpdateSrc::kTrainPartySrcNone),
            "kTrainPartySrcCard" => ::std::option::Option::Some(TrainPartyUpdateSrc::kTrainPartySrcCard),
            "kTrainPartySrcGrid" => ::std::option::Option::Some(TrainPartyUpdateSrc::kTrainPartySrcGrid),
            "kTrainPartySrcPam" => ::std::option::Option::Some(TrainPartyUpdateSrc::kTrainPartySrcPam),
            "kTrainPartySrcPassenger" => ::std::option::Option::Some(TrainPartyUpdateSrc::kTrainPartySrcPassenger),
            "kTrainPartySrcBuilding" => ::std::option::Option::Some(TrainPartyUpdateSrc::kTrainPartySrcBuilding),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TrainPartyUpdateSrc] = &[
        TrainPartyUpdateSrc::kTrainPartySrcNone,
        TrainPartyUpdateSrc::kTrainPartySrcCard,
        TrainPartyUpdateSrc::kTrainPartySrcGrid,
        TrainPartyUpdateSrc::kTrainPartySrcPam,
        TrainPartyUpdateSrc::kTrainPartySrcPassenger,
        TrainPartyUpdateSrc::kTrainPartySrcBuilding,
    ];
}

impl ::protobuf::EnumFull for TrainPartyUpdateSrc {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TrainPartyUpdateSrc").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TrainPartyUpdateSrc {
    fn default() -> Self {
        TrainPartyUpdateSrc::kTrainPartySrcNone
    }
}

impl TrainPartyUpdateSrc {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TrainPartyUpdateSrc>("TrainPartyUpdateSrc")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EJLFEABGGID)
pub enum EJLFEABGGID {
    // @@protoc_insertion_point(enum_value:EJLFEABGGID.kDialogueEventNone)
    kDialogueEventNone = 0,
    // @@protoc_insertion_point(enum_value:EJLFEABGGID.kGamePlayStartDialogueEvent)
    kGamePlayStartDialogueEvent = 1,
    // @@protoc_insertion_point(enum_value:EJLFEABGGID.kGridDialogueEvent)
    kGridDialogueEvent = 2,
    // @@protoc_insertion_point(enum_value:EJLFEABGGID.kAfterMeetingDialogueEvent)
    kAfterMeetingDialogueEvent = 3,
}

impl ::protobuf::Enum for EJLFEABGGID {
    const NAME: &'static str = "EJLFEABGGID";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EJLFEABGGID> {
        match value {
            0 => ::std::option::Option::Some(EJLFEABGGID::kDialogueEventNone),
            1 => ::std::option::Option::Some(EJLFEABGGID::kGamePlayStartDialogueEvent),
            2 => ::std::option::Option::Some(EJLFEABGGID::kGridDialogueEvent),
            3 => ::std::option::Option::Some(EJLFEABGGID::kAfterMeetingDialogueEvent),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EJLFEABGGID> {
        match str {
            "kDialogueEventNone" => ::std::option::Option::Some(EJLFEABGGID::kDialogueEventNone),
            "kGamePlayStartDialogueEvent" => ::std::option::Option::Some(EJLFEABGGID::kGamePlayStartDialogueEvent),
            "kGridDialogueEvent" => ::std::option::Option::Some(EJLFEABGGID::kGridDialogueEvent),
            "kAfterMeetingDialogueEvent" => ::std::option::Option::Some(EJLFEABGGID::kAfterMeetingDialogueEvent),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EJLFEABGGID] = &[
        EJLFEABGGID::kDialogueEventNone,
        EJLFEABGGID::kGamePlayStartDialogueEvent,
        EJLFEABGGID::kGridDialogueEvent,
        EJLFEABGGID::kAfterMeetingDialogueEvent,
    ];
}

impl ::protobuf::EnumFull for EJLFEABGGID {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EJLFEABGGID").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EJLFEABGGID {
    fn default() -> Self {
        EJLFEABGGID::kDialogueEventNone
    }
}

impl EJLFEABGGID {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EJLFEABGGID>("EJLFEABGGID")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TrainPartyMtSkillType)
pub enum TrainPartyMtSkillType {
    // @@protoc_insertion_point(enum_value:TrainPartyMtSkillType.kMtSkillNone)
    kMtSkillNone = 0,
    // @@protoc_insertion_point(enum_value:TrainPartyMtSkillType.kMtSkillModifyBase)
    kMtSkillModifyBase = 1,
    // @@protoc_insertion_point(enum_value:TrainPartyMtSkillType.kMtSkillModifyRatio)
    kMtSkillModifyRatio = 2,
    // @@protoc_insertion_point(enum_value:TrainPartyMtSkillType.kMtSkillMultiplyRatio)
    kMtSkillMultiplyRatio = 3,
    // @@protoc_insertion_point(enum_value:TrainPartyMtSkillType.kMtSkillSelfDestroy)
    kMtSkillSelfDestroy = 4,
}

impl ::protobuf::Enum for TrainPartyMtSkillType {
    const NAME: &'static str = "TrainPartyMtSkillType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TrainPartyMtSkillType> {
        match value {
            0 => ::std::option::Option::Some(TrainPartyMtSkillType::kMtSkillNone),
            1 => ::std::option::Option::Some(TrainPartyMtSkillType::kMtSkillModifyBase),
            2 => ::std::option::Option::Some(TrainPartyMtSkillType::kMtSkillModifyRatio),
            3 => ::std::option::Option::Some(TrainPartyMtSkillType::kMtSkillMultiplyRatio),
            4 => ::std::option::Option::Some(TrainPartyMtSkillType::kMtSkillSelfDestroy),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TrainPartyMtSkillType> {
        match str {
            "kMtSkillNone" => ::std::option::Option::Some(TrainPartyMtSkillType::kMtSkillNone),
            "kMtSkillModifyBase" => ::std::option::Option::Some(TrainPartyMtSkillType::kMtSkillModifyBase),
            "kMtSkillModifyRatio" => ::std::option::Option::Some(TrainPartyMtSkillType::kMtSkillModifyRatio),
            "kMtSkillMultiplyRatio" => ::std::option::Option::Some(TrainPartyMtSkillType::kMtSkillMultiplyRatio),
            "kMtSkillSelfDestroy" => ::std::option::Option::Some(TrainPartyMtSkillType::kMtSkillSelfDestroy),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TrainPartyMtSkillType] = &[
        TrainPartyMtSkillType::kMtSkillNone,
        TrainPartyMtSkillType::kMtSkillModifyBase,
        TrainPartyMtSkillType::kMtSkillModifyRatio,
        TrainPartyMtSkillType::kMtSkillMultiplyRatio,
        TrainPartyMtSkillType::kMtSkillSelfDestroy,
    ];
}

impl ::protobuf::EnumFull for TrainPartyMtSkillType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TrainPartyMtSkillType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TrainPartyMtSkillType {
    fn default() -> Self {
        TrainPartyMtSkillType::kMtSkillNone
    }
}

impl TrainPartyMtSkillType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TrainPartyMtSkillType>("TrainPartyMtSkillType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TrainPartyMtCategory)
pub enum TrainPartyMtCategory {
    // @@protoc_insertion_point(enum_value:TrainPartyMtCategory.TRAIN_PARTY_MT_CATEGORY_NONE)
    TRAIN_PARTY_MT_CATEGORY_NONE = 0,
    // @@protoc_insertion_point(enum_value:TrainPartyMtCategory.TRAIN_PARTY_MT_CATEGORY_S)
    TRAIN_PARTY_MT_CATEGORY_S = 1,
    // @@protoc_insertion_point(enum_value:TrainPartyMtCategory.TRAIN_PARTY_MT_CATEGORY_A)
    TRAIN_PARTY_MT_CATEGORY_A = 2,
    // @@protoc_insertion_point(enum_value:TrainPartyMtCategory.TRAIN_PARTY_MT_CATEGORY_B)
    TRAIN_PARTY_MT_CATEGORY_B = 3,
    // @@protoc_insertion_point(enum_value:TrainPartyMtCategory.TRAIN_PARTY_MT_CATEGORY_C)
    TRAIN_PARTY_MT_CATEGORY_C = 4,
    // @@protoc_insertion_point(enum_value:TrainPartyMtCategory.TRAIN_PARTY_MT_CATEGORY_D)
    TRAIN_PARTY_MT_CATEGORY_D = 5,
    // @@protoc_insertion_point(enum_value:TrainPartyMtCategory.TRAIN_PARTY_MT_CATEGORY_E)
    TRAIN_PARTY_MT_CATEGORY_E = 6,
    // @@protoc_insertion_point(enum_value:TrainPartyMtCategory.TRAIN_PARTY_MT_CATEGORY_F)
    TRAIN_PARTY_MT_CATEGORY_F = 7,
    // @@protoc_insertion_point(enum_value:TrainPartyMtCategory.TRAIN_PARTY_MT_CATEGORY_G)
    TRAIN_PARTY_MT_CATEGORY_G = 8,
}

impl ::protobuf::Enum for TrainPartyMtCategory {
    const NAME: &'static str = "TrainPartyMtCategory";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TrainPartyMtCategory> {
        match value {
            0 => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_NONE),
            1 => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_S),
            2 => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_A),
            3 => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_B),
            4 => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_C),
            5 => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_D),
            6 => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_E),
            7 => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_F),
            8 => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_G),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TrainPartyMtCategory> {
        match str {
            "TRAIN_PARTY_MT_CATEGORY_NONE" => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_NONE),
            "TRAIN_PARTY_MT_CATEGORY_S" => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_S),
            "TRAIN_PARTY_MT_CATEGORY_A" => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_A),
            "TRAIN_PARTY_MT_CATEGORY_B" => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_B),
            "TRAIN_PARTY_MT_CATEGORY_C" => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_C),
            "TRAIN_PARTY_MT_CATEGORY_D" => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_D),
            "TRAIN_PARTY_MT_CATEGORY_E" => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_E),
            "TRAIN_PARTY_MT_CATEGORY_F" => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_F),
            "TRAIN_PARTY_MT_CATEGORY_G" => ::std::option::Option::Some(TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_G),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TrainPartyMtCategory] = &[
        TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_NONE,
        TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_S,
        TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_A,
        TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_B,
        TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_C,
        TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_D,
        TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_E,
        TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_F,
        TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_G,
    ];
}

impl ::protobuf::EnumFull for TrainPartyMtCategory {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TrainPartyMtCategory").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TrainPartyMtCategory {
    fn default() -> Self {
        TrainPartyMtCategory::TRAIN_PARTY_MT_CATEGORY_NONE
    }
}

impl TrainPartyMtCategory {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TrainPartyMtCategory>("TrainPartyMtCategory")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10TrainParty.proto\x1a\x0eItemList.proto\"\x91\x01\n\x12TrainPartyCa\
    rdData\x12\x1b\n\tunique_id\x18\x0b\x20\x01(\rR\x08uniqueId\x12\x20\n\
    \x0bHMKMKBELCLG\x18\t\x20\x03(\rR\x0bHMKMKBELCLG\x12#\n\rupgrade_level\
    \x18\x05\x20\x01(\rR\x0cupgradeLevel\x12\x17\n\x07card_id\x18\x06\x20\
    \x01(\rR\x06cardId\"L\n\x0fTrainPartyCards\x129\n\x0ecard_data_list\x18\
    \x0b\x20\x03(\x0b2\x13.TrainPartyCardDataR\x0ccardDataList\"\xb8\x01\n\
    \x0eTrainPartyCard\x12\x1f\n\x0bextra_ratio\x18\x01\x20\x01(\rR\nextraRa\
    tio\x126\n\x0ecard_data_list\x18\r\x20\x01(\x0b2\x10.TrainPartyCardsR\
    \x0ccardDataList\x12M\n$has_modify_all_passenger_stat_effect\x18\x0e\x20\
    \x01(\x08R\x1fhasModifyAllPassengerStatEffect\"\x97\x01\n\x12TrainPartyG\
    ridData\x12\x20\n\x0bGAEIOFOPLFN\x18\x06\x20\x01(\rR\x0bGAEIOFOPLFN\x12\
    \x20\n\x0bGCIMMFIDPJP\x18\x02\x20\x01(\rR\x0bGCIMMFIDPJP\x12\x20\n\x0bBP\
    GOFIPCNLA\x18\x08\x20\x01(\rR\x0bBPGOFIPCNLA\x12\x1b\n\tunique_id\x18\
    \x0b\x20\x01(\rR\x08uniqueId\"\xe8\x01\n\x1aTrainPartyMeetingCountInfo\
    \x12\x20\n\x0bAADBGCLODKK\x18\x06\x20\x01(\rR\x0bAADBGCLODKK\x12\x20\n\
    \x0bHLIDPIFAJCG\x18\x0f\x20\x03(\rR\x0bHLIDPIFAJCG\x12\x20\n\x0bAOJBNMEE\
    CHF\x18\x02\x20\x01(\rR\x0bAOJBNMEECHF\x12\x20\n\x0bDFNCNGPDILM\x18\x0b\
    \x20\x01(\rR\x0bDFNCNGPDILM\x12\x20\n\x0bEPALCFOJBKJ\x18\x04\x20\x01(\rR\
    \x0bEPALCFOJBKJ\x12\x20\n\x0bECFPFKNJINA\x18\n\x20\x01(\rR\x0bECFPFKNJIN\
    A\"\xd7\x01\n\x0fTrainPartyGrids\x12\x20\n\x0bOOPDLCMLKKL\x18\x04\x20\
    \x01(\rR\x0bOOPDLCMLKKL\x12\x20\n\x0bNOFPLBABCCB\x18\x0b\x20\x01(\rR\x0b\
    NOFPLBABCCB\x12I\n\x12meeting_count_info\x18\t\x20\x01(\x0b2\x1b.TrainPa\
    rtyMeetingCountInfoR\x10meetingCountInfo\x125\n\x0bANPNJEKLCJJ\x18\x02\
    \x20\x03(\x0b2\x13.TrainPartyGridDataR\x0bANPNJEKLCJJ\"c\n\x1dTrainParty\
    PassengerStatusInfo\x12\x20\n\x0bDDELOEPNMPM\x18\x02\x20\x01(\rR\x0bDDEL\
    OEPNMPM\x12\x20\n\x0bKLAAHPFNMHP\x18\r\x20\x01(\rR\x0bKLAAHPFNMHP\"\x84\
    \x01\n\x1cTrainPartyPassengerSkillInfo\x12\x20\n\x0bMOCKIOPKEKE\x18\x08\
    \x20\x01(\rR\x0bMOCKIOPKEKE\x12\x20\n\x0bNCPFPAMHAOE\x18\x06\x20\x01(\rR\
    \x0bNCPFPAMHAOE\x12\x20\n\x0bFIIDGPNOEDE\x18\x05\x20\x01(\rR\x0bFIIDGPNO\
    EDE\"\x9f\x01\n\x17TrainPartyPassengerData\x12\x20\n\x0bDIKPBINAOOH\x18\
    \x0b\x20\x01(\rR\x0bDIKPBINAOOH\x12!\n\x0cpassenger_id\x18\n\x20\x01(\rR\
    \x0bpassengerId\x12?\n\x0bstatus_info\x18\x03\x20\x01(\x0b2\x1e.TrainPar\
    tyPassengerStatusInfoR\nstatusInfo\"\xac\x01\n!TrainPartyPassengerPersis\
    tentData\x12\x1a\n\x08attempts\x18\x0c\x20\x01(\rR\x08attempts\x12\x20\n\
    \x0bDNGLGOMMFNP\x18\x0b\x20\x01(\x08R\x0bDNGLGOMMFNP\x12&\n\x0fdiary_dat\
    a_list\x18\x05\x20\x03(\rR\rdiaryDataList\x12!\n\x0cpassenger_id\x18\x08\
    \x20\x01(\rR\x0bpassengerId\"\xb1\x02\n\x13TrainPartyPassenger\x12\x20\n\
    \x0bNINMOLKELOE\x18\x0f\x20\x01(\rR\x0bNINMOLKELOE\x12H\n\x13passenger_d\
    ata_list\x18\x0e\x20\x03(\x0b2\x18.TrainPartyPassengerDataR\x11passenger\
    DataList\x12#\n\rupgrade_level\x18\x03\x20\x01(\rR\x0cupgradeLevel\x12\
    \x20\n\x0bFGAGEPHCGGI\x18\x05\x20\x01(\rR\x0bFGAGEPHCGGI\x12E\n\x0fskill\
    _info_list\x18\x08\x20\x03(\x0b2\x1d.TrainPartyPassengerSkillInfoR\rskil\
    lInfoList\x12\x20\n\x0bMNDKAKMGDPH\x18\x07\x20\x03(\rR\x0bMNDKAKMGDPH\"\
    \x88\x01\n\x1dTrainPartyPersistentPassenger\x12g\n\x1epassenger_persiste\
    nt_data_list\x18\x02\x20\x03(\x0b2\".TrainPartyPassengerPersistentDataR\
    \x1bpassengerPersistentDataList\"\xb3\x02\n\x12TrainPartyAreaInfo\x12\
    \x17\n\x07area_id\x18\r\x20\x01(\rR\x06areaId\x12@\n\x0fbuild_slot_list\
    \x18\x02\x20\x03(\x0b2\x18.TrainPartyBuildSlotInfoR\rbuildSlotList\x12\
    \x20\n\x0cstep_id_list\x18\x0b\x20\x03(\rR\nstepIdList\x12\x1d\n\nstep_p\
    ages\x18\x0f\x20\x03(\rR\tstepPages\x12\x1a\n\x08progress\x18\x0e\x20\
    \x01(\rR\x08progress\x127\n\nbuild_goal\x18\x04\x20\x01(\x0b2\x18.TrainP\
    artyBuildGoalDataR\tbuildGoal\x12,\n\x12static_config_list\x18\x08\x20\
    \x03(\rR\x10staticConfigList\"E\n\x0bHHOKBPHNFNE\x12\x1d\n\nstep_pages\
    \x18\x05\x20\x03(\rR\tstepPages\x12\x17\n\x07area_id\x18\t\x20\x01(\rR\
    \x06areaId\"\x84\x01\n\x17TrainPartyBuildStepInfo\x12.\n\x06status\x18\
    \x0b\x20\x01(\x0e2\x16.TrainPartyBuildStatusR\x06status\x12\x17\n\x07ste\
    p_id\x18\x01\x20\x01(\rR\x06stepId\x12\x20\n\x0bMJALJMGLEFP\x18\x07\x20\
    \x01(\rR\x0bMJALJMGLEFP\"t\n\x17TrainPartyBuildGoalData\x12@\n\x0fbuild_\
    step_list\x18\x07\x20\x03(\x0b2\x18.TrainPartyBuildStepInfoR\rbuildStepL\
    ist\x12\x17\n\x07goal_id\x18\x0b\x20\x01(\rR\x06goalId\"Z\n\x17TrainPart\
    yBuildSlotInfo\x12\x17\n\x07slot_id\x18\x06\x20\x01(\rR\x06slotId\x12&\n\
    \x0fdynamic_prop_id\x18\x0b\x20\x01(\rR\rdynamicPropId\"\x93\x03\n\x13Tr\
    ainPartyBuildInfo\x129\n\x0earea_info_list\x18\x0c\x20\x03(\x0b2\x13.Tra\
    inPartyAreaInfoR\x0careaInfoList\x12\x14\n\x05funds\x18\x02\x20\x01(\rR\
    \x05funds\x12%\n\x0ebuild_progress\x18\x05\x20\x01(\rR\rbuildProgress\
    \x12.\n\x0bNNBHLDDNLDE\x18\x08\x20\x03(\x0b2\x0c.HHOKBPHNFNER\x0bNNBHLDD\
    NLDE\x12\x20\n\x0bCFJKBJHNIJM\x18\x0e\x20\x01(\rR\x0bCFJKBJHNIJM\x12\x1f\
    \n\x0bbuild_level\x18\x06\x20\x01(\rR\nbuildLevel\x12\x20\n\x0bKCFEECACM\
    OD\x18\n\x20\x03(\rR\x0bKCFEECACMOD\x12\x20\n\x0bCDJFDJIAING\x18\x01\x20\
    \x01(\rR\x0bCDJFDJIAING\x12.\n\x13dynamic_config_list\x18\x0f\x20\x03(\r\
    R\x11dynamicConfigList\x12\x1d\n\nbuild_star\x18\r\x20\x01(\rR\tbuildSta\
    r\"\xd3\x02\n\x16TrainPartyGameInstance\x12g\n\x20train_party_persistent\
    _passenger\x18\x0b\x20\x01(\x0b2\x1e.TrainPartyPersistentPassengerR\x1dt\
    rainPartyPersistentPassenger\x12\x20\n\x0bNPKLLEHIOAL\x18\x0f\x20\x01(\r\
    R\x0bNPKLLEHIOAL\x123\n\nbuild_info\x18\n\x20\x01(\x0b2\x14.TrainPartyBu\
    ildInfoR\tbuildInfo\x12<\n\rgameplay_data\x18\t\x20\x01(\x0b2\x17.TrainP\
    artyGameplayDataR\x0cgameplayData\x12\x1f\n\x0broom_unlock\x18\x06\x20\
    \x01(\rR\nroomUnlock\x12\x1a\n\x08attempts\x18\x02\x20\x01(\rR\x08attemp\
    ts\"\xd4\x02\n\x16TrainPartyGameplayData\x129\n\x10train_party_card\x18\
    \x0f\x20\x01(\x0b2\x0f.TrainPartyCardR\x0etrainPartyCard\x12H\n\x15train\
    _party_passenger\x18\n\x20\x01(\x0b2\x14.TrainPartyPassengerR\x13trainPa\
    rtyPassenger\x12\x20\n\x0bKNPFNNGBAIC\x18\x05\x20\x01(\rR\x0bKNPFNNGBAIC\
    \x12<\n\x11train_party_grids\x18\x07\x20\x01(\x0b2\x10.TrainPartyGridsR\
    \x0ftrainPartyGrids\x12U\n\x1atrain_party_pending_action\x18\x04\x20\x01\
    (\x0b2\x18.TrainPartyPendingActionR\x17trainPartyPendingAction\"\x18\n\
    \x16TrainPartyGetDataCsReq\"\x86\x01\n\x16TrainPartyGetDataScRsp\x12R\n\
    \x19train_party_game_instance\x18\x08\x20\x01(\x0b2\x17.TrainPartyGameIn\
    stanceR\x16trainPartyGameInstance\x12\x18\n\x07retcode\x18\x02\x20\x01(\
    \rR\x07retcode\"8\n\x16TrainPartyUseCardCsReq\x12\x1e\n\x0buse_card_id\
    \x18\r\x20\x01(\rR\tuseCardId\"R\n\x16TrainPartyUseCardScRsp\x12\x1e\n\
    \x0buse_card_id\x18\x01\x20\x01(\rR\tuseCardId\x12\x18\n\x07retcode\x18\
    \x06\x20\x01(\rR\x07retcode\"u\n\x16TrainPartyMoveScNotify\x12\x20\n\x0b\
    ONDGNPKGJCB\x18\x04\x20\x01(\rR\x0bONDGNPKGJCB\x129\n\x0egrid_data_list\
    \x18\x08\x20\x03(\x0b2\x13.TrainPartyGridDataR\x0cgridDataList\"\x86\x01\
    \n\x16TrainPartySettleNotify\x12L\n\x17train_party_settle_data\x18\x04\
    \x20\x01(\x0b2\x15.TrainPartySettleDataR\x14trainPartySettleData\x12\x1e\
    \n\x0buse_card_id\x18\x0b\x20\x01(\rR\tuseCardId\"\xc9\x01\n\x14TrainPar\
    tySettleData\x12E\n\x12settle_record_list\x18\n\x20\x03(\x0b2\x17.TrainP\
    artySettleRecordR\x10settleRecordList\x12\x20\n\x0bKIPKPPEDOJP\x18\x0f\
    \x20\x01(\rR\x0bKIPKPPEDOJP\x12H\n\x13passenger_data_list\x18\x08\x20\
    \x03(\x0b2\x18.TrainPartyPassengerDataR\x11passengerDataList\"Y\n\x16Tra\
    inPartySettleRecord\x12\x20\n\x0bAOMFDNHANFA\x18\x04\x20\x01(\rR\x0bAOMF\
    DNHANFA\x12\x1d\n\nparam_list\x18\x0e\x20\x03(\rR\tparamList\"U\n\x0bJDG\
    AOCPJEPL\x12F\n\x15train_party_card_data\x18\n\x20\x01(\x0b2\x13.TrainPa\
    rtyCardDataR\x12trainPartyCardData\"q\n\x0bCBNHKHEFEFF\x12!\n\x0cpasseng\
    er_id\x18\x01\x20\x01(\rR\x0bpassengerId\x12?\n\x0bstatus_info\x18\x0b\
    \x20\x01(\x0b2\x1e.TrainPartyPassengerStatusInfoR\nstatusInfo\"=\n\x0bBF\
    FIEMJEDIL\x12.\n\x0bKEHPCCGPFAD\x18\x05\x20\x03(\x0b2\x0c.CBNHKHEFEFFR\
    \x0bKEHPCCGPFAD\"N\n\x0bMINMHDAEEHH\x12?\n\x0epending_action\x18\x01\x20\
    \x01(\x0b2\x18.TrainPartyPendingActionR\rpendingAction\"2\n\x0bLFHKDENCE\
    CI\x12#\n\rupgrade_level\x18\x07\x20\x01(\rR\x0cupgradeLevel\"N\n\x0bLOC\
    AOOGDAMB\x12?\n\x0bMLMDEBKIGBH\x18\x0e\x20\x01(\x0b2\x1d.TrainPartyPasse\
    ngerSkillInfoR\x0bMLMDEBKIGBH\"T\n\x0bJCDCKOAPGEE\x12E\n\x0fskill_info_l\
    ist\x18\t\x20\x03(\x0b2\x1d.TrainPartyPassengerSkillInfoR\rskillInfoList\
    \"S\n\x0bKNINCLCJODM\x12D\n\x0bAAHAIIFCFNN\x18\r\x20\x01(\x0b2\".TrainPa\
    rtyPassengerPersistentDataR\x0bAAHAIIFCFNN\"D\n\x0bEKLMKFCKLAA\x125\n\
    \x0bANPNJEKLCJJ\x18\x0c\x20\x03(\x0b2\x13.TrainPartyGridDataR\x0bANPNJEK\
    LCJJ\"\xfc\x01\n\x0bNHNNJJPBOMJ\x12M\n$has_modify_all_passenger_stat_eff\
    ect\x18\x01\x20\x01(\x08R\x1fhasModifyAllPassengerStatEffect\x122\n\x0bF\
    OAFPCNJNAM\x18\x04\x20\x01(\x0b2\x10.TrainPartyCardsR\x0bFOAFPCNJNAM\x12\
    \x1f\n\x0bextra_ratio\x18\x0f\x20\x01(\rR\nextraRatio\x12I\n\x12meeting_\
    count_info\x18\x08\x20\x01(\x0b2\x1b.TrainPartyMeetingCountInfoR\x10meet\
    ingCountInfo\"\x9b\x04\n\x14TrainPartyUpdateInfo\x125\n\x0bFOAFPCNJNAM\
    \x18\x99\x0f\x20\x01(\x0b2\x10.TrainPartyCardsH\0R\x0bFOAFPCNJNAM\x121\n\
    \x0bIHKAOGHIMDN\x18\xa9\r\x20\x01(\x0b2\x0c.BFFIEMJEDILH\0R\x0bIHKAOGHIM\
    DN\x121\n\x0bGJKIGLGOOAF\x18\xbd\x08\x20\x01(\x0b2\x0c.MINMHDAEEHHH\0R\
    \x0bGJKIGLGOOAF\x121\n\x0bEEAFEPKNKMI\x18\x95\x05\x20\x01(\x0b2\x0c.LFHK\
    DENCECIH\0R\x0bEEAFEPKNKMI\x121\n\x0bLKCLGKLDNHE\x18\x8b\x0c\x20\x01(\
    \x0b2\x0c.EKLMKFCKLAAH\0R\x0bLKCLGKLDNHE\x121\n\x0bIDMPFCHCPHO\x18\xc8\
    \x06\x20\x01(\x0b2\x0c.LOCAOOGDAMBH\0R\x0bIDMPFCHCPHO\x121\n\x0bCKECMALE\
    PAA\x18\xee\n\x20\x01(\x0b2\x0c.NHNNJJPBOMJH\0R\x0bCKECMALEPAA\x120\n\
    \x0bNCLOBABIAHI\x18O\x20\x01(\x0b2\x0c.JCDCKOAPGEEH\0R\x0bNCLOBABIAHI\
    \x121\n\x0bAPGDKAPIMGF\x18\x8c\x06\x20\x01(\x0b2\x0c.KNINCLCJODMH\0R\x0b\
    APGDKAPIMGF\x12&\n\x03src\x18\r\x20\x01(\x0e2\x14.TrainPartyUpdateSrcR\
    \x03srcB\r\n\x0bOMNKNOLIHNB\"_\n\x1cTrainPartySyncUpdateScNotify\x12?\n\
    \x10update_info_list\x18\t\x20\x03(\x0b2\x15.TrainPartyUpdateInfoR\x0eup\
    dateInfoList\"\xb1\x02\n\x17TrainPartyPendingAction\x121\n\x0bGFLJGKBPCG\
    B\x18\xef\t\x20\x01(\x0b2\x0c.EEIADCHLFNBH\0R\x0bGFLJGKBPCGB\x121\n\x0bH\
    AKLMMJEHPF\x18\xef\x0c\x20\x01(\x0b2\x0c.BOMJDHMAAJMH\0R\x0bHAKLMMJEHPF\
    \x12;\n\x0bJJFGCDEHMPF\x18\x9a\x03\x20\x01(\x0b2\x16.TrainPartyMeetingDa\
    taH\0R\x0bJJFGCDEHMPF\x12B\n\x0bEPPNHJCNFCI\x18\x9f\x04\x20\x01(\x0b2\
    \x1d.TrainPartyReplaceSkillActionH\0R\x0bEPPNHJCNFCI\x12\x20\n\x0bLMFHNE\
    LKFOC\x18\x07\x20\x01(\rR\x0bLMFHNELKFOCB\r\n\x0bMHJAPKEOAIK\"Q\n\x0bJIG\
    MPADFPHE\x12\x20\n\x0bPBALFFCFPJD\x18\n\x20\x01(\rR\x0bPBALFFCFPJD\x12\
    \x20\n\x0bHJCGEIDBICC\x18\x05\x20\x01(\x08R\x0bHJCGEIDBICC\"\x88\x01\n\
    \x0bEEIADCHLFNB\x12.\n\x0bKJCDHKMKOPK\x18\x0e\x20\x03(\x0b2\x0c.JIGMPADF\
    PHER\x0bKJCDHKMKOPK\x12.\n\x0bAFOAGCODJLK\x18\x0c\x20\x01(\x0e2\x0c.EJLF\
    EABGGIDR\x0bAFOAGCODJLK\x12\x19\n\x08event_id\x18\n\x20\x01(\rR\x07event\
    Id\"/\n\x0bNIBBILKHHHE\x12\x20\n\x0bPBALFFCFPJD\x18\x06\x20\x01(\rR\x0bP\
    BALFFCFPJD\"g\n\x0bKBFEOIAJLJC\x12\x20\n\x0bNCPFPAMHAOE\x18\x0e\x20\x01(\
    \rR\x0bNCPFPAMHAOE\x12\x20\n\x0bMOCKIOPKEKE\x18\x06\x20\x01(\rR\x0bMOCKI\
    OPKEKE\x12\x14\n\x05level\x18\x07\x20\x01(\rR\x05level\"`\n\x0bBOMJDHMAA\
    JM\x12!\n\x0cpassenger_id\x18\x0c\x20\x01(\rR\x0bpassengerId\x12.\n\x0bK\
    LBCINEMHBD\x18\x04\x20\x03(\x0b2\x0c.KBFEOIAJLJCR\x0bKLBCINEMHBD\"\x8f\
    \x01\n\x1cTrainPartyReplaceSkillAction\x12\x20\n\x0bCKHOODLCGPK\x18\r\
    \x20\x01(\rR\x0bCKHOODLCGPK\x12M\n\x13replaced_skill_list\x18\x0f\x20\
    \x03(\x0b2\x1d.TrainPartyPassengerSkillInfoR\x11replacedSkillList\"/\n\
    \x0bICMFJIEIEBM\x12\x20\n\x0bEJALDBPBMPI\x18\x02\x20\x01(\rR\x0bEJALDBPB\
    MPI\"k\n\"TrainPartyReplaceSkillActionResult\x12E\n\x0fskill_info_list\
    \x18\x07\x20\x03(\x0b2\x1d.TrainPartyPassengerSkillInfoR\rskillInfoList\
    \"\x86\x01\n\"TrainPartyMeetingPassengerCardInfo\x12\x1b\n\tunique_id\
    \x18\n\x20\x01(\rR\x08uniqueId\x12\x20\n\x0bDDELOEPNMPM\x18\x06\x20\x01(\
    \rR\x0bDDELOEPNMPM\x12!\n\x0cpassenger_id\x18\x02\x20\x01(\rR\x0bpasseng\
    erId\"T\n\x1dTrainPartyMeetingLeftCardInfo\x12\x10\n\x03num\x18\x06\x20\
    \x01(\rR\x03num\x12!\n\x0cpassenger_id\x18\x0b\x20\x01(\rR\x0bpassengerI\
    d\"\x95\x03\n\x15TrainPartyMeetingData\x12\x20\n\x0bDEABGMBGMPP\x18\n\
    \x20\x01(\rR\x0bDEABGMBGMPP\x12M\n\x13left_card_info_list\x18\x04\x20\
    \x03(\x0b2\x1e.TrainPartyMeetingLeftCardInfoR\x10leftCardInfoList\x12\
    \x20\n\x0bPCHFKBKLDMJ\x18\x08\x20\x01(\rR\x0bPCHFKBKLDMJ\x12\x20\n\x0bOA\
    DOFHHHOEJ\x18\x0b\x20\x01(\rR\x0bOADOFHHHOEJ\x12\x20\n\x0bEKDNBEKFECL\
    \x18\x07\x20\x01(\rR\x0bEKDNBEKFECL\x12.\n\x0bAAGJLMHLJPK\x18\x02\x20\
    \x03(\x0b2\x0c.KHIIKMDCABJR\x0bAAGJLMHLJPK\x12S\n\x13passenger_card_list\
    \x18\x06\x20\x03(\x0b2#.TrainPartyMeetingPassengerCardInfoR\x11passenger\
    CardList\x12\x20\n\x0bBHKMEGPLPFA\x18\x05\x20\x01(\rR\x0bBHKMEGPLPFA\"\
    \x83\x01\n\x0ePlaySkillBrief\x125\n\nskill_type\x18\x05\x20\x01(\x0e2\
    \x16.TrainPartyMtSkillTypeR\tskillType\x12\x19\n\x08skill_id\x18\x04\x20\
    \x01(\rR\x07skillId\x12\x1f\n\x0bskill_param\x18\x02\x20\x01(\rR\nskillP\
    aram\"\x86\x01\n\rPlayCardBrief\x12\x1d\n\nbase_value\x18\x06\x20\x01(\r\
    R\tbaseValue\x12\x1b\n\tunique_id\x18\n\x20\x01(\rR\x08uniqueId\x129\n\
    \x10skill_brief_list\x18\x07\x20\x03(\x0b2\x0f.PlaySkillBriefR\x0eskillB\
    riefList\"\x90\x01\n\x1dTrainPartyMeetingSettleResult\x12+\n\x0bJPCFLGNM\
    COL\x18\x06\x20\x01(\x0b2\t.ItemListR\x0bJPCFLGNMCOL\x12\x20\n\x0bOGEFFH\
    HNMLE\x18\x08\x20\x01(\rR\x0bOGEFFHHNMLE\x12\x20\n\x0bJAMJNDMKMJI\x18\
    \x07\x20\x03(\rR\x0bJAMJNDMKMJI\"/\n\x0bHPIPKEEKBDO\x12\x20\n\x0bCAEFKFM\
    HLEC\x18\x01\x20\x03(\rR\x0bCAEFKFMHLEC\"\xe4\x04\n\x1cTrainPartyMeeting\
    UseCardInfo\x12S\n\x13passenger_card_list\x18\x06\x20\x03(\x0b2#.TrainPa\
    rtyMeetingPassengerCardInfoR\x11passengerCardList\x12\x20\n\x0bPCHFKBKLD\
    MJ\x18\x0e\x20\x01(\rR\x0bPCHFKBKLDMJ\x12M\n\x13left_card_info_list\x18\
    \r\x20\x03(\x0b2\x1e.TrainPartyMeetingLeftCardInfoR\x10leftCardInfoList\
    \x12\x14\n\x05score\x18\x02\x20\x01(\rR\x05score\x120\n\x0bPKCCIHJKJPM\
    \x18\x01\x20\x03(\x0b2\x0e.PlayCardBriefR\x0bPKCCIHJKJPM\x12\x20\n\x0bEK\
    DNBEKFECL\x18\x05\x20\x01(\rR\x0bEKDNBEKFECL\x12C\n\rsettle_result\x18\
    \x08\x20\x01(\x0b2\x1e.TrainPartyMeetingSettleResultR\x0csettleResult\
    \x12I\n\x12meeting_count_info\x18\x0c\x20\x01(\x0b2\x1b.TrainPartyMeetin\
    gCountInfoR\x10meetingCountInfo\x12B\n\x15play_skill_brief_list\x18\x07\
    \x20\x03(\x0b2\x0f.PlaySkillBriefR\x12playSkillBriefList\x12@\n\x10meeti\
    ng_category\x18\x0f\x20\x01(\x0e2\x15.TrainPartyMtCategoryR\x0fmeetingCa\
    tegory\"/\n\x0bCOAOOLIBOHF\x12\x20\n\x0bCAEFKFMHLEC\x18\n\x20\x03(\rR\
    \x0bCAEFKFMHLEC\"\x94\x02\n\x19TrainPartyMeetingRollInfo\x12S\n\x13passe\
    nger_card_list\x18\x06\x20\x03(\x0b2#.TrainPartyMeetingPassengerCardInfo\
    R\x11passengerCardList\x12\x20\n\x0bDEABGMBGMPP\x18\x05\x20\x01(\rR\x0bD\
    EABGMBGMPP\x121\n\x0bJLJIDMGPCFD\x18\x0b\x20\x03(\x0b2\x0f.PlaySkillBrie\
    fR\x0bJLJIDMGPCFD\x12M\n\x13left_card_info_list\x18\x08\x20\x03(\x0b2\
    \x1e.TrainPartyMeetingLeftCardInfoR\x10leftCardInfoList\"\xa8\x02\n\"Tra\
    inPartyHandlePendingActionCsReq\x121\n\x0bGFLJGKBPCGB\x18\xe3\r\x20\x01(\
    \x0b2\x0c.NIBBILKHHHEH\0R\x0bGFLJGKBPCGB\x121\n\x0bEPPNHJCNFCI\x18\x9a\
    \x01\x20\x01(\x0b2\x0c.ICMFJIEIEBMH\0R\x0bEPPNHJCNFCI\x121\n\x0bBMOCCJHI\
    FAK\x18\x90\x05\x20\x01(\x0b2\x0c.HPIPKEEKBDOH\0R\x0bBMOCCJHIFAK\x121\n\
    \x0bMGEKAIONENB\x18\xee\x02\x20\x01(\x0b2\x0c.COAOOLIBOHFH\0R\x0bMGEKAIO\
    NENB\x12\x20\n\x0bLMFHNELKFOC\x18\x07\x20\x01(\rR\x0bLMFHNELKFOCB\x14\n\
    \x12train_party_action\"\xc9\x03\n\"TrainPartyHandlePendingActionScRsp\
    \x12X\n\x14replace_skill_action\x18\xe2\x0b\x20\x01(\x0b2#.TrainPartyRep\
    laceSkillActionResultH\0R\x12replaceSkillAction\x12G\n\x0fuse_card_actio\
    n\x18E\x20\x01(\x0b2\x1d.TrainPartyMeetingUseCardInfoH\0R\ruseCardAction\
    \x12>\n\x0broll_action\x18\xee\x02\x20\x01(\x0b2\x1a.TrainPartyMeetingRo\
    llInfoH\0R\nrollAction\x12\x20\n\x0bLFJLHJHPLGI\x18\x03\x20\x01(\x08R\
    \x0bLFJLHJHPLGI\x12L\n\x17train_party_settle_data\x18\r\x20\x01(\x0b2\
    \x15.TrainPartySettleDataR\x14trainPartySettleData\x12\x20\n\x0bLMFHNELK\
    FOC\x18\x04\x20\x01(\rR\x0bLMFHNELKFOC\x12\x18\n\x07retcode\x18\x06\x20\
    \x01(\rR\x07retcodeB\x14\n\x12train_party_action\"\xac\x01\n\x1dTrainPar\
    tyBuildStartStepCsReq\x12\x17\n\x07area_id\x18\n\x20\x01(\rR\x06areaId\
    \x12@\n\x0fbuild_slot_info\x18\x0c\x20\x01(\x0b2\x18.TrainPartyBuildSlot\
    InfoR\rbuildSlotInfo\x12\x17\n\x07step_id\x18\x0e\x20\x01(\rR\x06stepId\
    \x12\x17\n\x07goal_id\x18\x08\x20\x01(\rR\x06goalId\"O\n\x1dTrainPartyBu\
    ildStartStepScRsp\x12\x18\n\x07retcode\x18\t\x20\x01(\rR\x07retcode\x12\
    \x14\n\x05funds\x18\x02\x20\x01(\rR\x05funds\"\x95\x01\n\x17TrainPartyBu\
    ildDiyCsReq\x12\x17\n\x07area_id\x18\n\x20\x01(\rR\x06areaId\x12&\n\x0fd\
    ynamic_prop_id\x18\x04\x20\x01(\rR\rdynamicPropId\x12\x17\n\x07slot_id\
    \x18\x0e\x20\x01(\rR\x06slotId\x12\x20\n\x0bHEMODCFENHP\x18\x08\x20\x01(\
    \x08R\x0bHEMODCFENHP\"\xb0\x01\n\x17TrainPartyBuildDiyScRsp\x12\x20\n\
    \x0bHEMODCFENHP\x18\x0b\x20\x01(\x08R\x0bHEMODCFENHP\x12@\n\x0fbuild_slo\
    t_list\x18\t\x20\x03(\x0b2\x18.TrainPartyBuildSlotInfoR\rbuildSlotList\
    \x12\x18\n\x07retcode\x18\x02\x20\x01(\rR\x07retcode\x12\x17\n\x07area_i\
    d\x18\x07\x20\x01(\rR\x06areaId\"q\n\x0bBFIHFFONJIH\x12\x20\n\x0bFBBNKCF\
    EIIC\x18\x04\x20\x01(\rR\x0bFBBNKCFEIIC\x12@\n\x0fbuild_step_list\x18\
    \x06\x20\x03(\x0b2\x18.TrainPartyBuildStepInfoR\rbuildStepList\"\x9d\x01\
    \n\x0bHHCFGIJPHLC\x12\x1a\n\x08progress\x18\x03\x20\x01(\rR\x08progress\
    \x12@\n\x0fbuild_step_list\x18\t\x20\x03(\x0b2\x18.TrainPartyBuildStepIn\
    foR\rbuildStepList\x12\x17\n\x07goal_id\x18\r\x20\x01(\rR\x06goalId\x12\
    \x17\n\x07area_id\x18\x0f\x20\x01(\rR\x06areaId\"P\n\x0bNKFHBMJAOBM\x12\
    \x20\n\x0bCFJKBJHNIJM\x18\x03\x20\x01(\rR\x0bCFJKBJHNIJM\x12\x1f\n\x0bbu\
    ild_level\x18\t\x20\x01(\rR\nbuildLevel\"/\n\x0bIFDLBAFMEKG\x12\x20\n\
    \x0bCLLDMNPOOPJ\x18\x0f\x20\x01(\rR\x0bCLLDMNPOOPJ\"/\n\x0bIGNFNKHNIEL\
    \x12\x20\n\x0bCDJFDJIAING\x18\x04\x20\x01(\rR\x0bCDJFDJIAING\"H\n\x0bEIM\
    DBGMFDOB\x12\x20\n\x0bODKNCMOKFGO\x18\x04\x20\x01(\rR\x0bODKNCMOKFGO\x12\
    \x17\n\x07area_id\x18\x05\x20\x01(\rR\x06areaId\"5\n\x0bAICEBLJDHJL\x12&\
    \n\x0fdynamic_prop_id\x18\x01\x20\x01(\rR\rdynamicPropId\"/\n\x0bGOIBHEO\
    AHNG\x12\x20\n\x0bBIJHIEOKFBD\x18\x08\x20\x01(\rR\x0bBIJHIEOKFBD\"4\n\
    \x0bBAEECFDDJCH\x12%\n\x0ebuild_progress\x18\x08\x20\x01(\rR\rbuildProgr\
    ess\"N\n\x0bLKKHDLLPMEL\x12\x17\n\x07area_id\x18\n\x20\x01(\rR\x06areaId\
    \x12&\n\x0fbuild_step_list\x18\x06\x20\x03(\rR\rbuildStepList\"A\n\x0bAC\
    JOMKMLBOO\x122\n\x0earea_info_list\x18\x0c\x20\x03(\x0b2\x0c.LKKHDLLPMEL\
    R\x0careaInfoList\"\x99\x04\n\x0bECEOEEEJIOC\x121\n\x0bLOFHHANCPBG\x18\
    \xd4\r\x20\x01(\x0b2\x0c.GOIBHEOAHNGH\0R\x0bLOFHHANCPBG\x121\n\x0bKIJLCJ\
    BJICP\x18\x9f\x05\x20\x01(\x0b2\x0c.BFIHFFONJIHH\0R\x0bKIJLCJBJICP\x121\
    \n\x0bJHJHDIHDJIM\x18\xd1\x0b\x20\x01(\x0b2\x0c.HHCFGIJPHLCH\0R\x0bJHJHD\
    IHDJIM\x120\n\x0bJFBBLDGBEDH\x18b\x20\x01(\x0b2\x0c.NKFHBMJAOBMH\0R\x0bJ\
    FBBLDGBEDH\x121\n\x0bEBOJDHDENKA\x18\x97\x06\x20\x01(\x0b2\x0c.IFDLBAFME\
    KGH\0R\x0bEBOJDHDENKA\x121\n\x0bBIIMCNKIEPD\x18\x92\x0f\x20\x01(\x0b2\
    \x0c.EIMDBGMFDOBH\0R\x0bBIIMCNKIEPD\x121\n\x0bBFKEEKCOODN\x18\xbf\x03\
    \x20\x01(\x0b2\x0c.AICEBLJDHJLH\0R\x0bBFKEEKCOODN\x121\n\x0bPMNEMJCNFEJ\
    \x18\x88\x04\x20\x01(\x0b2\x0c.IGNFNKHNIELH\0R\x0bPMNEMJCNFEJ\x121\n\x0b\
    MMEGPPCJFGG\x18\xff\n\x20\x01(\x0b2\x0c.BAEECFDDJCHH\0R\x0bMMEGPPCJFGG\
    \x121\n\x0bMCEEKAJKCIG\x18\xcc\x06\x20\x01(\x0b2\x0c.ACJOMKMLBOOH\0R\x0b\
    MCEEKAJKCIGB\r\n\x0bOMNKNOLIHNB\"P\n\x1eTrainPartyBuildingUpdateNotify\
    \x12.\n\x0bJLNMJIFIALA\x18\x03\x20\x03(\x0b2\x0c.ECEOEEEJIOCR\x0bJLNMJIF\
    IALA\"\x16\n\x14TrainPartyEnterCsReq\"0\n\x14TrainPartyEnterScRsp\x12\
    \x18\n\x07retcode\x18\x05\x20\x01(\rR\x07retcode\"\x16\n\x14TrainPartyLe\
    aveCsReq\"0\n\x14TrainPartyLeaveScRsp\x12\x18\n\x07retcode\x18\x07\x20\
    \x01(\rR\x07retcode\"\\\n\x0bKHIIKMDCABJ\x12\x14\n\x05level\x18\x02\x20\
    \x01(\rR\x05level\x127\n\x0bIAHEKFKNFCD\x18\x0f\x20\x01(\x0e2\x15.TrainP\
    artyMtCategoryR\x0bIAHEKFKNFCD\"9\n\x1eTrainPartyUnlockBuildAreaCsReq\
    \x12\x17\n\x07area_id\x18\x07\x20\x01(\rR\x06areaId\"S\n\x1eTrainPartyUn\
    lockBuildAreaScRsp\x12\x17\n\x07area_id\x18\x06\x20\x01(\rR\x06areaId\
    \x12\x18\n\x07retcode\x18\x0c\x20\x01(\rR\x07retcode\"\xd2\x01\n\x1eTrai\
    nPartyGamePlaySettleNotify\x12Q\n\x14passenger_persistent\x18\x03\x20\
    \x01(\x0b2\x1e.TrainPartyPersistentPassengerR\x13passengerPersistent\x12\
    \x1a\n\x08attempts\x18\t\x20\x01(\rR\x08attempts\x12\x1f\n\x0broom_unloc\
    k\x18\x0e\x20\x01(\rR\nroomUnlock\x12\x20\n\x0bBFBPHDKHHKO\x18\x01\x20\
    \x03(\rR\x0bBFBPHDKHHKO\"p\n\x1cTrainPartyGamePlayStartCsReq\x12.\n\x13p\
    assenger_data_list\x18\n\x20\x03(\rR\x11passengerDataList\x12\x20\n\x0bK\
    NPFNNGBAIC\x18\x0c\x20\x01(\rR\x0bKNPFNNGBAIC\"\x8c\x01\n\x1cTrainPartyG\
    amePlayStartScRsp\x12\x18\n\x07retcode\x18\x02\x20\x01(\rR\x07retcode\
    \x12R\n\x19train_party_gameplay_data\x18\r\x20\x01(\x0b2\x17.TrainPartyG\
    ameplayDataR\x16trainPartyGameplayData\"?\n\x1bTrainPartyUpdatePosEnvCsR\
    eq\x12\x20\n\x0bNPKLLEHIOAL\x18\x0c\x20\x01(\rR\x0bNPKLLEHIOAL\"Y\n\x1bT\
    rainPartyUpdatePosEnvScRsp\x12\x20\n\x0bNPKLLEHIOAL\x18\x03\x20\x01(\rR\
    \x0bNPKLLEHIOAL\x12\x18\n\x07retcode\x18\t\x20\x01(\rR\x07retcode\"$\n\"\
    TrainPartyAddBuildDynamicBuffCsReq\"W\n\"TrainPartyAddBuildDynamicBuffSc\
    Rsp\x12\x18\n\x07retcode\x18\x01\x20\x01(\rR\x07retcode\x12\x17\n\x07buf\
    f_id\x18\x06\x20\x01(\rR\x06buffId\"F\n\"TrainPartyTakeBuildLevelAwardCs\
    Req\x12\x20\n\x0bBJFLLFADCIH\x18\x0c\x20\x01(\rR\x0bBJFLLFADCIH\"\x88\
    \x01\n\"TrainPartyTakeBuildLevelAwardScRsp\x12&\n\titem_list\x18\x02\x20\
    \x01(\x0b2\t.ItemListR\x08itemList\x12\x18\n\x07retcode\x18\r\x20\x01(\r\
    R\x07retcode\x12\x20\n\x0bBJFLLFADCIH\x18\x0c\x20\x01(\rR\x0bBJFLLFADCIH\
    *v\n\x15TrainPartyBuildStatus\x12\x15\n\x11BuildGoalStepNone\x10\0\x12\
    \x15\n\x11BuildGoalStepIdle\x10\x01\x12\x16\n\x12BuildGoalStepStart\x10\
    \x02\x12\x17\n\x13BuildGoalStepFinish\x10\x03*\xad\x01\n\x13TrainPartyUp\
    dateSrc\x12\x16\n\x12kTrainPartySrcNone\x10\0\x12\x16\n\x12kTrainPartySr\
    cCard\x10\x01\x12\x16\n\x12kTrainPartySrcGrid\x10\x02\x12\x15\n\x11kTrai\
    nPartySrcPam\x10\x03\x12\x1b\n\x17kTrainPartySrcPassenger\x10\x04\x12\
    \x1a\n\x16kTrainPartySrcBuilding\x10\x05*~\n\x0bEJLFEABGGID\x12\x16\n\
    \x12kDialogueEventNone\x10\0\x12\x1f\n\x1bkGamePlayStartDialogueEvent\
    \x10\x01\x12\x16\n\x12kGridDialogueEvent\x10\x02\x12\x1e\n\x1akAfterMeet\
    ingDialogueEvent\x10\x03*\x8e\x01\n\x15TrainPartyMtSkillType\x12\x10\n\
    \x0ckMtSkillNone\x10\0\x12\x16\n\x12kMtSkillModifyBase\x10\x01\x12\x17\n\
    \x13kMtSkillModifyRatio\x10\x02\x12\x19\n\x15kMtSkillMultiplyRatio\x10\
    \x03\x12\x17\n\x13kMtSkillSelfDestroy\x10\x04*\xb0\x02\n\x14TrainPartyMt\
    Category\x12\x20\n\x1cTRAIN_PARTY_MT_CATEGORY_NONE\x10\0\x12\x1d\n\x19TR\
    AIN_PARTY_MT_CATEGORY_S\x10\x01\x12\x1d\n\x19TRAIN_PARTY_MT_CATEGORY_A\
    \x10\x02\x12\x1d\n\x19TRAIN_PARTY_MT_CATEGORY_B\x10\x03\x12\x1d\n\x19TRA\
    IN_PARTY_MT_CATEGORY_C\x10\x04\x12\x1d\n\x19TRAIN_PARTY_MT_CATEGORY_D\
    \x10\x05\x12\x1d\n\x19TRAIN_PARTY_MT_CATEGORY_E\x10\x06\x12\x1d\n\x19TRA\
    IN_PARTY_MT_CATEGORY_F\x10\x07\x12\x1d\n\x19TRAIN_PARTY_MT_CATEGORY_G\
    \x10\x08B\x15\n\x13emu.lunarcore.protob\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::ItemList::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(94);
            messages.push(TrainPartyCardData::generated_message_descriptor_data());
            messages.push(TrainPartyCards::generated_message_descriptor_data());
            messages.push(TrainPartyCard::generated_message_descriptor_data());
            messages.push(TrainPartyGridData::generated_message_descriptor_data());
            messages.push(TrainPartyMeetingCountInfo::generated_message_descriptor_data());
            messages.push(TrainPartyGrids::generated_message_descriptor_data());
            messages.push(TrainPartyPassengerStatusInfo::generated_message_descriptor_data());
            messages.push(TrainPartyPassengerSkillInfo::generated_message_descriptor_data());
            messages.push(TrainPartyPassengerData::generated_message_descriptor_data());
            messages.push(TrainPartyPassengerPersistentData::generated_message_descriptor_data());
            messages.push(TrainPartyPassenger::generated_message_descriptor_data());
            messages.push(TrainPartyPersistentPassenger::generated_message_descriptor_data());
            messages.push(TrainPartyAreaInfo::generated_message_descriptor_data());
            messages.push(HHOKBPHNFNE::generated_message_descriptor_data());
            messages.push(TrainPartyBuildStepInfo::generated_message_descriptor_data());
            messages.push(TrainPartyBuildGoalData::generated_message_descriptor_data());
            messages.push(TrainPartyBuildSlotInfo::generated_message_descriptor_data());
            messages.push(TrainPartyBuildInfo::generated_message_descriptor_data());
            messages.push(TrainPartyGameInstance::generated_message_descriptor_data());
            messages.push(TrainPartyGameplayData::generated_message_descriptor_data());
            messages.push(TrainPartyGetDataCsReq::generated_message_descriptor_data());
            messages.push(TrainPartyGetDataScRsp::generated_message_descriptor_data());
            messages.push(TrainPartyUseCardCsReq::generated_message_descriptor_data());
            messages.push(TrainPartyUseCardScRsp::generated_message_descriptor_data());
            messages.push(TrainPartyMoveScNotify::generated_message_descriptor_data());
            messages.push(TrainPartySettleNotify::generated_message_descriptor_data());
            messages.push(TrainPartySettleData::generated_message_descriptor_data());
            messages.push(TrainPartySettleRecord::generated_message_descriptor_data());
            messages.push(JDGAOCPJEPL::generated_message_descriptor_data());
            messages.push(CBNHKHEFEFF::generated_message_descriptor_data());
            messages.push(BFFIEMJEDIL::generated_message_descriptor_data());
            messages.push(MINMHDAEEHH::generated_message_descriptor_data());
            messages.push(LFHKDENCECI::generated_message_descriptor_data());
            messages.push(LOCAOOGDAMB::generated_message_descriptor_data());
            messages.push(JCDCKOAPGEE::generated_message_descriptor_data());
            messages.push(KNINCLCJODM::generated_message_descriptor_data());
            messages.push(EKLMKFCKLAA::generated_message_descriptor_data());
            messages.push(NHNNJJPBOMJ::generated_message_descriptor_data());
            messages.push(TrainPartyUpdateInfo::generated_message_descriptor_data());
            messages.push(TrainPartySyncUpdateScNotify::generated_message_descriptor_data());
            messages.push(TrainPartyPendingAction::generated_message_descriptor_data());
            messages.push(JIGMPADFPHE::generated_message_descriptor_data());
            messages.push(EEIADCHLFNB::generated_message_descriptor_data());
            messages.push(NIBBILKHHHE::generated_message_descriptor_data());
            messages.push(KBFEOIAJLJC::generated_message_descriptor_data());
            messages.push(BOMJDHMAAJM::generated_message_descriptor_data());
            messages.push(TrainPartyReplaceSkillAction::generated_message_descriptor_data());
            messages.push(ICMFJIEIEBM::generated_message_descriptor_data());
            messages.push(TrainPartyReplaceSkillActionResult::generated_message_descriptor_data());
            messages.push(TrainPartyMeetingPassengerCardInfo::generated_message_descriptor_data());
            messages.push(TrainPartyMeetingLeftCardInfo::generated_message_descriptor_data());
            messages.push(TrainPartyMeetingData::generated_message_descriptor_data());
            messages.push(PlaySkillBrief::generated_message_descriptor_data());
            messages.push(PlayCardBrief::generated_message_descriptor_data());
            messages.push(TrainPartyMeetingSettleResult::generated_message_descriptor_data());
            messages.push(HPIPKEEKBDO::generated_message_descriptor_data());
            messages.push(TrainPartyMeetingUseCardInfo::generated_message_descriptor_data());
            messages.push(COAOOLIBOHF::generated_message_descriptor_data());
            messages.push(TrainPartyMeetingRollInfo::generated_message_descriptor_data());
            messages.push(TrainPartyHandlePendingActionCsReq::generated_message_descriptor_data());
            messages.push(TrainPartyHandlePendingActionScRsp::generated_message_descriptor_data());
            messages.push(TrainPartyBuildStartStepCsReq::generated_message_descriptor_data());
            messages.push(TrainPartyBuildStartStepScRsp::generated_message_descriptor_data());
            messages.push(TrainPartyBuildDiyCsReq::generated_message_descriptor_data());
            messages.push(TrainPartyBuildDiyScRsp::generated_message_descriptor_data());
            messages.push(BFIHFFONJIH::generated_message_descriptor_data());
            messages.push(HHCFGIJPHLC::generated_message_descriptor_data());
            messages.push(NKFHBMJAOBM::generated_message_descriptor_data());
            messages.push(IFDLBAFMEKG::generated_message_descriptor_data());
            messages.push(IGNFNKHNIEL::generated_message_descriptor_data());
            messages.push(EIMDBGMFDOB::generated_message_descriptor_data());
            messages.push(AICEBLJDHJL::generated_message_descriptor_data());
            messages.push(GOIBHEOAHNG::generated_message_descriptor_data());
            messages.push(BAEECFDDJCH::generated_message_descriptor_data());
            messages.push(LKKHDLLPMEL::generated_message_descriptor_data());
            messages.push(ACJOMKMLBOO::generated_message_descriptor_data());
            messages.push(ECEOEEEJIOC::generated_message_descriptor_data());
            messages.push(TrainPartyBuildingUpdateNotify::generated_message_descriptor_data());
            messages.push(TrainPartyEnterCsReq::generated_message_descriptor_data());
            messages.push(TrainPartyEnterScRsp::generated_message_descriptor_data());
            messages.push(TrainPartyLeaveCsReq::generated_message_descriptor_data());
            messages.push(TrainPartyLeaveScRsp::generated_message_descriptor_data());
            messages.push(KHIIKMDCABJ::generated_message_descriptor_data());
            messages.push(TrainPartyUnlockBuildAreaCsReq::generated_message_descriptor_data());
            messages.push(TrainPartyUnlockBuildAreaScRsp::generated_message_descriptor_data());
            messages.push(TrainPartyGamePlaySettleNotify::generated_message_descriptor_data());
            messages.push(TrainPartyGamePlayStartCsReq::generated_message_descriptor_data());
            messages.push(TrainPartyGamePlayStartScRsp::generated_message_descriptor_data());
            messages.push(TrainPartyUpdatePosEnvCsReq::generated_message_descriptor_data());
            messages.push(TrainPartyUpdatePosEnvScRsp::generated_message_descriptor_data());
            messages.push(TrainPartyAddBuildDynamicBuffCsReq::generated_message_descriptor_data());
            messages.push(TrainPartyAddBuildDynamicBuffScRsp::generated_message_descriptor_data());
            messages.push(TrainPartyTakeBuildLevelAwardCsReq::generated_message_descriptor_data());
            messages.push(TrainPartyTakeBuildLevelAwardScRsp::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(TrainPartyBuildStatus::generated_enum_descriptor_data());
            enums.push(TrainPartyUpdateSrc::generated_enum_descriptor_data());
            enums.push(EJLFEABGGID::generated_enum_descriptor_data());
            enums.push(TrainPartyMtSkillType::generated_enum_descriptor_data());
            enums.push(TrainPartyMtCategory::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
