// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `ContentPackage.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:ContentPackageGetDataCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContentPackageGetDataCsReq {
    // special fields
    // @@protoc_insertion_point(special_field:ContentPackageGetDataCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContentPackageGetDataCsReq {
    fn default() -> &'a ContentPackageGetDataCsReq {
        <ContentPackageGetDataCsReq as ::protobuf::Message>::default_instance()
    }
}

impl ContentPackageGetDataCsReq {
    pub fn new() -> ContentPackageGetDataCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContentPackageGetDataCsReq>(
            "ContentPackageGetDataCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContentPackageGetDataCsReq {
    const NAME: &'static str = "ContentPackageGetDataCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContentPackageGetDataCsReq {
        ContentPackageGetDataCsReq::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContentPackageGetDataCsReq {
        static instance: ContentPackageGetDataCsReq = ContentPackageGetDataCsReq {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContentPackageGetDataCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContentPackageGetDataCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContentPackageGetDataCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentPackageGetDataCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ContentPackageGetDataScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContentPackageGetDataScRsp {
    // message fields
    // @@protoc_insertion_point(field:ContentPackageGetDataScRsp.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:ContentPackageGetDataScRsp.data)
    pub data: ::protobuf::MessageField<PackageData>,
    // special fields
    // @@protoc_insertion_point(special_field:ContentPackageGetDataScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContentPackageGetDataScRsp {
    fn default() -> &'a ContentPackageGetDataScRsp {
        <ContentPackageGetDataScRsp as ::protobuf::Message>::default_instance()
    }
}

impl ContentPackageGetDataScRsp {
    pub fn new() -> ContentPackageGetDataScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &ContentPackageGetDataScRsp| { &m.retcode },
            |m: &mut ContentPackageGetDataScRsp| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PackageData>(
            "data",
            |m: &ContentPackageGetDataScRsp| { &m.data },
            |m: &mut ContentPackageGetDataScRsp| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContentPackageGetDataScRsp>(
            "ContentPackageGetDataScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContentPackageGetDataScRsp {
    const NAME: &'static str = "ContentPackageGetDataScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.retcode = is.read_uint32()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.retcode);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(2, self.retcode)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContentPackageGetDataScRsp {
        ContentPackageGetDataScRsp::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContentPackageGetDataScRsp {
        static instance: ContentPackageGetDataScRsp = ContentPackageGetDataScRsp {
            retcode: 0,
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContentPackageGetDataScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContentPackageGetDataScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContentPackageGetDataScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentPackageGetDataScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ContentInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContentInfo {
    // message fields
    // @@protoc_insertion_point(field:ContentInfo.status)
    pub status: ::protobuf::EnumOrUnknown<ContentPackageStatus>,
    // @@protoc_insertion_point(field:ContentInfo.content_id)
    pub content_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ContentInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContentInfo {
    fn default() -> &'a ContentInfo {
        <ContentInfo as ::protobuf::Message>::default_instance()
    }
}

impl ContentInfo {
    pub fn new() -> ContentInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &ContentInfo| { &m.status },
            |m: &mut ContentInfo| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content_id",
            |m: &ContentInfo| { &m.content_id },
            |m: &mut ContentInfo| { &mut m.content_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContentInfo>(
            "ContentInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContentInfo {
    const NAME: &'static str = "ContentInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                88 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                80 => {
                    self.content_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.status != ::protobuf::EnumOrUnknown::new(ContentPackageStatus::ContentPackageStatus_None) {
            my_size += ::protobuf::rt::int32_size(11, self.status.value());
        }
        if self.content_id != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.content_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.status != ::protobuf::EnumOrUnknown::new(ContentPackageStatus::ContentPackageStatus_None) {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if self.content_id != 0 {
            os.write_uint32(10, self.content_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContentInfo {
        ContentInfo::new()
    }

    fn clear(&mut self) {
        self.status = ::protobuf::EnumOrUnknown::new(ContentPackageStatus::ContentPackageStatus_None);
        self.content_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContentInfo {
        static instance: ContentInfo = ContentInfo {
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            content_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContentInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContentInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PackageData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PackageData {
    // message fields
    // @@protoc_insertion_point(field:PackageData.MCNAPKPEJII)
    pub MCNAPKPEJII: u32,
    // @@protoc_insertion_point(field:PackageData.info_list)
    pub info_list: ::std::vec::Vec<ContentInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:PackageData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PackageData {
    fn default() -> &'a PackageData {
        <PackageData as ::protobuf::Message>::default_instance()
    }
}

impl PackageData {
    pub fn new() -> PackageData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MCNAPKPEJII",
            |m: &PackageData| { &m.MCNAPKPEJII },
            |m: &mut PackageData| { &mut m.MCNAPKPEJII },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "info_list",
            |m: &PackageData| { &m.info_list },
            |m: &mut PackageData| { &mut m.info_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PackageData>(
            "PackageData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PackageData {
    const NAME: &'static str = "PackageData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.MCNAPKPEJII = is.read_uint32()?;
                },
                34 => {
                    self.info_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.MCNAPKPEJII != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.MCNAPKPEJII);
        }
        for value in &self.info_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.MCNAPKPEJII != 0 {
            os.write_uint32(6, self.MCNAPKPEJII)?;
        }
        for v in &self.info_list {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PackageData {
        PackageData::new()
    }

    fn clear(&mut self) {
        self.MCNAPKPEJII = 0;
        self.info_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PackageData {
        static instance: PackageData = PackageData {
            MCNAPKPEJII: 0,
            info_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PackageData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PackageData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PackageData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PackageData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ContentPackageSyncDataScNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContentPackageSyncDataScNotify {
    // message fields
    // @@protoc_insertion_point(field:ContentPackageSyncDataScNotify.data)
    pub data: ::protobuf::MessageField<PackageData>,
    // special fields
    // @@protoc_insertion_point(special_field:ContentPackageSyncDataScNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContentPackageSyncDataScNotify {
    fn default() -> &'a ContentPackageSyncDataScNotify {
        <ContentPackageSyncDataScNotify as ::protobuf::Message>::default_instance()
    }
}

impl ContentPackageSyncDataScNotify {
    pub fn new() -> ContentPackageSyncDataScNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PackageData>(
            "data",
            |m: &ContentPackageSyncDataScNotify| { &m.data },
            |m: &mut ContentPackageSyncDataScNotify| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContentPackageSyncDataScNotify>(
            "ContentPackageSyncDataScNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContentPackageSyncDataScNotify {
    const NAME: &'static str = "ContentPackageSyncDataScNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContentPackageSyncDataScNotify {
        ContentPackageSyncDataScNotify::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContentPackageSyncDataScNotify {
        static instance: ContentPackageSyncDataScNotify = ContentPackageSyncDataScNotify {
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContentPackageSyncDataScNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContentPackageSyncDataScNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContentPackageSyncDataScNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentPackageSyncDataScNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ContentPackageUnlockCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContentPackageUnlockCsReq {
    // message fields
    // @@protoc_insertion_point(field:ContentPackageUnlockCsReq.content_id)
    pub content_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ContentPackageUnlockCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContentPackageUnlockCsReq {
    fn default() -> &'a ContentPackageUnlockCsReq {
        <ContentPackageUnlockCsReq as ::protobuf::Message>::default_instance()
    }
}

impl ContentPackageUnlockCsReq {
    pub fn new() -> ContentPackageUnlockCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content_id",
            |m: &ContentPackageUnlockCsReq| { &m.content_id },
            |m: &mut ContentPackageUnlockCsReq| { &mut m.content_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContentPackageUnlockCsReq>(
            "ContentPackageUnlockCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContentPackageUnlockCsReq {
    const NAME: &'static str = "ContentPackageUnlockCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.content_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.content_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.content_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.content_id != 0 {
            os.write_uint32(4, self.content_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContentPackageUnlockCsReq {
        ContentPackageUnlockCsReq::new()
    }

    fn clear(&mut self) {
        self.content_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContentPackageUnlockCsReq {
        static instance: ContentPackageUnlockCsReq = ContentPackageUnlockCsReq {
            content_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContentPackageUnlockCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContentPackageUnlockCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContentPackageUnlockCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentPackageUnlockCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ContentPackageUnlockScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContentPackageUnlockScRsp {
    // message fields
    // @@protoc_insertion_point(field:ContentPackageUnlockScRsp.content_id)
    pub content_id: u32,
    // @@protoc_insertion_point(field:ContentPackageUnlockScRsp.retcode)
    pub retcode: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ContentPackageUnlockScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContentPackageUnlockScRsp {
    fn default() -> &'a ContentPackageUnlockScRsp {
        <ContentPackageUnlockScRsp as ::protobuf::Message>::default_instance()
    }
}

impl ContentPackageUnlockScRsp {
    pub fn new() -> ContentPackageUnlockScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content_id",
            |m: &ContentPackageUnlockScRsp| { &m.content_id },
            |m: &mut ContentPackageUnlockScRsp| { &mut m.content_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &ContentPackageUnlockScRsp| { &m.retcode },
            |m: &mut ContentPackageUnlockScRsp| { &mut m.retcode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContentPackageUnlockScRsp>(
            "ContentPackageUnlockScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContentPackageUnlockScRsp {
    const NAME: &'static str = "ContentPackageUnlockScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                72 => {
                    self.content_id = is.read_uint32()?;
                },
                80 => {
                    self.retcode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.content_id != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.content_id);
        }
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.retcode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.content_id != 0 {
            os.write_uint32(9, self.content_id)?;
        }
        if self.retcode != 0 {
            os.write_uint32(10, self.retcode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContentPackageUnlockScRsp {
        ContentPackageUnlockScRsp::new()
    }

    fn clear(&mut self) {
        self.content_id = 0;
        self.retcode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContentPackageUnlockScRsp {
        static instance: ContentPackageUnlockScRsp = ContentPackageUnlockScRsp {
            content_id: 0,
            retcode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContentPackageUnlockScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContentPackageUnlockScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContentPackageUnlockScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentPackageUnlockScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ContentPackageTransferScNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContentPackageTransferScNotify {
    // special fields
    // @@protoc_insertion_point(special_field:ContentPackageTransferScNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContentPackageTransferScNotify {
    fn default() -> &'a ContentPackageTransferScNotify {
        <ContentPackageTransferScNotify as ::protobuf::Message>::default_instance()
    }
}

impl ContentPackageTransferScNotify {
    pub fn new() -> ContentPackageTransferScNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContentPackageTransferScNotify>(
            "ContentPackageTransferScNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContentPackageTransferScNotify {
    const NAME: &'static str = "ContentPackageTransferScNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContentPackageTransferScNotify {
        ContentPackageTransferScNotify::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContentPackageTransferScNotify {
        static instance: ContentPackageTransferScNotify = ContentPackageTransferScNotify {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContentPackageTransferScNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContentPackageTransferScNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContentPackageTransferScNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentPackageTransferScNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ContentPackageStatus)
pub enum ContentPackageStatus {
    // @@protoc_insertion_point(enum_value:ContentPackageStatus.ContentPackageStatus_None)
    ContentPackageStatus_None = 0,
    // @@protoc_insertion_point(enum_value:ContentPackageStatus.ContentPackageStatus_Init)
    ContentPackageStatus_Init = 1,
    // @@protoc_insertion_point(enum_value:ContentPackageStatus.ContentPackageStatus_Doing)
    ContentPackageStatus_Doing = 2,
    // @@protoc_insertion_point(enum_value:ContentPackageStatus.ContentPackageStatus_Finished)
    ContentPackageStatus_Finished = 3,
    // @@protoc_insertion_point(enum_value:ContentPackageStatus.ContentPackageStatus_Release)
    ContentPackageStatus_Release = 4,
}

impl ::protobuf::Enum for ContentPackageStatus {
    const NAME: &'static str = "ContentPackageStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContentPackageStatus> {
        match value {
            0 => ::std::option::Option::Some(ContentPackageStatus::ContentPackageStatus_None),
            1 => ::std::option::Option::Some(ContentPackageStatus::ContentPackageStatus_Init),
            2 => ::std::option::Option::Some(ContentPackageStatus::ContentPackageStatus_Doing),
            3 => ::std::option::Option::Some(ContentPackageStatus::ContentPackageStatus_Finished),
            4 => ::std::option::Option::Some(ContentPackageStatus::ContentPackageStatus_Release),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ContentPackageStatus> {
        match str {
            "ContentPackageStatus_None" => ::std::option::Option::Some(ContentPackageStatus::ContentPackageStatus_None),
            "ContentPackageStatus_Init" => ::std::option::Option::Some(ContentPackageStatus::ContentPackageStatus_Init),
            "ContentPackageStatus_Doing" => ::std::option::Option::Some(ContentPackageStatus::ContentPackageStatus_Doing),
            "ContentPackageStatus_Finished" => ::std::option::Option::Some(ContentPackageStatus::ContentPackageStatus_Finished),
            "ContentPackageStatus_Release" => ::std::option::Option::Some(ContentPackageStatus::ContentPackageStatus_Release),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ContentPackageStatus] = &[
        ContentPackageStatus::ContentPackageStatus_None,
        ContentPackageStatus::ContentPackageStatus_Init,
        ContentPackageStatus::ContentPackageStatus_Doing,
        ContentPackageStatus::ContentPackageStatus_Finished,
        ContentPackageStatus::ContentPackageStatus_Release,
    ];
}

impl ::protobuf::EnumFull for ContentPackageStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ContentPackageStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ContentPackageStatus {
    fn default() -> Self {
        ContentPackageStatus::ContentPackageStatus_None
    }
}

impl ContentPackageStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ContentPackageStatus>("ContentPackageStatus")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x14ContentPackage.proto\"\x1c\n\x1aContentPackageGetDataCsReq\"X\n\
    \x1aContentPackageGetDataScRsp\x12\x18\n\x07retcode\x18\x02\x20\x01(\rR\
    \x07retcode\x12\x20\n\x04data\x18\x08\x20\x01(\x0b2\x0c.PackageDataR\x04\
    data\"[\n\x0bContentInfo\x12-\n\x06status\x18\x0b\x20\x01(\x0e2\x15.Cont\
    entPackageStatusR\x06status\x12\x1d\n\ncontent_id\x18\n\x20\x01(\rR\tcon\
    tentId\"Z\n\x0bPackageData\x12\x20\n\x0bMCNAPKPEJII\x18\x06\x20\x01(\rR\
    \x0bMCNAPKPEJII\x12)\n\tinfo_list\x18\x04\x20\x03(\x0b2\x0c.ContentInfoR\
    \x08infoList\"B\n\x1eContentPackageSyncDataScNotify\x12\x20\n\x04data\
    \x18\x03\x20\x01(\x0b2\x0c.PackageDataR\x04data\":\n\x19ContentPackageUn\
    lockCsReq\x12\x1d\n\ncontent_id\x18\x04\x20\x01(\rR\tcontentId\"T\n\x19C\
    ontentPackageUnlockScRsp\x12\x1d\n\ncontent_id\x18\t\x20\x01(\rR\tconten\
    tId\x12\x18\n\x07retcode\x18\n\x20\x01(\rR\x07retcode\"\x20\n\x1eContent\
    PackageTransferScNotify*\xb9\x01\n\x14ContentPackageStatus\x12\x1d\n\x19\
    ContentPackageStatus_None\x10\0\x12\x1d\n\x19ContentPackageStatus_Init\
    \x10\x01\x12\x1e\n\x1aContentPackageStatus_Doing\x10\x02\x12!\n\x1dConte\
    ntPackageStatus_Finished\x10\x03\x12\x20\n\x1cContentPackageStatus_Relea\
    se\x10\x04B\x15\n\x13emu.lunarcore.protob\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(8);
            messages.push(ContentPackageGetDataCsReq::generated_message_descriptor_data());
            messages.push(ContentPackageGetDataScRsp::generated_message_descriptor_data());
            messages.push(ContentInfo::generated_message_descriptor_data());
            messages.push(PackageData::generated_message_descriptor_data());
            messages.push(ContentPackageSyncDataScNotify::generated_message_descriptor_data());
            messages.push(ContentPackageUnlockCsReq::generated_message_descriptor_data());
            messages.push(ContentPackageUnlockScRsp::generated_message_descriptor_data());
            messages.push(ContentPackageTransferScNotify::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(ContentPackageStatus::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
