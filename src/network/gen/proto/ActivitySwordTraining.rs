// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `ActivitySwordTraining.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:SwordTrainingGameInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingGameInfo {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingGameInfo.skill_info)
    pub skill_info: ::protobuf::MessageField<SwordTrainingSkillInfo>,
    // @@protoc_insertion_point(field:SwordTrainingGameInfo.sword_training_story_info)
    pub sword_training_story_info: ::protobuf::MessageField<SwordTrainingStoryInfo>,
    // @@protoc_insertion_point(field:SwordTrainingGameInfo.status_type_info)
    pub status_type_info: ::protobuf::MessageField<SwordTrainingStatusTypeInfo>,
    // @@protoc_insertion_point(field:SwordTrainingGameInfo.partner_info)
    pub partner_info: ::protobuf::MessageField<SwordTrainingPartnerInfo>,
    // @@protoc_insertion_point(field:SwordTrainingGameInfo.turn_info)
    pub turn_info: ::protobuf::MessageField<SwordTrainingTurnInfo>,
    // @@protoc_insertion_point(field:SwordTrainingGameInfo.pending_action)
    pub pending_action: ::protobuf::MessageField<SwordTrainingPendingAction>,
    // @@protoc_insertion_point(field:SwordTrainingGameInfo.MGKDFNBENAI)
    pub MGKDFNBENAI: u32,
    // @@protoc_insertion_point(field:SwordTrainingGameInfo.effect_info_list)
    pub effect_info_list: ::std::vec::Vec<SwordTrainingEffectInfo>,
    // @@protoc_insertion_point(field:SwordTrainingGameInfo.DPHNBKLJEHM)
    pub DPHNBKLJEHM: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:SwordTrainingGameInfo.action_info)
    pub action_info: ::protobuf::MessageField<SwordTrainingActionInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingGameInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingGameInfo {
    fn default() -> &'a SwordTrainingGameInfo {
        <SwordTrainingGameInfo as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingGameInfo {
    pub fn new() -> SwordTrainingGameInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SwordTrainingSkillInfo>(
            "skill_info",
            |m: &SwordTrainingGameInfo| { &m.skill_info },
            |m: &mut SwordTrainingGameInfo| { &mut m.skill_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SwordTrainingStoryInfo>(
            "sword_training_story_info",
            |m: &SwordTrainingGameInfo| { &m.sword_training_story_info },
            |m: &mut SwordTrainingGameInfo| { &mut m.sword_training_story_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SwordTrainingStatusTypeInfo>(
            "status_type_info",
            |m: &SwordTrainingGameInfo| { &m.status_type_info },
            |m: &mut SwordTrainingGameInfo| { &mut m.status_type_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SwordTrainingPartnerInfo>(
            "partner_info",
            |m: &SwordTrainingGameInfo| { &m.partner_info },
            |m: &mut SwordTrainingGameInfo| { &mut m.partner_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SwordTrainingTurnInfo>(
            "turn_info",
            |m: &SwordTrainingGameInfo| { &m.turn_info },
            |m: &mut SwordTrainingGameInfo| { &mut m.turn_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SwordTrainingPendingAction>(
            "pending_action",
            |m: &SwordTrainingGameInfo| { &m.pending_action },
            |m: &mut SwordTrainingGameInfo| { &mut m.pending_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MGKDFNBENAI",
            |m: &SwordTrainingGameInfo| { &m.MGKDFNBENAI },
            |m: &mut SwordTrainingGameInfo| { &mut m.MGKDFNBENAI },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "effect_info_list",
            |m: &SwordTrainingGameInfo| { &m.effect_info_list },
            |m: &mut SwordTrainingGameInfo| { &mut m.effect_info_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "DPHNBKLJEHM",
            |m: &SwordTrainingGameInfo| { &m.DPHNBKLJEHM },
            |m: &mut SwordTrainingGameInfo| { &mut m.DPHNBKLJEHM },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SwordTrainingActionInfo>(
            "action_info",
            |m: &SwordTrainingGameInfo| { &m.action_info },
            |m: &mut SwordTrainingGameInfo| { &mut m.action_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingGameInfo>(
            "SwordTrainingGameInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingGameInfo {
    const NAME: &'static str = "SwordTrainingGameInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.skill_info)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sword_training_story_info)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status_type_info)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.partner_info)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.turn_info)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pending_action)?;
                },
                40 => {
                    self.MGKDFNBENAI = is.read_uint32()?;
                },
                66 => {
                    self.effect_info_list.push(is.read_message()?);
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.DPHNBKLJEHM)?;
                },
                48 => {
                    self.DPHNBKLJEHM.push(is.read_uint32()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.action_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.skill_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sword_training_story_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status_type_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.partner_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.turn_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pending_action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.MGKDFNBENAI != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.MGKDFNBENAI);
        }
        for value in &self.effect_info_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.DPHNBKLJEHM {
            my_size += ::protobuf::rt::uint32_size(6, *value);
        };
        if let Some(v) = self.action_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.skill_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.sword_training_story_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.status_type_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.partner_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.turn_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.pending_action.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.MGKDFNBENAI != 0 {
            os.write_uint32(5, self.MGKDFNBENAI)?;
        }
        for v in &self.effect_info_list {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.DPHNBKLJEHM {
            os.write_uint32(6, *v)?;
        };
        if let Some(v) = self.action_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingGameInfo {
        SwordTrainingGameInfo::new()
    }

    fn clear(&mut self) {
        self.skill_info.clear();
        self.sword_training_story_info.clear();
        self.status_type_info.clear();
        self.partner_info.clear();
        self.turn_info.clear();
        self.pending_action.clear();
        self.MGKDFNBENAI = 0;
        self.effect_info_list.clear();
        self.DPHNBKLJEHM.clear();
        self.action_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingGameInfo {
        static instance: SwordTrainingGameInfo = SwordTrainingGameInfo {
            skill_info: ::protobuf::MessageField::none(),
            sword_training_story_info: ::protobuf::MessageField::none(),
            status_type_info: ::protobuf::MessageField::none(),
            partner_info: ::protobuf::MessageField::none(),
            turn_info: ::protobuf::MessageField::none(),
            pending_action: ::protobuf::MessageField::none(),
            MGKDFNBENAI: 0,
            effect_info_list: ::std::vec::Vec::new(),
            DPHNBKLJEHM: ::std::vec::Vec::new(),
            action_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingGameInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingGameInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingGameInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingGetSkillInfoCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingGetSkillInfoCsReq {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingGetSkillInfoCsReq.slot)
    pub slot: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingGetSkillInfoCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingGetSkillInfoCsReq {
    fn default() -> &'a SwordTrainingGetSkillInfoCsReq {
        <SwordTrainingGetSkillInfoCsReq as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingGetSkillInfoCsReq {
    pub fn new() -> SwordTrainingGetSkillInfoCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot",
            |m: &SwordTrainingGetSkillInfoCsReq| { &m.slot },
            |m: &mut SwordTrainingGetSkillInfoCsReq| { &mut m.slot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingGetSkillInfoCsReq>(
            "SwordTrainingGetSkillInfoCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingGetSkillInfoCsReq {
    const NAME: &'static str = "SwordTrainingGetSkillInfoCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.slot = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.slot != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.slot);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.slot != 0 {
            os.write_uint32(1, self.slot)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingGetSkillInfoCsReq {
        SwordTrainingGetSkillInfoCsReq::new()
    }

    fn clear(&mut self) {
        self.slot = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingGetSkillInfoCsReq {
        static instance: SwordTrainingGetSkillInfoCsReq = SwordTrainingGetSkillInfoCsReq {
            slot: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingGetSkillInfoCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingGetSkillInfoCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingGetSkillInfoCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingGetSkillInfoCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingGetSkillInfoScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingGetSkillInfoScRsp {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingGetSkillInfoScRsp.slot)
    pub slot: u32,
    // @@protoc_insertion_point(field:SwordTrainingGetSkillInfoScRsp.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:SwordTrainingGetSkillInfoScRsp.NHPHHAPJODG)
    pub NHPHHAPJODG: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:SwordTrainingGetSkillInfoScRsp.FEKILLBIEKO)
    pub FEKILLBIEKO: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingGetSkillInfoScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingGetSkillInfoScRsp {
    fn default() -> &'a SwordTrainingGetSkillInfoScRsp {
        <SwordTrainingGetSkillInfoScRsp as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingGetSkillInfoScRsp {
    pub fn new() -> SwordTrainingGetSkillInfoScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot",
            |m: &SwordTrainingGetSkillInfoScRsp| { &m.slot },
            |m: &mut SwordTrainingGetSkillInfoScRsp| { &mut m.slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &SwordTrainingGetSkillInfoScRsp| { &m.retcode },
            |m: &mut SwordTrainingGetSkillInfoScRsp| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "NHPHHAPJODG",
            |m: &SwordTrainingGetSkillInfoScRsp| { &m.NHPHHAPJODG },
            |m: &mut SwordTrainingGetSkillInfoScRsp| { &mut m.NHPHHAPJODG },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "FEKILLBIEKO",
            |m: &SwordTrainingGetSkillInfoScRsp| { &m.FEKILLBIEKO },
            |m: &mut SwordTrainingGetSkillInfoScRsp| { &mut m.FEKILLBIEKO },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingGetSkillInfoScRsp>(
            "SwordTrainingGetSkillInfoScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingGetSkillInfoScRsp {
    const NAME: &'static str = "SwordTrainingGetSkillInfoScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.slot = is.read_uint32()?;
                },
                120 => {
                    self.retcode = is.read_uint32()?;
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.NHPHHAPJODG)?;
                },
                56 => {
                    self.NHPHHAPJODG.push(is.read_uint32()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.FEKILLBIEKO)?;
                },
                40 => {
                    self.FEKILLBIEKO.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.slot != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.slot);
        }
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(15, self.retcode);
        }
        for value in &self.NHPHHAPJODG {
            my_size += ::protobuf::rt::uint32_size(7, *value);
        };
        for value in &self.FEKILLBIEKO {
            my_size += ::protobuf::rt::uint32_size(5, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.slot != 0 {
            os.write_uint32(2, self.slot)?;
        }
        if self.retcode != 0 {
            os.write_uint32(15, self.retcode)?;
        }
        for v in &self.NHPHHAPJODG {
            os.write_uint32(7, *v)?;
        };
        for v in &self.FEKILLBIEKO {
            os.write_uint32(5, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingGetSkillInfoScRsp {
        SwordTrainingGetSkillInfoScRsp::new()
    }

    fn clear(&mut self) {
        self.slot = 0;
        self.retcode = 0;
        self.NHPHHAPJODG.clear();
        self.FEKILLBIEKO.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingGetSkillInfoScRsp {
        static instance: SwordTrainingGetSkillInfoScRsp = SwordTrainingGetSkillInfoScRsp {
            slot: 0,
            retcode: 0,
            NHPHHAPJODG: ::std::vec::Vec::new(),
            FEKILLBIEKO: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingGetSkillInfoScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingGetSkillInfoScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingGetSkillInfoScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingGetSkillInfoScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingEffectInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingEffectInfo {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingEffectInfo.effect_type)
    pub effect_type: u32,
    // @@protoc_insertion_point(field:SwordTrainingEffectInfo.config_id)
    pub config_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingEffectInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingEffectInfo {
    fn default() -> &'a SwordTrainingEffectInfo {
        <SwordTrainingEffectInfo as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingEffectInfo {
    pub fn new() -> SwordTrainingEffectInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "effect_type",
            |m: &SwordTrainingEffectInfo| { &m.effect_type },
            |m: &mut SwordTrainingEffectInfo| { &mut m.effect_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "config_id",
            |m: &SwordTrainingEffectInfo| { &m.config_id },
            |m: &mut SwordTrainingEffectInfo| { &mut m.config_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingEffectInfo>(
            "SwordTrainingEffectInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingEffectInfo {
    const NAME: &'static str = "SwordTrainingEffectInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                72 => {
                    self.effect_type = is.read_uint32()?;
                },
                48 => {
                    self.config_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.effect_type != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.effect_type);
        }
        if self.config_id != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.config_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.effect_type != 0 {
            os.write_uint32(9, self.effect_type)?;
        }
        if self.config_id != 0 {
            os.write_uint32(6, self.config_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingEffectInfo {
        SwordTrainingEffectInfo::new()
    }

    fn clear(&mut self) {
        self.effect_type = 0;
        self.config_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingEffectInfo {
        static instance: SwordTrainingEffectInfo = SwordTrainingEffectInfo {
            effect_type: 0,
            config_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingEffectInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingEffectInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingEffectInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingEffectInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingSkillInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingSkillInfo {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingSkillInfo.OAJMNPADHGA)
    pub OAJMNPADHGA: u32,
    // @@protoc_insertion_point(field:SwordTrainingSkillInfo.PAOJAAONCBF)
    pub PAOJAAONCBF: u32,
    // @@protoc_insertion_point(field:SwordTrainingSkillInfo.BCMNPJJHJAD)
    pub BCMNPJJHJAD: u32,
    // @@protoc_insertion_point(field:SwordTrainingSkillInfo.FEKILLBIEKO)
    pub FEKILLBIEKO: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingSkillInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingSkillInfo {
    fn default() -> &'a SwordTrainingSkillInfo {
        <SwordTrainingSkillInfo as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingSkillInfo {
    pub fn new() -> SwordTrainingSkillInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OAJMNPADHGA",
            |m: &SwordTrainingSkillInfo| { &m.OAJMNPADHGA },
            |m: &mut SwordTrainingSkillInfo| { &mut m.OAJMNPADHGA },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PAOJAAONCBF",
            |m: &SwordTrainingSkillInfo| { &m.PAOJAAONCBF },
            |m: &mut SwordTrainingSkillInfo| { &mut m.PAOJAAONCBF },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "BCMNPJJHJAD",
            |m: &SwordTrainingSkillInfo| { &m.BCMNPJJHJAD },
            |m: &mut SwordTrainingSkillInfo| { &mut m.BCMNPJJHJAD },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "FEKILLBIEKO",
            |m: &SwordTrainingSkillInfo| { &m.FEKILLBIEKO },
            |m: &mut SwordTrainingSkillInfo| { &mut m.FEKILLBIEKO },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingSkillInfo>(
            "SwordTrainingSkillInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingSkillInfo {
    const NAME: &'static str = "SwordTrainingSkillInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                112 => {
                    self.OAJMNPADHGA = is.read_uint32()?;
                },
                56 => {
                    self.PAOJAAONCBF = is.read_uint32()?;
                },
                8 => {
                    self.BCMNPJJHJAD = is.read_uint32()?;
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.FEKILLBIEKO)?;
                },
                16 => {
                    self.FEKILLBIEKO.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.OAJMNPADHGA != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.OAJMNPADHGA);
        }
        if self.PAOJAAONCBF != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.PAOJAAONCBF);
        }
        if self.BCMNPJJHJAD != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.BCMNPJJHJAD);
        }
        for value in &self.FEKILLBIEKO {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.OAJMNPADHGA != 0 {
            os.write_uint32(14, self.OAJMNPADHGA)?;
        }
        if self.PAOJAAONCBF != 0 {
            os.write_uint32(7, self.PAOJAAONCBF)?;
        }
        if self.BCMNPJJHJAD != 0 {
            os.write_uint32(1, self.BCMNPJJHJAD)?;
        }
        for v in &self.FEKILLBIEKO {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingSkillInfo {
        SwordTrainingSkillInfo::new()
    }

    fn clear(&mut self) {
        self.OAJMNPADHGA = 0;
        self.PAOJAAONCBF = 0;
        self.BCMNPJJHJAD = 0;
        self.FEKILLBIEKO.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingSkillInfo {
        static instance: SwordTrainingSkillInfo = SwordTrainingSkillInfo {
            OAJMNPADHGA: 0,
            PAOJAAONCBF: 0,
            BCMNPJJHJAD: 0,
            FEKILLBIEKO: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingSkillInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingSkillInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingSkillInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingSkillInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingPartner)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingPartner {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingPartner.partner_id)
    pub partner_id: u32,
    // @@protoc_insertion_point(field:SwordTrainingPartner.avatar_id)
    pub avatar_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingPartner.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingPartner {
    fn default() -> &'a SwordTrainingPartner {
        <SwordTrainingPartner as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingPartner {
    pub fn new() -> SwordTrainingPartner {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "partner_id",
            |m: &SwordTrainingPartner| { &m.partner_id },
            |m: &mut SwordTrainingPartner| { &mut m.partner_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "avatar_id",
            |m: &SwordTrainingPartner| { &m.avatar_id },
            |m: &mut SwordTrainingPartner| { &mut m.avatar_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingPartner>(
            "SwordTrainingPartner",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingPartner {
    const NAME: &'static str = "SwordTrainingPartner";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.partner_id = is.read_uint32()?;
                },
                88 => {
                    self.avatar_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.partner_id != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.partner_id);
        }
        if self.avatar_id != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.avatar_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.partner_id != 0 {
            os.write_uint32(6, self.partner_id)?;
        }
        if self.avatar_id != 0 {
            os.write_uint32(11, self.avatar_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingPartner {
        SwordTrainingPartner::new()
    }

    fn clear(&mut self) {
        self.partner_id = 0;
        self.avatar_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingPartner {
        static instance: SwordTrainingPartner = SwordTrainingPartner {
            partner_id: 0,
            avatar_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingPartner {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingPartner").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingPartner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingPartner {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingPartnerInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingPartnerInfo {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingPartnerInfo.partner_list)
    pub partner_list: ::std::vec::Vec<SwordTrainingPartner>,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingPartnerInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingPartnerInfo {
    fn default() -> &'a SwordTrainingPartnerInfo {
        <SwordTrainingPartnerInfo as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingPartnerInfo {
    pub fn new() -> SwordTrainingPartnerInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "partner_list",
            |m: &SwordTrainingPartnerInfo| { &m.partner_list },
            |m: &mut SwordTrainingPartnerInfo| { &mut m.partner_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingPartnerInfo>(
            "SwordTrainingPartnerInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingPartnerInfo {
    const NAME: &'static str = "SwordTrainingPartnerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                74 => {
                    self.partner_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.partner_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.partner_list {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingPartnerInfo {
        SwordTrainingPartnerInfo::new()
    }

    fn clear(&mut self) {
        self.partner_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingPartnerInfo {
        static instance: SwordTrainingPartnerInfo = SwordTrainingPartnerInfo {
            partner_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingPartnerInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingPartnerInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingPartnerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingPartnerInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingStoryInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingStoryInfo {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingStoryInfo.story_id)
    pub story_id: u32,
    // @@protoc_insertion_point(field:SwordTrainingStoryInfo.hint_id)
    pub hint_id: u32,
    // @@protoc_insertion_point(field:SwordTrainingStoryInfo.story_id_list)
    pub story_id_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:SwordTrainingStoryInfo.HCMJKFEAADP)
    pub HCMJKFEAADP: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingStoryInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingStoryInfo {
    fn default() -> &'a SwordTrainingStoryInfo {
        <SwordTrainingStoryInfo as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingStoryInfo {
    pub fn new() -> SwordTrainingStoryInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "story_id",
            |m: &SwordTrainingStoryInfo| { &m.story_id },
            |m: &mut SwordTrainingStoryInfo| { &mut m.story_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hint_id",
            |m: &SwordTrainingStoryInfo| { &m.hint_id },
            |m: &mut SwordTrainingStoryInfo| { &mut m.hint_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "story_id_list",
            |m: &SwordTrainingStoryInfo| { &m.story_id_list },
            |m: &mut SwordTrainingStoryInfo| { &mut m.story_id_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "HCMJKFEAADP",
            |m: &SwordTrainingStoryInfo| { &m.HCMJKFEAADP },
            |m: &mut SwordTrainingStoryInfo| { &mut m.HCMJKFEAADP },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingStoryInfo>(
            "SwordTrainingStoryInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingStoryInfo {
    const NAME: &'static str = "SwordTrainingStoryInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                56 => {
                    self.story_id = is.read_uint32()?;
                },
                48 => {
                    self.hint_id = is.read_uint32()?;
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.story_id_list)?;
                },
                24 => {
                    self.story_id_list.push(is.read_uint32()?);
                },
                90 => {
                    is.read_repeated_packed_uint32_into(&mut self.HCMJKFEAADP)?;
                },
                88 => {
                    self.HCMJKFEAADP.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.story_id != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.story_id);
        }
        if self.hint_id != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.hint_id);
        }
        for value in &self.story_id_list {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        for value in &self.HCMJKFEAADP {
            my_size += ::protobuf::rt::uint32_size(11, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.story_id != 0 {
            os.write_uint32(7, self.story_id)?;
        }
        if self.hint_id != 0 {
            os.write_uint32(6, self.hint_id)?;
        }
        for v in &self.story_id_list {
            os.write_uint32(3, *v)?;
        };
        for v in &self.HCMJKFEAADP {
            os.write_uint32(11, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingStoryInfo {
        SwordTrainingStoryInfo::new()
    }

    fn clear(&mut self) {
        self.story_id = 0;
        self.hint_id = 0;
        self.story_id_list.clear();
        self.HCMJKFEAADP.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingStoryInfo {
        static instance: SwordTrainingStoryInfo = SwordTrainingStoryInfo {
            story_id: 0,
            hint_id: 0,
            story_id_list: ::std::vec::Vec::new(),
            HCMJKFEAADP: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingStoryInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingStoryInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingStoryInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingStoryInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingStatus {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingStatus.DIBKEHHCPAP)
    pub DIBKEHHCPAP: u32,
    // @@protoc_insertion_point(field:SwordTrainingStatus.PCLPEHLNDAF)
    pub PCLPEHLNDAF: u32,
    // @@protoc_insertion_point(field:SwordTrainingStatus.status_type)
    pub status_type: ::protobuf::EnumOrUnknown<SwordTrainingStatusType>,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingStatus {
    fn default() -> &'a SwordTrainingStatus {
        <SwordTrainingStatus as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingStatus {
    pub fn new() -> SwordTrainingStatus {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DIBKEHHCPAP",
            |m: &SwordTrainingStatus| { &m.DIBKEHHCPAP },
            |m: &mut SwordTrainingStatus| { &mut m.DIBKEHHCPAP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PCLPEHLNDAF",
            |m: &SwordTrainingStatus| { &m.PCLPEHLNDAF },
            |m: &mut SwordTrainingStatus| { &mut m.PCLPEHLNDAF },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status_type",
            |m: &SwordTrainingStatus| { &m.status_type },
            |m: &mut SwordTrainingStatus| { &mut m.status_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingStatus>(
            "SwordTrainingStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingStatus {
    const NAME: &'static str = "SwordTrainingStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.DIBKEHHCPAP = is.read_uint32()?;
                },
                32 => {
                    self.PCLPEHLNDAF = is.read_uint32()?;
                },
                56 => {
                    self.status_type = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.DIBKEHHCPAP != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.DIBKEHHCPAP);
        }
        if self.PCLPEHLNDAF != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.PCLPEHLNDAF);
        }
        if self.status_type != ::protobuf::EnumOrUnknown::new(SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.status_type.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.DIBKEHHCPAP != 0 {
            os.write_uint32(10, self.DIBKEHHCPAP)?;
        }
        if self.PCLPEHLNDAF != 0 {
            os.write_uint32(4, self.PCLPEHLNDAF)?;
        }
        if self.status_type != ::protobuf::EnumOrUnknown::new(SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.status_type))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingStatus {
        SwordTrainingStatus::new()
    }

    fn clear(&mut self) {
        self.DIBKEHHCPAP = 0;
        self.PCLPEHLNDAF = 0;
        self.status_type = ::protobuf::EnumOrUnknown::new(SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingStatus {
        static instance: SwordTrainingStatus = SwordTrainingStatus {
            DIBKEHHCPAP: 0,
            PCLPEHLNDAF: 0,
            status_type: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingStatusTypeInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingStatusTypeInfo {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingStatusTypeInfo.skill_point)
    pub skill_point: u32,
    // @@protoc_insertion_point(field:SwordTrainingStatusTypeInfo.status_list)
    pub status_list: ::std::vec::Vec<SwordTrainingStatus>,
    // @@protoc_insertion_point(field:SwordTrainingStatusTypeInfo.combat_rank)
    pub combat_rank: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingStatusTypeInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingStatusTypeInfo {
    fn default() -> &'a SwordTrainingStatusTypeInfo {
        <SwordTrainingStatusTypeInfo as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingStatusTypeInfo {
    pub fn new() -> SwordTrainingStatusTypeInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "skill_point",
            |m: &SwordTrainingStatusTypeInfo| { &m.skill_point },
            |m: &mut SwordTrainingStatusTypeInfo| { &mut m.skill_point },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "status_list",
            |m: &SwordTrainingStatusTypeInfo| { &m.status_list },
            |m: &mut SwordTrainingStatusTypeInfo| { &mut m.status_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "combat_rank",
            |m: &SwordTrainingStatusTypeInfo| { &m.combat_rank },
            |m: &mut SwordTrainingStatusTypeInfo| { &mut m.combat_rank },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingStatusTypeInfo>(
            "SwordTrainingStatusTypeInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingStatusTypeInfo {
    const NAME: &'static str = "SwordTrainingStatusTypeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.skill_point = is.read_uint32()?;
                },
                114 => {
                    self.status_list.push(is.read_message()?);
                },
                24 => {
                    self.combat_rank = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.skill_point != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.skill_point);
        }
        for value in &self.status_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.combat_rank != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.combat_rank);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.skill_point != 0 {
            os.write_uint32(6, self.skill_point)?;
        }
        for v in &self.status_list {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        if self.combat_rank != 0 {
            os.write_uint32(3, self.combat_rank)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingStatusTypeInfo {
        SwordTrainingStatusTypeInfo::new()
    }

    fn clear(&mut self) {
        self.skill_point = 0;
        self.status_list.clear();
        self.combat_rank = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingStatusTypeInfo {
        static instance: SwordTrainingStatusTypeInfo = SwordTrainingStatusTypeInfo {
            skill_point: 0,
            status_list: ::std::vec::Vec::new(),
            combat_rank: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingStatusTypeInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingStatusTypeInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingStatusTypeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingStatusTypeInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingStatusList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingStatusList {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingStatusList.status_list)
    pub status_list: ::std::vec::Vec<SwordTrainingStatus>,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingStatusList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingStatusList {
    fn default() -> &'a SwordTrainingStatusList {
        <SwordTrainingStatusList as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingStatusList {
    pub fn new() -> SwordTrainingStatusList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "status_list",
            |m: &SwordTrainingStatusList| { &m.status_list },
            |m: &mut SwordTrainingStatusList| { &mut m.status_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingStatusList>(
            "SwordTrainingStatusList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingStatusList {
    const NAME: &'static str = "SwordTrainingStatusList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                42 => {
                    self.status_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.status_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.status_list {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingStatusList {
        SwordTrainingStatusList::new()
    }

    fn clear(&mut self) {
        self.status_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingStatusList {
        static instance: SwordTrainingStatusList = SwordTrainingStatusList {
            status_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingStatusList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingStatusList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingStatusList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingStatusList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingAction {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingAction.unique_id)
    pub unique_id: u32,
    // @@protoc_insertion_point(field:SwordTrainingAction.level)
    pub level: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingAction {
    fn default() -> &'a SwordTrainingAction {
        <SwordTrainingAction as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingAction {
    pub fn new() -> SwordTrainingAction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &SwordTrainingAction| { &m.unique_id },
            |m: &mut SwordTrainingAction| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "level",
            |m: &SwordTrainingAction| { &m.level },
            |m: &mut SwordTrainingAction| { &mut m.level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingAction>(
            "SwordTrainingAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingAction {
    const NAME: &'static str = "SwordTrainingAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.unique_id = is.read_uint32()?;
                },
                8 => {
                    self.level = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.unique_id != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.unique_id);
        }
        if self.level != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.level);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.unique_id != 0 {
            os.write_uint32(6, self.unique_id)?;
        }
        if self.level != 0 {
            os.write_uint32(1, self.level)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingAction {
        SwordTrainingAction::new()
    }

    fn clear(&mut self) {
        self.unique_id = 0;
        self.level = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingAction {
        static instance: SwordTrainingAction = SwordTrainingAction {
            unique_id: 0,
            level: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingActionInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingActionInfo {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingActionInfo.action_list)
    pub action_list: ::std::vec::Vec<SwordTrainingAction>,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingActionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingActionInfo {
    fn default() -> &'a SwordTrainingActionInfo {
        <SwordTrainingActionInfo as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingActionInfo {
    pub fn new() -> SwordTrainingActionInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "action_list",
            |m: &SwordTrainingActionInfo| { &m.action_list },
            |m: &mut SwordTrainingActionInfo| { &mut m.action_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingActionInfo>(
            "SwordTrainingActionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingActionInfo {
    const NAME: &'static str = "SwordTrainingActionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.action_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.action_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.action_list {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingActionInfo {
        SwordTrainingActionInfo::new()
    }

    fn clear(&mut self) {
        self.action_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingActionInfo {
        static instance: SwordTrainingActionInfo = SwordTrainingActionInfo {
            action_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingActionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingActionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingActionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingActionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingTurnInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingTurnInfo {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingTurnInfo.turn_id)
    pub turn_id: u32,
    // message oneof groups
    pub turn_info: ::std::option::Option<sword_training_turn_info::Turn_info>,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingTurnInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingTurnInfo {
    fn default() -> &'a SwordTrainingTurnInfo {
        <SwordTrainingTurnInfo as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingTurnInfo {
    pub fn new() -> SwordTrainingTurnInfo {
        ::std::default::Default::default()
    }

    // .SwordTrainingActionTurnInfo action_turn = 14;

    pub fn action_turn(&self) -> &SwordTrainingActionTurnInfo {
        match self.turn_info {
            ::std::option::Option::Some(sword_training_turn_info::Turn_info::ActionTurn(ref v)) => v,
            _ => <SwordTrainingActionTurnInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_action_turn(&mut self) {
        self.turn_info = ::std::option::Option::None;
    }

    pub fn has_action_turn(&self) -> bool {
        match self.turn_info {
            ::std::option::Option::Some(sword_training_turn_info::Turn_info::ActionTurn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_turn(&mut self, v: SwordTrainingActionTurnInfo) {
        self.turn_info = ::std::option::Option::Some(sword_training_turn_info::Turn_info::ActionTurn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_turn(&mut self) -> &mut SwordTrainingActionTurnInfo {
        if let ::std::option::Option::Some(sword_training_turn_info::Turn_info::ActionTurn(_)) = self.turn_info {
        } else {
            self.turn_info = ::std::option::Option::Some(sword_training_turn_info::Turn_info::ActionTurn(SwordTrainingActionTurnInfo::new()));
        }
        match self.turn_info {
            ::std::option::Option::Some(sword_training_turn_info::Turn_info::ActionTurn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_turn(&mut self) -> SwordTrainingActionTurnInfo {
        if self.has_action_turn() {
            match self.turn_info.take() {
                ::std::option::Option::Some(sword_training_turn_info::Turn_info::ActionTurn(v)) => v,
                _ => panic!(),
            }
        } else {
            SwordTrainingActionTurnInfo::new()
        }
    }

    // .SwordTrainingExamTurnInfo exam_turn = 4;

    pub fn exam_turn(&self) -> &SwordTrainingExamTurnInfo {
        match self.turn_info {
            ::std::option::Option::Some(sword_training_turn_info::Turn_info::ExamTurn(ref v)) => v,
            _ => <SwordTrainingExamTurnInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_exam_turn(&mut self) {
        self.turn_info = ::std::option::Option::None;
    }

    pub fn has_exam_turn(&self) -> bool {
        match self.turn_info {
            ::std::option::Option::Some(sword_training_turn_info::Turn_info::ExamTurn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exam_turn(&mut self, v: SwordTrainingExamTurnInfo) {
        self.turn_info = ::std::option::Option::Some(sword_training_turn_info::Turn_info::ExamTurn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exam_turn(&mut self) -> &mut SwordTrainingExamTurnInfo {
        if let ::std::option::Option::Some(sword_training_turn_info::Turn_info::ExamTurn(_)) = self.turn_info {
        } else {
            self.turn_info = ::std::option::Option::Some(sword_training_turn_info::Turn_info::ExamTurn(SwordTrainingExamTurnInfo::new()));
        }
        match self.turn_info {
            ::std::option::Option::Some(sword_training_turn_info::Turn_info::ExamTurn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exam_turn(&mut self) -> SwordTrainingExamTurnInfo {
        if self.has_exam_turn() {
            match self.turn_info.take() {
                ::std::option::Option::Some(sword_training_turn_info::Turn_info::ExamTurn(v)) => v,
                _ => panic!(),
            }
        } else {
            SwordTrainingExamTurnInfo::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "turn_id",
            |m: &SwordTrainingTurnInfo| { &m.turn_id },
            |m: &mut SwordTrainingTurnInfo| { &mut m.turn_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SwordTrainingActionTurnInfo>(
            "action_turn",
            SwordTrainingTurnInfo::has_action_turn,
            SwordTrainingTurnInfo::action_turn,
            SwordTrainingTurnInfo::mut_action_turn,
            SwordTrainingTurnInfo::set_action_turn,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SwordTrainingExamTurnInfo>(
            "exam_turn",
            SwordTrainingTurnInfo::has_exam_turn,
            SwordTrainingTurnInfo::exam_turn,
            SwordTrainingTurnInfo::mut_exam_turn,
            SwordTrainingTurnInfo::set_exam_turn,
        ));
        oneofs.push(sword_training_turn_info::Turn_info::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingTurnInfo>(
            "SwordTrainingTurnInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingTurnInfo {
    const NAME: &'static str = "SwordTrainingTurnInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                5056 => {
                    self.turn_id = is.read_uint32()?;
                },
                114 => {
                    self.turn_info = ::std::option::Option::Some(sword_training_turn_info::Turn_info::ActionTurn(is.read_message()?));
                },
                34 => {
                    self.turn_info = ::std::option::Option::Some(sword_training_turn_info::Turn_info::ExamTurn(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.turn_id != 0 {
            my_size += ::protobuf::rt::uint32_size(632, self.turn_id);
        }
        if let ::std::option::Option::Some(ref v) = self.turn_info {
            match v {
                &sword_training_turn_info::Turn_info::ActionTurn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &sword_training_turn_info::Turn_info::ExamTurn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.turn_id != 0 {
            os.write_uint32(632, self.turn_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.turn_info {
            match v {
                &sword_training_turn_info::Turn_info::ActionTurn(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &sword_training_turn_info::Turn_info::ExamTurn(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingTurnInfo {
        SwordTrainingTurnInfo::new()
    }

    fn clear(&mut self) {
        self.turn_id = 0;
        self.turn_info = ::std::option::Option::None;
        self.turn_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingTurnInfo {
        static instance: SwordTrainingTurnInfo = SwordTrainingTurnInfo {
            turn_id: 0,
            turn_info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingTurnInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingTurnInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingTurnInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingTurnInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SwordTrainingTurnInfo`
pub mod sword_training_turn_info {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SwordTrainingTurnInfo.turn_info)
    pub enum Turn_info {
        // @@protoc_insertion_point(oneof_field:SwordTrainingTurnInfo.action_turn)
        ActionTurn(super::SwordTrainingActionTurnInfo),
        // @@protoc_insertion_point(oneof_field:SwordTrainingTurnInfo.exam_turn)
        ExamTurn(super::SwordTrainingExamTurnInfo),
    }

    impl ::protobuf::Oneof for Turn_info {
    }

    impl ::protobuf::OneofFull for Turn_info {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::SwordTrainingTurnInfo as ::protobuf::MessageFull>::descriptor().oneof_by_name("turn_info").unwrap()).clone()
        }
    }

    impl Turn_info {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Turn_info>("turn_info")
        }
    }
}

// @@protoc_insertion_point(message:NEMGFNPGEDK)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NEMGFNPGEDK {
    // message fields
    // @@protoc_insertion_point(field:NEMGFNPGEDK.PAOKBIDANEJ)
    pub PAOKBIDANEJ: i32,
    // @@protoc_insertion_point(field:NEMGFNPGEDK.MMAKPNLBHII)
    pub MMAKPNLBHII: i32,
    // special fields
    // @@protoc_insertion_point(special_field:NEMGFNPGEDK.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NEMGFNPGEDK {
    fn default() -> &'a NEMGFNPGEDK {
        <NEMGFNPGEDK as ::protobuf::Message>::default_instance()
    }
}

impl NEMGFNPGEDK {
    pub fn new() -> NEMGFNPGEDK {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PAOKBIDANEJ",
            |m: &NEMGFNPGEDK| { &m.PAOKBIDANEJ },
            |m: &mut NEMGFNPGEDK| { &mut m.PAOKBIDANEJ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MMAKPNLBHII",
            |m: &NEMGFNPGEDK| { &m.MMAKPNLBHII },
            |m: &mut NEMGFNPGEDK| { &mut m.MMAKPNLBHII },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NEMGFNPGEDK>(
            "NEMGFNPGEDK",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NEMGFNPGEDK {
    const NAME: &'static str = "NEMGFNPGEDK";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                112 => {
                    self.PAOKBIDANEJ = is.read_int32()?;
                },
                32 => {
                    self.MMAKPNLBHII = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.PAOKBIDANEJ != 0 {
            my_size += ::protobuf::rt::int32_size(14, self.PAOKBIDANEJ);
        }
        if self.MMAKPNLBHII != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.MMAKPNLBHII);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.PAOKBIDANEJ != 0 {
            os.write_int32(14, self.PAOKBIDANEJ)?;
        }
        if self.MMAKPNLBHII != 0 {
            os.write_int32(4, self.MMAKPNLBHII)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NEMGFNPGEDK {
        NEMGFNPGEDK::new()
    }

    fn clear(&mut self) {
        self.PAOKBIDANEJ = 0;
        self.MMAKPNLBHII = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NEMGFNPGEDK {
        static instance: NEMGFNPGEDK = NEMGFNPGEDK {
            PAOKBIDANEJ: 0,
            MMAKPNLBHII: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NEMGFNPGEDK {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NEMGFNPGEDK").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NEMGFNPGEDK {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMGFNPGEDK {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingPartnerAbility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingPartnerAbility {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingPartnerAbility.ADENLFJOOPL)
    pub ADENLFJOOPL: u32,
    // @@protoc_insertion_point(field:SwordTrainingPartnerAbility.PBNBFPABMFP)
    pub PBNBFPABMFP: u32,
    // @@protoc_insertion_point(field:SwordTrainingPartnerAbility.MCKOMCKFKLG)
    pub MCKOMCKFKLG: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingPartnerAbility.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingPartnerAbility {
    fn default() -> &'a SwordTrainingPartnerAbility {
        <SwordTrainingPartnerAbility as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingPartnerAbility {
    pub fn new() -> SwordTrainingPartnerAbility {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ADENLFJOOPL",
            |m: &SwordTrainingPartnerAbility| { &m.ADENLFJOOPL },
            |m: &mut SwordTrainingPartnerAbility| { &mut m.ADENLFJOOPL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PBNBFPABMFP",
            |m: &SwordTrainingPartnerAbility| { &m.PBNBFPABMFP },
            |m: &mut SwordTrainingPartnerAbility| { &mut m.PBNBFPABMFP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MCKOMCKFKLG",
            |m: &SwordTrainingPartnerAbility| { &m.MCKOMCKFKLG },
            |m: &mut SwordTrainingPartnerAbility| { &mut m.MCKOMCKFKLG },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingPartnerAbility>(
            "SwordTrainingPartnerAbility",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingPartnerAbility {
    const NAME: &'static str = "SwordTrainingPartnerAbility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                96 => {
                    self.ADENLFJOOPL = is.read_uint32()?;
                },
                64 => {
                    self.PBNBFPABMFP = is.read_uint32()?;
                },
                32 => {
                    self.MCKOMCKFKLG = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ADENLFJOOPL != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.ADENLFJOOPL);
        }
        if self.PBNBFPABMFP != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.PBNBFPABMFP);
        }
        if self.MCKOMCKFKLG != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.MCKOMCKFKLG);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ADENLFJOOPL != 0 {
            os.write_uint32(12, self.ADENLFJOOPL)?;
        }
        if self.PBNBFPABMFP != 0 {
            os.write_uint32(8, self.PBNBFPABMFP)?;
        }
        if self.MCKOMCKFKLG != 0 {
            os.write_uint32(4, self.MCKOMCKFKLG)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingPartnerAbility {
        SwordTrainingPartnerAbility::new()
    }

    fn clear(&mut self) {
        self.ADENLFJOOPL = 0;
        self.PBNBFPABMFP = 0;
        self.MCKOMCKFKLG = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingPartnerAbility {
        static instance: SwordTrainingPartnerAbility = SwordTrainingPartnerAbility {
            ADENLFJOOPL: 0,
            PBNBFPABMFP: 0,
            MCKOMCKFKLG: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingPartnerAbility {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingPartnerAbility").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingPartnerAbility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingPartnerAbility {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingActionTurnInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingActionTurnInfo {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingActionTurnInfo.JHINDCDBNML)
    pub JHINDCDBNML: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:SwordTrainingActionTurnInfo.GPJGAFFCMNG)
    pub GPJGAFFCMNG: ::protobuf::EnumOrUnknown<SwordTrainingDailyPhaseType>,
    // @@protoc_insertion_point(field:SwordTrainingActionTurnInfo.LOJFKFFCEAA)
    pub LOJFKFFCEAA: ::std::vec::Vec<SwordTrainingPartnerAbility>,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingActionTurnInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingActionTurnInfo {
    fn default() -> &'a SwordTrainingActionTurnInfo {
        <SwordTrainingActionTurnInfo as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingActionTurnInfo {
    pub fn new() -> SwordTrainingActionTurnInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "JHINDCDBNML",
            |m: &SwordTrainingActionTurnInfo| { &m.JHINDCDBNML },
            |m: &mut SwordTrainingActionTurnInfo| { &mut m.JHINDCDBNML },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "GPJGAFFCMNG",
            |m: &SwordTrainingActionTurnInfo| { &m.GPJGAFFCMNG },
            |m: &mut SwordTrainingActionTurnInfo| { &mut m.GPJGAFFCMNG },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "LOJFKFFCEAA",
            |m: &SwordTrainingActionTurnInfo| { &m.LOJFKFFCEAA },
            |m: &mut SwordTrainingActionTurnInfo| { &mut m.LOJFKFFCEAA },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingActionTurnInfo>(
            "SwordTrainingActionTurnInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingActionTurnInfo {
    const NAME: &'static str = "SwordTrainingActionTurnInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                114 => {
                    is.read_repeated_packed_uint32_into(&mut self.JHINDCDBNML)?;
                },
                112 => {
                    self.JHINDCDBNML.push(is.read_uint32()?);
                },
                88 => {
                    self.GPJGAFFCMNG = is.read_enum_or_unknown()?;
                },
                82 => {
                    self.LOJFKFFCEAA.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.JHINDCDBNML {
            my_size += ::protobuf::rt::uint32_size(14, *value);
        };
        if self.GPJGAFFCMNG != ::protobuf::EnumOrUnknown::new(SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(11, self.GPJGAFFCMNG.value());
        }
        for value in &self.LOJFKFFCEAA {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.JHINDCDBNML {
            os.write_uint32(14, *v)?;
        };
        if self.GPJGAFFCMNG != ::protobuf::EnumOrUnknown::new(SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_NONE) {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.GPJGAFFCMNG))?;
        }
        for v in &self.LOJFKFFCEAA {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingActionTurnInfo {
        SwordTrainingActionTurnInfo::new()
    }

    fn clear(&mut self) {
        self.JHINDCDBNML.clear();
        self.GPJGAFFCMNG = ::protobuf::EnumOrUnknown::new(SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_NONE);
        self.LOJFKFFCEAA.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingActionTurnInfo {
        static instance: SwordTrainingActionTurnInfo = SwordTrainingActionTurnInfo {
            JHINDCDBNML: ::std::vec::Vec::new(),
            GPJGAFFCMNG: ::protobuf::EnumOrUnknown::from_i32(0),
            LOJFKFFCEAA: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingActionTurnInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingActionTurnInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingActionTurnInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingActionTurnInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingExamTurnInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingExamTurnInfo {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingExamTurnInfo.NONMKEIGEGF)
    pub NONMKEIGEGF: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingExamTurnInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingExamTurnInfo {
    fn default() -> &'a SwordTrainingExamTurnInfo {
        <SwordTrainingExamTurnInfo as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingExamTurnInfo {
    pub fn new() -> SwordTrainingExamTurnInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NONMKEIGEGF",
            |m: &SwordTrainingExamTurnInfo| { &m.NONMKEIGEGF },
            |m: &mut SwordTrainingExamTurnInfo| { &mut m.NONMKEIGEGF },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingExamTurnInfo>(
            "SwordTrainingExamTurnInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingExamTurnInfo {
    const NAME: &'static str = "SwordTrainingExamTurnInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                104 => {
                    self.NONMKEIGEGF = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.NONMKEIGEGF != 0 {
            my_size += ::protobuf::rt::uint32_size(13, self.NONMKEIGEGF);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.NONMKEIGEGF != 0 {
            os.write_uint32(13, self.NONMKEIGEGF)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingExamTurnInfo {
        SwordTrainingExamTurnInfo::new()
    }

    fn clear(&mut self) {
        self.NONMKEIGEGF = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingExamTurnInfo {
        static instance: SwordTrainingExamTurnInfo = SwordTrainingExamTurnInfo {
            NONMKEIGEGF: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingExamTurnInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingExamTurnInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingExamTurnInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingExamTurnInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingPendingAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingPendingAction {
    // message oneof groups
    pub action: ::std::option::Option<sword_training_pending_action::Action>,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingPendingAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingPendingAction {
    fn default() -> &'a SwordTrainingPendingAction {
        <SwordTrainingPendingAction as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingPendingAction {
    pub fn new() -> SwordTrainingPendingAction {
        ::std::default::Default::default()
    }

    // .PKGODKBNAAM PCPAFLJBGDD = 2;

    pub fn PCPAFLJBGDD(&self) -> &PKGODKBNAAM {
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::PCPAFLJBGDD(ref v)) => v,
            _ => <PKGODKBNAAM as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_PCPAFLJBGDD(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_PCPAFLJBGDD(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::PCPAFLJBGDD(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_PCPAFLJBGDD(&mut self, v: PKGODKBNAAM) {
        self.action = ::std::option::Option::Some(sword_training_pending_action::Action::PCPAFLJBGDD(v))
    }

    // Mutable pointer to the field.
    pub fn mut_PCPAFLJBGDD(&mut self) -> &mut PKGODKBNAAM {
        if let ::std::option::Option::Some(sword_training_pending_action::Action::PCPAFLJBGDD(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(sword_training_pending_action::Action::PCPAFLJBGDD(PKGODKBNAAM::new()));
        }
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::PCPAFLJBGDD(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_PCPAFLJBGDD(&mut self) -> PKGODKBNAAM {
        if self.has_PCPAFLJBGDD() {
            match self.action.take() {
                ::std::option::Option::Some(sword_training_pending_action::Action::PCPAFLJBGDD(v)) => v,
                _ => panic!(),
            }
        } else {
            PKGODKBNAAM::new()
        }
    }

    // .NJAHHFGIMBF LGBCIKNKPOK = 3;

    pub fn LGBCIKNKPOK(&self) -> &NJAHHFGIMBF {
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::LGBCIKNKPOK(ref v)) => v,
            _ => <NJAHHFGIMBF as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_LGBCIKNKPOK(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_LGBCIKNKPOK(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::LGBCIKNKPOK(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_LGBCIKNKPOK(&mut self, v: NJAHHFGIMBF) {
        self.action = ::std::option::Option::Some(sword_training_pending_action::Action::LGBCIKNKPOK(v))
    }

    // Mutable pointer to the field.
    pub fn mut_LGBCIKNKPOK(&mut self) -> &mut NJAHHFGIMBF {
        if let ::std::option::Option::Some(sword_training_pending_action::Action::LGBCIKNKPOK(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(sword_training_pending_action::Action::LGBCIKNKPOK(NJAHHFGIMBF::new()));
        }
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::LGBCIKNKPOK(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_LGBCIKNKPOK(&mut self) -> NJAHHFGIMBF {
        if self.has_LGBCIKNKPOK() {
            match self.action.take() {
                ::std::option::Option::Some(sword_training_pending_action::Action::LGBCIKNKPOK(v)) => v,
                _ => panic!(),
            }
        } else {
            NJAHHFGIMBF::new()
        }
    }

    // .NGFELCGLDGB JAHPBDGDIGN = 9;

    pub fn JAHPBDGDIGN(&self) -> &NGFELCGLDGB {
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::JAHPBDGDIGN(ref v)) => v,
            _ => <NGFELCGLDGB as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_JAHPBDGDIGN(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_JAHPBDGDIGN(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::JAHPBDGDIGN(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_JAHPBDGDIGN(&mut self, v: NGFELCGLDGB) {
        self.action = ::std::option::Option::Some(sword_training_pending_action::Action::JAHPBDGDIGN(v))
    }

    // Mutable pointer to the field.
    pub fn mut_JAHPBDGDIGN(&mut self) -> &mut NGFELCGLDGB {
        if let ::std::option::Option::Some(sword_training_pending_action::Action::JAHPBDGDIGN(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(sword_training_pending_action::Action::JAHPBDGDIGN(NGFELCGLDGB::new()));
        }
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::JAHPBDGDIGN(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_JAHPBDGDIGN(&mut self) -> NGFELCGLDGB {
        if self.has_JAHPBDGDIGN() {
            match self.action.take() {
                ::std::option::Option::Some(sword_training_pending_action::Action::JAHPBDGDIGN(v)) => v,
                _ => panic!(),
            }
        } else {
            NGFELCGLDGB::new()
        }
    }

    // .OALMPFHPFPK OLNKGJDOECP = 14;

    pub fn OLNKGJDOECP(&self) -> &OALMPFHPFPK {
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::OLNKGJDOECP(ref v)) => v,
            _ => <OALMPFHPFPK as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_OLNKGJDOECP(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_OLNKGJDOECP(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::OLNKGJDOECP(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_OLNKGJDOECP(&mut self, v: OALMPFHPFPK) {
        self.action = ::std::option::Option::Some(sword_training_pending_action::Action::OLNKGJDOECP(v))
    }

    // Mutable pointer to the field.
    pub fn mut_OLNKGJDOECP(&mut self) -> &mut OALMPFHPFPK {
        if let ::std::option::Option::Some(sword_training_pending_action::Action::OLNKGJDOECP(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(sword_training_pending_action::Action::OLNKGJDOECP(OALMPFHPFPK::new()));
        }
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::OLNKGJDOECP(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_OLNKGJDOECP(&mut self) -> OALMPFHPFPK {
        if self.has_OLNKGJDOECP() {
            match self.action.take() {
                ::std::option::Option::Some(sword_training_pending_action::Action::OLNKGJDOECP(v)) => v,
                _ => panic!(),
            }
        } else {
            OALMPFHPFPK::new()
        }
    }

    // .OEJIIDGGGBO DAIBJMDJPKJ = 5;

    pub fn DAIBJMDJPKJ(&self) -> &OEJIIDGGGBO {
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::DAIBJMDJPKJ(ref v)) => v,
            _ => <OEJIIDGGGBO as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_DAIBJMDJPKJ(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_DAIBJMDJPKJ(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::DAIBJMDJPKJ(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_DAIBJMDJPKJ(&mut self, v: OEJIIDGGGBO) {
        self.action = ::std::option::Option::Some(sword_training_pending_action::Action::DAIBJMDJPKJ(v))
    }

    // Mutable pointer to the field.
    pub fn mut_DAIBJMDJPKJ(&mut self) -> &mut OEJIIDGGGBO {
        if let ::std::option::Option::Some(sword_training_pending_action::Action::DAIBJMDJPKJ(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(sword_training_pending_action::Action::DAIBJMDJPKJ(OEJIIDGGGBO::new()));
        }
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::DAIBJMDJPKJ(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_DAIBJMDJPKJ(&mut self) -> OEJIIDGGGBO {
        if self.has_DAIBJMDJPKJ() {
            match self.action.take() {
                ::std::option::Option::Some(sword_training_pending_action::Action::DAIBJMDJPKJ(v)) => v,
                _ => panic!(),
            }
        } else {
            OEJIIDGGGBO::new()
        }
    }

    // .BOIFCPNAOLC AOPBDFIBFPH = 4;

    pub fn AOPBDFIBFPH(&self) -> &BOIFCPNAOLC {
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::AOPBDFIBFPH(ref v)) => v,
            _ => <BOIFCPNAOLC as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_AOPBDFIBFPH(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_AOPBDFIBFPH(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::AOPBDFIBFPH(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_AOPBDFIBFPH(&mut self, v: BOIFCPNAOLC) {
        self.action = ::std::option::Option::Some(sword_training_pending_action::Action::AOPBDFIBFPH(v))
    }

    // Mutable pointer to the field.
    pub fn mut_AOPBDFIBFPH(&mut self) -> &mut BOIFCPNAOLC {
        if let ::std::option::Option::Some(sword_training_pending_action::Action::AOPBDFIBFPH(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(sword_training_pending_action::Action::AOPBDFIBFPH(BOIFCPNAOLC::new()));
        }
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::AOPBDFIBFPH(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_AOPBDFIBFPH(&mut self) -> BOIFCPNAOLC {
        if self.has_AOPBDFIBFPH() {
            match self.action.take() {
                ::std::option::Option::Some(sword_training_pending_action::Action::AOPBDFIBFPH(v)) => v,
                _ => panic!(),
            }
        } else {
            BOIFCPNAOLC::new()
        }
    }

    // .LFNDEHMBKNN AEPOACPOGND = 7;

    pub fn AEPOACPOGND(&self) -> &LFNDEHMBKNN {
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::AEPOACPOGND(ref v)) => v,
            _ => <LFNDEHMBKNN as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_AEPOACPOGND(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_AEPOACPOGND(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::AEPOACPOGND(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_AEPOACPOGND(&mut self, v: LFNDEHMBKNN) {
        self.action = ::std::option::Option::Some(sword_training_pending_action::Action::AEPOACPOGND(v))
    }

    // Mutable pointer to the field.
    pub fn mut_AEPOACPOGND(&mut self) -> &mut LFNDEHMBKNN {
        if let ::std::option::Option::Some(sword_training_pending_action::Action::AEPOACPOGND(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(sword_training_pending_action::Action::AEPOACPOGND(LFNDEHMBKNN::new()));
        }
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::AEPOACPOGND(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_AEPOACPOGND(&mut self) -> LFNDEHMBKNN {
        if self.has_AEPOACPOGND() {
            match self.action.take() {
                ::std::option::Option::Some(sword_training_pending_action::Action::AEPOACPOGND(v)) => v,
                _ => panic!(),
            }
        } else {
            LFNDEHMBKNN::new()
        }
    }

    // .ENGJLGMAOAC AFGIMCBOJFL = 12;

    pub fn AFGIMCBOJFL(&self) -> &ENGJLGMAOAC {
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::AFGIMCBOJFL(ref v)) => v,
            _ => <ENGJLGMAOAC as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_AFGIMCBOJFL(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_AFGIMCBOJFL(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::AFGIMCBOJFL(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_AFGIMCBOJFL(&mut self, v: ENGJLGMAOAC) {
        self.action = ::std::option::Option::Some(sword_training_pending_action::Action::AFGIMCBOJFL(v))
    }

    // Mutable pointer to the field.
    pub fn mut_AFGIMCBOJFL(&mut self) -> &mut ENGJLGMAOAC {
        if let ::std::option::Option::Some(sword_training_pending_action::Action::AFGIMCBOJFL(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(sword_training_pending_action::Action::AFGIMCBOJFL(ENGJLGMAOAC::new()));
        }
        match self.action {
            ::std::option::Option::Some(sword_training_pending_action::Action::AFGIMCBOJFL(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_AFGIMCBOJFL(&mut self) -> ENGJLGMAOAC {
        if self.has_AFGIMCBOJFL() {
            match self.action.take() {
                ::std::option::Option::Some(sword_training_pending_action::Action::AFGIMCBOJFL(v)) => v,
                _ => panic!(),
            }
        } else {
            ENGJLGMAOAC::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PKGODKBNAAM>(
            "PCPAFLJBGDD",
            SwordTrainingPendingAction::has_PCPAFLJBGDD,
            SwordTrainingPendingAction::PCPAFLJBGDD,
            SwordTrainingPendingAction::mut_PCPAFLJBGDD,
            SwordTrainingPendingAction::set_PCPAFLJBGDD,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, NJAHHFGIMBF>(
            "LGBCIKNKPOK",
            SwordTrainingPendingAction::has_LGBCIKNKPOK,
            SwordTrainingPendingAction::LGBCIKNKPOK,
            SwordTrainingPendingAction::mut_LGBCIKNKPOK,
            SwordTrainingPendingAction::set_LGBCIKNKPOK,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, NGFELCGLDGB>(
            "JAHPBDGDIGN",
            SwordTrainingPendingAction::has_JAHPBDGDIGN,
            SwordTrainingPendingAction::JAHPBDGDIGN,
            SwordTrainingPendingAction::mut_JAHPBDGDIGN,
            SwordTrainingPendingAction::set_JAHPBDGDIGN,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OALMPFHPFPK>(
            "OLNKGJDOECP",
            SwordTrainingPendingAction::has_OLNKGJDOECP,
            SwordTrainingPendingAction::OLNKGJDOECP,
            SwordTrainingPendingAction::mut_OLNKGJDOECP,
            SwordTrainingPendingAction::set_OLNKGJDOECP,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OEJIIDGGGBO>(
            "DAIBJMDJPKJ",
            SwordTrainingPendingAction::has_DAIBJMDJPKJ,
            SwordTrainingPendingAction::DAIBJMDJPKJ,
            SwordTrainingPendingAction::mut_DAIBJMDJPKJ,
            SwordTrainingPendingAction::set_DAIBJMDJPKJ,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BOIFCPNAOLC>(
            "AOPBDFIBFPH",
            SwordTrainingPendingAction::has_AOPBDFIBFPH,
            SwordTrainingPendingAction::AOPBDFIBFPH,
            SwordTrainingPendingAction::mut_AOPBDFIBFPH,
            SwordTrainingPendingAction::set_AOPBDFIBFPH,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LFNDEHMBKNN>(
            "AEPOACPOGND",
            SwordTrainingPendingAction::has_AEPOACPOGND,
            SwordTrainingPendingAction::AEPOACPOGND,
            SwordTrainingPendingAction::mut_AEPOACPOGND,
            SwordTrainingPendingAction::set_AEPOACPOGND,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ENGJLGMAOAC>(
            "AFGIMCBOJFL",
            SwordTrainingPendingAction::has_AFGIMCBOJFL,
            SwordTrainingPendingAction::AFGIMCBOJFL,
            SwordTrainingPendingAction::mut_AFGIMCBOJFL,
            SwordTrainingPendingAction::set_AFGIMCBOJFL,
        ));
        oneofs.push(sword_training_pending_action::Action::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingPendingAction>(
            "SwordTrainingPendingAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingPendingAction {
    const NAME: &'static str = "SwordTrainingPendingAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.action = ::std::option::Option::Some(sword_training_pending_action::Action::PCPAFLJBGDD(is.read_message()?));
                },
                26 => {
                    self.action = ::std::option::Option::Some(sword_training_pending_action::Action::LGBCIKNKPOK(is.read_message()?));
                },
                74 => {
                    self.action = ::std::option::Option::Some(sword_training_pending_action::Action::JAHPBDGDIGN(is.read_message()?));
                },
                114 => {
                    self.action = ::std::option::Option::Some(sword_training_pending_action::Action::OLNKGJDOECP(is.read_message()?));
                },
                42 => {
                    self.action = ::std::option::Option::Some(sword_training_pending_action::Action::DAIBJMDJPKJ(is.read_message()?));
                },
                34 => {
                    self.action = ::std::option::Option::Some(sword_training_pending_action::Action::AOPBDFIBFPH(is.read_message()?));
                },
                58 => {
                    self.action = ::std::option::Option::Some(sword_training_pending_action::Action::AEPOACPOGND(is.read_message()?));
                },
                98 => {
                    self.action = ::std::option::Option::Some(sword_training_pending_action::Action::AFGIMCBOJFL(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &sword_training_pending_action::Action::PCPAFLJBGDD(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &sword_training_pending_action::Action::LGBCIKNKPOK(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &sword_training_pending_action::Action::JAHPBDGDIGN(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &sword_training_pending_action::Action::OLNKGJDOECP(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &sword_training_pending_action::Action::DAIBJMDJPKJ(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &sword_training_pending_action::Action::AOPBDFIBFPH(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &sword_training_pending_action::Action::AEPOACPOGND(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &sword_training_pending_action::Action::AFGIMCBOJFL(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &sword_training_pending_action::Action::PCPAFLJBGDD(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &sword_training_pending_action::Action::LGBCIKNKPOK(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &sword_training_pending_action::Action::JAHPBDGDIGN(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &sword_training_pending_action::Action::OLNKGJDOECP(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &sword_training_pending_action::Action::DAIBJMDJPKJ(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &sword_training_pending_action::Action::AOPBDFIBFPH(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &sword_training_pending_action::Action::AEPOACPOGND(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &sword_training_pending_action::Action::AFGIMCBOJFL(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingPendingAction {
        SwordTrainingPendingAction::new()
    }

    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingPendingAction {
        static instance: SwordTrainingPendingAction = SwordTrainingPendingAction {
            action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingPendingAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingPendingAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingPendingAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingPendingAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SwordTrainingPendingAction`
pub mod sword_training_pending_action {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SwordTrainingPendingAction.action)
    pub enum Action {
        // @@protoc_insertion_point(oneof_field:SwordTrainingPendingAction.PCPAFLJBGDD)
        PCPAFLJBGDD(super::PKGODKBNAAM),
        // @@protoc_insertion_point(oneof_field:SwordTrainingPendingAction.LGBCIKNKPOK)
        LGBCIKNKPOK(super::NJAHHFGIMBF),
        // @@protoc_insertion_point(oneof_field:SwordTrainingPendingAction.JAHPBDGDIGN)
        JAHPBDGDIGN(super::NGFELCGLDGB),
        // @@protoc_insertion_point(oneof_field:SwordTrainingPendingAction.OLNKGJDOECP)
        OLNKGJDOECP(super::OALMPFHPFPK),
        // @@protoc_insertion_point(oneof_field:SwordTrainingPendingAction.DAIBJMDJPKJ)
        DAIBJMDJPKJ(super::OEJIIDGGGBO),
        // @@protoc_insertion_point(oneof_field:SwordTrainingPendingAction.AOPBDFIBFPH)
        AOPBDFIBFPH(super::BOIFCPNAOLC),
        // @@protoc_insertion_point(oneof_field:SwordTrainingPendingAction.AEPOACPOGND)
        AEPOACPOGND(super::LFNDEHMBKNN),
        // @@protoc_insertion_point(oneof_field:SwordTrainingPendingAction.AFGIMCBOJFL)
        AFGIMCBOJFL(super::ENGJLGMAOAC),
    }

    impl ::protobuf::Oneof for Action {
    }

    impl ::protobuf::OneofFull for Action {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::SwordTrainingPendingAction as ::protobuf::MessageFull>::descriptor().oneof_by_name("action").unwrap()).clone()
        }
    }

    impl Action {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Action>("action")
        }
    }
}

// @@protoc_insertion_point(message:ABHNAFELEME)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ABHNAFELEME {
    // message fields
    // @@protoc_insertion_point(field:ABHNAFELEME.PCPAFLJBGDD)
    pub PCPAFLJBGDD: i32,
    // @@protoc_insertion_point(field:ABHNAFELEME.LGBCIKNKPOK)
    pub LGBCIKNKPOK: i32,
    // @@protoc_insertion_point(field:ABHNAFELEME.JAHPBDGDIGN)
    pub JAHPBDGDIGN: i32,
    // @@protoc_insertion_point(field:ABHNAFELEME.OLNKGJDOECP)
    pub OLNKGJDOECP: i32,
    // @@protoc_insertion_point(field:ABHNAFELEME.DAIBJMDJPKJ)
    pub DAIBJMDJPKJ: i32,
    // @@protoc_insertion_point(field:ABHNAFELEME.AOPBDFIBFPH)
    pub AOPBDFIBFPH: i32,
    // @@protoc_insertion_point(field:ABHNAFELEME.AEPOACPOGND)
    pub AEPOACPOGND: i32,
    // @@protoc_insertion_point(field:ABHNAFELEME.AFGIMCBOJFL)
    pub AFGIMCBOJFL: i32,
    // special fields
    // @@protoc_insertion_point(special_field:ABHNAFELEME.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ABHNAFELEME {
    fn default() -> &'a ABHNAFELEME {
        <ABHNAFELEME as ::protobuf::Message>::default_instance()
    }
}

impl ABHNAFELEME {
    pub fn new() -> ABHNAFELEME {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PCPAFLJBGDD",
            |m: &ABHNAFELEME| { &m.PCPAFLJBGDD },
            |m: &mut ABHNAFELEME| { &mut m.PCPAFLJBGDD },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LGBCIKNKPOK",
            |m: &ABHNAFELEME| { &m.LGBCIKNKPOK },
            |m: &mut ABHNAFELEME| { &mut m.LGBCIKNKPOK },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "JAHPBDGDIGN",
            |m: &ABHNAFELEME| { &m.JAHPBDGDIGN },
            |m: &mut ABHNAFELEME| { &mut m.JAHPBDGDIGN },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OLNKGJDOECP",
            |m: &ABHNAFELEME| { &m.OLNKGJDOECP },
            |m: &mut ABHNAFELEME| { &mut m.OLNKGJDOECP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DAIBJMDJPKJ",
            |m: &ABHNAFELEME| { &m.DAIBJMDJPKJ },
            |m: &mut ABHNAFELEME| { &mut m.DAIBJMDJPKJ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "AOPBDFIBFPH",
            |m: &ABHNAFELEME| { &m.AOPBDFIBFPH },
            |m: &mut ABHNAFELEME| { &mut m.AOPBDFIBFPH },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "AEPOACPOGND",
            |m: &ABHNAFELEME| { &m.AEPOACPOGND },
            |m: &mut ABHNAFELEME| { &mut m.AEPOACPOGND },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "AFGIMCBOJFL",
            |m: &ABHNAFELEME| { &m.AFGIMCBOJFL },
            |m: &mut ABHNAFELEME| { &mut m.AFGIMCBOJFL },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ABHNAFELEME>(
            "ABHNAFELEME",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ABHNAFELEME {
    const NAME: &'static str = "ABHNAFELEME";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.PCPAFLJBGDD = is.read_int32()?;
                },
                24 => {
                    self.LGBCIKNKPOK = is.read_int32()?;
                },
                72 => {
                    self.JAHPBDGDIGN = is.read_int32()?;
                },
                112 => {
                    self.OLNKGJDOECP = is.read_int32()?;
                },
                40 => {
                    self.DAIBJMDJPKJ = is.read_int32()?;
                },
                32 => {
                    self.AOPBDFIBFPH = is.read_int32()?;
                },
                56 => {
                    self.AEPOACPOGND = is.read_int32()?;
                },
                96 => {
                    self.AFGIMCBOJFL = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.PCPAFLJBGDD != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.PCPAFLJBGDD);
        }
        if self.LGBCIKNKPOK != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.LGBCIKNKPOK);
        }
        if self.JAHPBDGDIGN != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.JAHPBDGDIGN);
        }
        if self.OLNKGJDOECP != 0 {
            my_size += ::protobuf::rt::int32_size(14, self.OLNKGJDOECP);
        }
        if self.DAIBJMDJPKJ != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.DAIBJMDJPKJ);
        }
        if self.AOPBDFIBFPH != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.AOPBDFIBFPH);
        }
        if self.AEPOACPOGND != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.AEPOACPOGND);
        }
        if self.AFGIMCBOJFL != 0 {
            my_size += ::protobuf::rt::int32_size(12, self.AFGIMCBOJFL);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.PCPAFLJBGDD != 0 {
            os.write_int32(2, self.PCPAFLJBGDD)?;
        }
        if self.LGBCIKNKPOK != 0 {
            os.write_int32(3, self.LGBCIKNKPOK)?;
        }
        if self.JAHPBDGDIGN != 0 {
            os.write_int32(9, self.JAHPBDGDIGN)?;
        }
        if self.OLNKGJDOECP != 0 {
            os.write_int32(14, self.OLNKGJDOECP)?;
        }
        if self.DAIBJMDJPKJ != 0 {
            os.write_int32(5, self.DAIBJMDJPKJ)?;
        }
        if self.AOPBDFIBFPH != 0 {
            os.write_int32(4, self.AOPBDFIBFPH)?;
        }
        if self.AEPOACPOGND != 0 {
            os.write_int32(7, self.AEPOACPOGND)?;
        }
        if self.AFGIMCBOJFL != 0 {
            os.write_int32(12, self.AFGIMCBOJFL)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ABHNAFELEME {
        ABHNAFELEME::new()
    }

    fn clear(&mut self) {
        self.PCPAFLJBGDD = 0;
        self.LGBCIKNKPOK = 0;
        self.JAHPBDGDIGN = 0;
        self.OLNKGJDOECP = 0;
        self.DAIBJMDJPKJ = 0;
        self.AOPBDFIBFPH = 0;
        self.AEPOACPOGND = 0;
        self.AFGIMCBOJFL = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ABHNAFELEME {
        static instance: ABHNAFELEME = ABHNAFELEME {
            PCPAFLJBGDD: 0,
            LGBCIKNKPOK: 0,
            JAHPBDGDIGN: 0,
            OLNKGJDOECP: 0,
            DAIBJMDJPKJ: 0,
            AOPBDFIBFPH: 0,
            AEPOACPOGND: 0,
            AFGIMCBOJFL: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ABHNAFELEME {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ABHNAFELEME").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ABHNAFELEME {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ABHNAFELEME {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PKGODKBNAAM)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PKGODKBNAAM {
    // special fields
    // @@protoc_insertion_point(special_field:PKGODKBNAAM.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PKGODKBNAAM {
    fn default() -> &'a PKGODKBNAAM {
        <PKGODKBNAAM as ::protobuf::Message>::default_instance()
    }
}

impl PKGODKBNAAM {
    pub fn new() -> PKGODKBNAAM {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PKGODKBNAAM>(
            "PKGODKBNAAM",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PKGODKBNAAM {
    const NAME: &'static str = "PKGODKBNAAM";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PKGODKBNAAM {
        PKGODKBNAAM::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PKGODKBNAAM {
        static instance: PKGODKBNAAM = PKGODKBNAAM {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PKGODKBNAAM {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PKGODKBNAAM").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PKGODKBNAAM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PKGODKBNAAM {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NJAHHFGIMBF)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NJAHHFGIMBF {
    // special fields
    // @@protoc_insertion_point(special_field:NJAHHFGIMBF.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NJAHHFGIMBF {
    fn default() -> &'a NJAHHFGIMBF {
        <NJAHHFGIMBF as ::protobuf::Message>::default_instance()
    }
}

impl NJAHHFGIMBF {
    pub fn new() -> NJAHHFGIMBF {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NJAHHFGIMBF>(
            "NJAHHFGIMBF",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NJAHHFGIMBF {
    const NAME: &'static str = "NJAHHFGIMBF";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NJAHHFGIMBF {
        NJAHHFGIMBF::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NJAHHFGIMBF {
        static instance: NJAHHFGIMBF = NJAHHFGIMBF {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NJAHHFGIMBF {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NJAHHFGIMBF").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NJAHHFGIMBF {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NJAHHFGIMBF {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NGFELCGLDGB)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NGFELCGLDGB {
    // message fields
    // @@protoc_insertion_point(field:NGFELCGLDGB.IAGJGJKGJBL)
    pub IAGJGJKGJBL: u32,
    // special fields
    // @@protoc_insertion_point(special_field:NGFELCGLDGB.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NGFELCGLDGB {
    fn default() -> &'a NGFELCGLDGB {
        <NGFELCGLDGB as ::protobuf::Message>::default_instance()
    }
}

impl NGFELCGLDGB {
    pub fn new() -> NGFELCGLDGB {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "IAGJGJKGJBL",
            |m: &NGFELCGLDGB| { &m.IAGJGJKGJBL },
            |m: &mut NGFELCGLDGB| { &mut m.IAGJGJKGJBL },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NGFELCGLDGB>(
            "NGFELCGLDGB",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NGFELCGLDGB {
    const NAME: &'static str = "NGFELCGLDGB";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.IAGJGJKGJBL = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.IAGJGJKGJBL != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.IAGJGJKGJBL);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.IAGJGJKGJBL != 0 {
            os.write_uint32(10, self.IAGJGJKGJBL)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NGFELCGLDGB {
        NGFELCGLDGB::new()
    }

    fn clear(&mut self) {
        self.IAGJGJKGJBL = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NGFELCGLDGB {
        static instance: NGFELCGLDGB = NGFELCGLDGB {
            IAGJGJKGJBL: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NGFELCGLDGB {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NGFELCGLDGB").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NGFELCGLDGB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NGFELCGLDGB {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:OALMPFHPFPK)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OALMPFHPFPK {
    // special fields
    // @@protoc_insertion_point(special_field:OALMPFHPFPK.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OALMPFHPFPK {
    fn default() -> &'a OALMPFHPFPK {
        <OALMPFHPFPK as ::protobuf::Message>::default_instance()
    }
}

impl OALMPFHPFPK {
    pub fn new() -> OALMPFHPFPK {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OALMPFHPFPK>(
            "OALMPFHPFPK",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OALMPFHPFPK {
    const NAME: &'static str = "OALMPFHPFPK";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OALMPFHPFPK {
        OALMPFHPFPK::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OALMPFHPFPK {
        static instance: OALMPFHPFPK = OALMPFHPFPK {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OALMPFHPFPK {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OALMPFHPFPK").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OALMPFHPFPK {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OALMPFHPFPK {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:OEJIIDGGGBO)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OEJIIDGGGBO {
    // message fields
    // @@protoc_insertion_point(field:OEJIIDGGGBO.LHMPHPEODNP)
    pub LHMPHPEODNP: u32,
    // @@protoc_insertion_point(field:OEJIIDGGGBO.NBBEBBCAKBE)
    pub NBBEBBCAKBE: bool,
    // special fields
    // @@protoc_insertion_point(special_field:OEJIIDGGGBO.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OEJIIDGGGBO {
    fn default() -> &'a OEJIIDGGGBO {
        <OEJIIDGGGBO as ::protobuf::Message>::default_instance()
    }
}

impl OEJIIDGGGBO {
    pub fn new() -> OEJIIDGGGBO {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LHMPHPEODNP",
            |m: &OEJIIDGGGBO| { &m.LHMPHPEODNP },
            |m: &mut OEJIIDGGGBO| { &mut m.LHMPHPEODNP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NBBEBBCAKBE",
            |m: &OEJIIDGGGBO| { &m.NBBEBBCAKBE },
            |m: &mut OEJIIDGGGBO| { &mut m.NBBEBBCAKBE },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OEJIIDGGGBO>(
            "OEJIIDGGGBO",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OEJIIDGGGBO {
    const NAME: &'static str = "OEJIIDGGGBO";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.LHMPHPEODNP = is.read_uint32()?;
                },
                40 => {
                    self.NBBEBBCAKBE = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.LHMPHPEODNP != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.LHMPHPEODNP);
        }
        if self.NBBEBBCAKBE != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.LHMPHPEODNP != 0 {
            os.write_uint32(4, self.LHMPHPEODNP)?;
        }
        if self.NBBEBBCAKBE != false {
            os.write_bool(5, self.NBBEBBCAKBE)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OEJIIDGGGBO {
        OEJIIDGGGBO::new()
    }

    fn clear(&mut self) {
        self.LHMPHPEODNP = 0;
        self.NBBEBBCAKBE = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OEJIIDGGGBO {
        static instance: OEJIIDGGGBO = OEJIIDGGGBO {
            LHMPHPEODNP: 0,
            NBBEBBCAKBE: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OEJIIDGGGBO {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OEJIIDGGGBO").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OEJIIDGGGBO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OEJIIDGGGBO {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BOIFCPNAOLC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BOIFCPNAOLC {
    // special fields
    // @@protoc_insertion_point(special_field:BOIFCPNAOLC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BOIFCPNAOLC {
    fn default() -> &'a BOIFCPNAOLC {
        <BOIFCPNAOLC as ::protobuf::Message>::default_instance()
    }
}

impl BOIFCPNAOLC {
    pub fn new() -> BOIFCPNAOLC {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BOIFCPNAOLC>(
            "BOIFCPNAOLC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BOIFCPNAOLC {
    const NAME: &'static str = "BOIFCPNAOLC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BOIFCPNAOLC {
        BOIFCPNAOLC::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BOIFCPNAOLC {
        static instance: BOIFCPNAOLC = BOIFCPNAOLC {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BOIFCPNAOLC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BOIFCPNAOLC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BOIFCPNAOLC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BOIFCPNAOLC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LFNDEHMBKNN)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LFNDEHMBKNN {
    // special fields
    // @@protoc_insertion_point(special_field:LFNDEHMBKNN.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LFNDEHMBKNN {
    fn default() -> &'a LFNDEHMBKNN {
        <LFNDEHMBKNN as ::protobuf::Message>::default_instance()
    }
}

impl LFNDEHMBKNN {
    pub fn new() -> LFNDEHMBKNN {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LFNDEHMBKNN>(
            "LFNDEHMBKNN",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LFNDEHMBKNN {
    const NAME: &'static str = "LFNDEHMBKNN";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LFNDEHMBKNN {
        LFNDEHMBKNN::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LFNDEHMBKNN {
        static instance: LFNDEHMBKNN = LFNDEHMBKNN {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LFNDEHMBKNN {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LFNDEHMBKNN").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LFNDEHMBKNN {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LFNDEHMBKNN {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ENGJLGMAOAC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ENGJLGMAOAC {
    // message fields
    // @@protoc_insertion_point(field:ENGJLGMAOAC.LHMPHPEODNP)
    pub LHMPHPEODNP: u32,
    // @@protoc_insertion_point(field:ENGJLGMAOAC.MIIDPLKIHDA)
    pub MIIDPLKIHDA: bool,
    // special fields
    // @@protoc_insertion_point(special_field:ENGJLGMAOAC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ENGJLGMAOAC {
    fn default() -> &'a ENGJLGMAOAC {
        <ENGJLGMAOAC as ::protobuf::Message>::default_instance()
    }
}

impl ENGJLGMAOAC {
    pub fn new() -> ENGJLGMAOAC {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LHMPHPEODNP",
            |m: &ENGJLGMAOAC| { &m.LHMPHPEODNP },
            |m: &mut ENGJLGMAOAC| { &mut m.LHMPHPEODNP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MIIDPLKIHDA",
            |m: &ENGJLGMAOAC| { &m.MIIDPLKIHDA },
            |m: &mut ENGJLGMAOAC| { &mut m.MIIDPLKIHDA },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ENGJLGMAOAC>(
            "ENGJLGMAOAC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ENGJLGMAOAC {
    const NAME: &'static str = "ENGJLGMAOAC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                40 => {
                    self.LHMPHPEODNP = is.read_uint32()?;
                },
                8 => {
                    self.MIIDPLKIHDA = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.LHMPHPEODNP != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.LHMPHPEODNP);
        }
        if self.MIIDPLKIHDA != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.LHMPHPEODNP != 0 {
            os.write_uint32(5, self.LHMPHPEODNP)?;
        }
        if self.MIIDPLKIHDA != false {
            os.write_bool(1, self.MIIDPLKIHDA)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ENGJLGMAOAC {
        ENGJLGMAOAC::new()
    }

    fn clear(&mut self) {
        self.LHMPHPEODNP = 0;
        self.MIIDPLKIHDA = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ENGJLGMAOAC {
        static instance: ENGJLGMAOAC = ENGJLGMAOAC {
            LHMPHPEODNP: 0,
            MIIDPLKIHDA: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ENGJLGMAOAC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ENGJLGMAOAC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ENGJLGMAOAC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ENGJLGMAOAC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BFDCFCKHILP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BFDCFCKHILP {
    // message fields
    // @@protoc_insertion_point(field:BFDCFCKHILP.action)
    pub action: ::protobuf::MessageField<HNADJAAFBMJ>,
    // @@protoc_insertion_point(field:BFDCFCKHILP.LGEKDBJJLNI)
    pub LGEKDBJJLNI: ::protobuf::EnumOrUnknown<IMPNHHHPMBA>,
    // special fields
    // @@protoc_insertion_point(special_field:BFDCFCKHILP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BFDCFCKHILP {
    fn default() -> &'a BFDCFCKHILP {
        <BFDCFCKHILP as ::protobuf::Message>::default_instance()
    }
}

impl BFDCFCKHILP {
    pub fn new() -> BFDCFCKHILP {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HNADJAAFBMJ>(
            "action",
            |m: &BFDCFCKHILP| { &m.action },
            |m: &mut BFDCFCKHILP| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LGEKDBJJLNI",
            |m: &BFDCFCKHILP| { &m.LGEKDBJJLNI },
            |m: &mut BFDCFCKHILP| { &mut m.LGEKDBJJLNI },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BFDCFCKHILP>(
            "BFDCFCKHILP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BFDCFCKHILP {
    const NAME: &'static str = "BFDCFCKHILP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.action)?;
                },
                112 => {
                    self.LGEKDBJJLNI = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.LGEKDBJJLNI != ::protobuf::EnumOrUnknown::new(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(14, self.LGEKDBJJLNI.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.action.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.LGEKDBJJLNI != ::protobuf::EnumOrUnknown::new(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_NONE) {
            os.write_enum(14, ::protobuf::EnumOrUnknown::value(&self.LGEKDBJJLNI))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BFDCFCKHILP {
        BFDCFCKHILP::new()
    }

    fn clear(&mut self) {
        self.action.clear();
        self.LGEKDBJJLNI = ::protobuf::EnumOrUnknown::new(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BFDCFCKHILP {
        static instance: BFDCFCKHILP = BFDCFCKHILP {
            action: ::protobuf::MessageField::none(),
            LGEKDBJJLNI: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BFDCFCKHILP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BFDCFCKHILP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BFDCFCKHILP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BFDCFCKHILP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HNADJAAFBMJ)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HNADJAAFBMJ {
    // message oneof groups
    pub KBKHABGINKB: ::std::option::Option<hnadjaafbmj::KBKHABGINKB>,
    // special fields
    // @@protoc_insertion_point(special_field:HNADJAAFBMJ.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HNADJAAFBMJ {
    fn default() -> &'a HNADJAAFBMJ {
        <HNADJAAFBMJ as ::protobuf::Message>::default_instance()
    }
}

impl HNADJAAFBMJ {
    pub fn new() -> HNADJAAFBMJ {
        ::std::default::Default::default()
    }

    // .EJNNNBLNJIC PEIIECHJBOH = 3;

    pub fn PEIIECHJBOH(&self) -> &EJNNNBLNJIC {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::PEIIECHJBOH(ref v)) => v,
            _ => <EJNNNBLNJIC as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_PEIIECHJBOH(&mut self) {
        self.KBKHABGINKB = ::std::option::Option::None;
    }

    pub fn has_PEIIECHJBOH(&self) -> bool {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::PEIIECHJBOH(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_PEIIECHJBOH(&mut self, v: EJNNNBLNJIC) {
        self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::PEIIECHJBOH(v))
    }

    // Mutable pointer to the field.
    pub fn mut_PEIIECHJBOH(&mut self) -> &mut EJNNNBLNJIC {
        if let ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::PEIIECHJBOH(_)) = self.KBKHABGINKB {
        } else {
            self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::PEIIECHJBOH(EJNNNBLNJIC::new()));
        }
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::PEIIECHJBOH(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_PEIIECHJBOH(&mut self) -> EJNNNBLNJIC {
        if self.has_PEIIECHJBOH() {
            match self.KBKHABGINKB.take() {
                ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::PEIIECHJBOH(v)) => v,
                _ => panic!(),
            }
        } else {
            EJNNNBLNJIC::new()
        }
    }

    // .HOFBPPLLJGJ LLBPGOIFDAD = 8;

    pub fn LLBPGOIFDAD(&self) -> &HOFBPPLLJGJ {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::LLBPGOIFDAD(ref v)) => v,
            _ => <HOFBPPLLJGJ as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_LLBPGOIFDAD(&mut self) {
        self.KBKHABGINKB = ::std::option::Option::None;
    }

    pub fn has_LLBPGOIFDAD(&self) -> bool {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::LLBPGOIFDAD(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_LLBPGOIFDAD(&mut self, v: HOFBPPLLJGJ) {
        self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::LLBPGOIFDAD(v))
    }

    // Mutable pointer to the field.
    pub fn mut_LLBPGOIFDAD(&mut self) -> &mut HOFBPPLLJGJ {
        if let ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::LLBPGOIFDAD(_)) = self.KBKHABGINKB {
        } else {
            self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::LLBPGOIFDAD(HOFBPPLLJGJ::new()));
        }
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::LLBPGOIFDAD(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_LLBPGOIFDAD(&mut self) -> HOFBPPLLJGJ {
        if self.has_LLBPGOIFDAD() {
            match self.KBKHABGINKB.take() {
                ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::LLBPGOIFDAD(v)) => v,
                _ => panic!(),
            }
        } else {
            HOFBPPLLJGJ::new()
        }
    }

    // .HOFBPPLLJGJ ILBOHKPGEBN = 15;

    pub fn ILBOHKPGEBN(&self) -> &HOFBPPLLJGJ {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::ILBOHKPGEBN(ref v)) => v,
            _ => <HOFBPPLLJGJ as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ILBOHKPGEBN(&mut self) {
        self.KBKHABGINKB = ::std::option::Option::None;
    }

    pub fn has_ILBOHKPGEBN(&self) -> bool {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::ILBOHKPGEBN(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ILBOHKPGEBN(&mut self, v: HOFBPPLLJGJ) {
        self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::ILBOHKPGEBN(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ILBOHKPGEBN(&mut self) -> &mut HOFBPPLLJGJ {
        if let ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::ILBOHKPGEBN(_)) = self.KBKHABGINKB {
        } else {
            self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::ILBOHKPGEBN(HOFBPPLLJGJ::new()));
        }
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::ILBOHKPGEBN(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ILBOHKPGEBN(&mut self) -> HOFBPPLLJGJ {
        if self.has_ILBOHKPGEBN() {
            match self.KBKHABGINKB.take() {
                ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::ILBOHKPGEBN(v)) => v,
                _ => panic!(),
            }
        } else {
            HOFBPPLLJGJ::new()
        }
    }

    // .ANDOCAGGDMH BJLIOIKGPCK = 14;

    pub fn BJLIOIKGPCK(&self) -> &ANDOCAGGDMH {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::BJLIOIKGPCK(ref v)) => v,
            _ => <ANDOCAGGDMH as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_BJLIOIKGPCK(&mut self) {
        self.KBKHABGINKB = ::std::option::Option::None;
    }

    pub fn has_BJLIOIKGPCK(&self) -> bool {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::BJLIOIKGPCK(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_BJLIOIKGPCK(&mut self, v: ANDOCAGGDMH) {
        self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::BJLIOIKGPCK(v))
    }

    // Mutable pointer to the field.
    pub fn mut_BJLIOIKGPCK(&mut self) -> &mut ANDOCAGGDMH {
        if let ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::BJLIOIKGPCK(_)) = self.KBKHABGINKB {
        } else {
            self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::BJLIOIKGPCK(ANDOCAGGDMH::new()));
        }
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::BJLIOIKGPCK(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_BJLIOIKGPCK(&mut self) -> ANDOCAGGDMH {
        if self.has_BJLIOIKGPCK() {
            match self.KBKHABGINKB.take() {
                ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::BJLIOIKGPCK(v)) => v,
                _ => panic!(),
            }
        } else {
            ANDOCAGGDMH::new()
        }
    }

    // .ANDOCAGGDMH BHCEKMIEFKC = 2;

    pub fn BHCEKMIEFKC(&self) -> &ANDOCAGGDMH {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::BHCEKMIEFKC(ref v)) => v,
            _ => <ANDOCAGGDMH as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_BHCEKMIEFKC(&mut self) {
        self.KBKHABGINKB = ::std::option::Option::None;
    }

    pub fn has_BHCEKMIEFKC(&self) -> bool {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::BHCEKMIEFKC(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_BHCEKMIEFKC(&mut self, v: ANDOCAGGDMH) {
        self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::BHCEKMIEFKC(v))
    }

    // Mutable pointer to the field.
    pub fn mut_BHCEKMIEFKC(&mut self) -> &mut ANDOCAGGDMH {
        if let ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::BHCEKMIEFKC(_)) = self.KBKHABGINKB {
        } else {
            self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::BHCEKMIEFKC(ANDOCAGGDMH::new()));
        }
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::BHCEKMIEFKC(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_BHCEKMIEFKC(&mut self) -> ANDOCAGGDMH {
        if self.has_BHCEKMIEFKC() {
            match self.KBKHABGINKB.take() {
                ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::BHCEKMIEFKC(v)) => v,
                _ => panic!(),
            }
        } else {
            ANDOCAGGDMH::new()
        }
    }

    // .EFLKKNBMPHB INMOIILMOJN = 5;

    pub fn INMOIILMOJN(&self) -> &EFLKKNBMPHB {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::INMOIILMOJN(ref v)) => v,
            _ => <EFLKKNBMPHB as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_INMOIILMOJN(&mut self) {
        self.KBKHABGINKB = ::std::option::Option::None;
    }

    pub fn has_INMOIILMOJN(&self) -> bool {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::INMOIILMOJN(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_INMOIILMOJN(&mut self, v: EFLKKNBMPHB) {
        self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::INMOIILMOJN(v))
    }

    // Mutable pointer to the field.
    pub fn mut_INMOIILMOJN(&mut self) -> &mut EFLKKNBMPHB {
        if let ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::INMOIILMOJN(_)) = self.KBKHABGINKB {
        } else {
            self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::INMOIILMOJN(EFLKKNBMPHB::new()));
        }
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::INMOIILMOJN(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_INMOIILMOJN(&mut self) -> EFLKKNBMPHB {
        if self.has_INMOIILMOJN() {
            match self.KBKHABGINKB.take() {
                ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::INMOIILMOJN(v)) => v,
                _ => panic!(),
            }
        } else {
            EFLKKNBMPHB::new()
        }
    }

    // .HNHNFFFGFJC LDMGDOGJKNC = 11;

    pub fn LDMGDOGJKNC(&self) -> &HNHNFFFGFJC {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::LDMGDOGJKNC(ref v)) => v,
            _ => <HNHNFFFGFJC as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_LDMGDOGJKNC(&mut self) {
        self.KBKHABGINKB = ::std::option::Option::None;
    }

    pub fn has_LDMGDOGJKNC(&self) -> bool {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::LDMGDOGJKNC(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_LDMGDOGJKNC(&mut self, v: HNHNFFFGFJC) {
        self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::LDMGDOGJKNC(v))
    }

    // Mutable pointer to the field.
    pub fn mut_LDMGDOGJKNC(&mut self) -> &mut HNHNFFFGFJC {
        if let ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::LDMGDOGJKNC(_)) = self.KBKHABGINKB {
        } else {
            self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::LDMGDOGJKNC(HNHNFFFGFJC::new()));
        }
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::LDMGDOGJKNC(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_LDMGDOGJKNC(&mut self) -> HNHNFFFGFJC {
        if self.has_LDMGDOGJKNC() {
            match self.KBKHABGINKB.take() {
                ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::LDMGDOGJKNC(v)) => v,
                _ => panic!(),
            }
        } else {
            HNHNFFFGFJC::new()
        }
    }

    // .OEJIIDGGGBO NOJFNAKKOJO = 10;

    pub fn NOJFNAKKOJO(&self) -> &OEJIIDGGGBO {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::NOJFNAKKOJO(ref v)) => v,
            _ => <OEJIIDGGGBO as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_NOJFNAKKOJO(&mut self) {
        self.KBKHABGINKB = ::std::option::Option::None;
    }

    pub fn has_NOJFNAKKOJO(&self) -> bool {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::NOJFNAKKOJO(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_NOJFNAKKOJO(&mut self, v: OEJIIDGGGBO) {
        self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::NOJFNAKKOJO(v))
    }

    // Mutable pointer to the field.
    pub fn mut_NOJFNAKKOJO(&mut self) -> &mut OEJIIDGGGBO {
        if let ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::NOJFNAKKOJO(_)) = self.KBKHABGINKB {
        } else {
            self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::NOJFNAKKOJO(OEJIIDGGGBO::new()));
        }
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::NOJFNAKKOJO(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_NOJFNAKKOJO(&mut self) -> OEJIIDGGGBO {
        if self.has_NOJFNAKKOJO() {
            match self.KBKHABGINKB.take() {
                ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::NOJFNAKKOJO(v)) => v,
                _ => panic!(),
            }
        } else {
            OEJIIDGGGBO::new()
        }
    }

    // .SwordTrainingEffectInfo DOBMEMOFBDE = 12;

    pub fn DOBMEMOFBDE(&self) -> &SwordTrainingEffectInfo {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::DOBMEMOFBDE(ref v)) => v,
            _ => <SwordTrainingEffectInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_DOBMEMOFBDE(&mut self) {
        self.KBKHABGINKB = ::std::option::Option::None;
    }

    pub fn has_DOBMEMOFBDE(&self) -> bool {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::DOBMEMOFBDE(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_DOBMEMOFBDE(&mut self, v: SwordTrainingEffectInfo) {
        self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::DOBMEMOFBDE(v))
    }

    // Mutable pointer to the field.
    pub fn mut_DOBMEMOFBDE(&mut self) -> &mut SwordTrainingEffectInfo {
        if let ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::DOBMEMOFBDE(_)) = self.KBKHABGINKB {
        } else {
            self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::DOBMEMOFBDE(SwordTrainingEffectInfo::new()));
        }
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::DOBMEMOFBDE(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_DOBMEMOFBDE(&mut self) -> SwordTrainingEffectInfo {
        if self.has_DOBMEMOFBDE() {
            match self.KBKHABGINKB.take() {
                ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::DOBMEMOFBDE(v)) => v,
                _ => panic!(),
            }
        } else {
            SwordTrainingEffectInfo::new()
        }
    }

    // .SwordTrainingEffectInfo FHFOFHBEIGI = 9;

    pub fn FHFOFHBEIGI(&self) -> &SwordTrainingEffectInfo {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::FHFOFHBEIGI(ref v)) => v,
            _ => <SwordTrainingEffectInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_FHFOFHBEIGI(&mut self) {
        self.KBKHABGINKB = ::std::option::Option::None;
    }

    pub fn has_FHFOFHBEIGI(&self) -> bool {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::FHFOFHBEIGI(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_FHFOFHBEIGI(&mut self, v: SwordTrainingEffectInfo) {
        self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::FHFOFHBEIGI(v))
    }

    // Mutable pointer to the field.
    pub fn mut_FHFOFHBEIGI(&mut self) -> &mut SwordTrainingEffectInfo {
        if let ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::FHFOFHBEIGI(_)) = self.KBKHABGINKB {
        } else {
            self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::FHFOFHBEIGI(SwordTrainingEffectInfo::new()));
        }
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::FHFOFHBEIGI(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_FHFOFHBEIGI(&mut self) -> SwordTrainingEffectInfo {
        if self.has_FHFOFHBEIGI() {
            match self.KBKHABGINKB.take() {
                ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::FHFOFHBEIGI(v)) => v,
                _ => panic!(),
            }
        } else {
            SwordTrainingEffectInfo::new()
        }
    }

    // .LCEMAIAAPCA KABMHIGOCHM = 1;

    pub fn KABMHIGOCHM(&self) -> &LCEMAIAAPCA {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::KABMHIGOCHM(ref v)) => v,
            _ => <LCEMAIAAPCA as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_KABMHIGOCHM(&mut self) {
        self.KBKHABGINKB = ::std::option::Option::None;
    }

    pub fn has_KABMHIGOCHM(&self) -> bool {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::KABMHIGOCHM(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_KABMHIGOCHM(&mut self, v: LCEMAIAAPCA) {
        self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::KABMHIGOCHM(v))
    }

    // Mutable pointer to the field.
    pub fn mut_KABMHIGOCHM(&mut self) -> &mut LCEMAIAAPCA {
        if let ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::KABMHIGOCHM(_)) = self.KBKHABGINKB {
        } else {
            self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::KABMHIGOCHM(LCEMAIAAPCA::new()));
        }
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::KABMHIGOCHM(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_KABMHIGOCHM(&mut self) -> LCEMAIAAPCA {
        if self.has_KABMHIGOCHM() {
            match self.KBKHABGINKB.take() {
                ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::KABMHIGOCHM(v)) => v,
                _ => panic!(),
            }
        } else {
            LCEMAIAAPCA::new()
        }
    }

    // uint32 DMOGPPBEFNA = 7;

    pub fn DMOGPPBEFNA(&self) -> u32 {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::DMOGPPBEFNA(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_DMOGPPBEFNA(&mut self) {
        self.KBKHABGINKB = ::std::option::Option::None;
    }

    pub fn has_DMOGPPBEFNA(&self) -> bool {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::DMOGPPBEFNA(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_DMOGPPBEFNA(&mut self, v: u32) {
        self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::DMOGPPBEFNA(v))
    }

    // uint32 combat_rank = 623;

    pub fn combat_rank(&self) -> u32 {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::CombatRank(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_combat_rank(&mut self) {
        self.KBKHABGINKB = ::std::option::Option::None;
    }

    pub fn has_combat_rank(&self) -> bool {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::CombatRank(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_combat_rank(&mut self, v: u32) {
        self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::CombatRank(v))
    }

    // .SwordTrainingStatusList IFBIMMDFOED = 1133;

    pub fn IFBIMMDFOED(&self) -> &SwordTrainingStatusList {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::IFBIMMDFOED(ref v)) => v,
            _ => <SwordTrainingStatusList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_IFBIMMDFOED(&mut self) {
        self.KBKHABGINKB = ::std::option::Option::None;
    }

    pub fn has_IFBIMMDFOED(&self) -> bool {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::IFBIMMDFOED(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_IFBIMMDFOED(&mut self, v: SwordTrainingStatusList) {
        self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::IFBIMMDFOED(v))
    }

    // Mutable pointer to the field.
    pub fn mut_IFBIMMDFOED(&mut self) -> &mut SwordTrainingStatusList {
        if let ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::IFBIMMDFOED(_)) = self.KBKHABGINKB {
        } else {
            self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::IFBIMMDFOED(SwordTrainingStatusList::new()));
        }
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::IFBIMMDFOED(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_IFBIMMDFOED(&mut self) -> SwordTrainingStatusList {
        if self.has_IFBIMMDFOED() {
            match self.KBKHABGINKB.take() {
                ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::IFBIMMDFOED(v)) => v,
                _ => panic!(),
            }
        } else {
            SwordTrainingStatusList::new()
        }
    }

    // .ENGJLGMAOAC KENCPJJECKL = 343;

    pub fn KENCPJJECKL(&self) -> &ENGJLGMAOAC {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::KENCPJJECKL(ref v)) => v,
            _ => <ENGJLGMAOAC as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_KENCPJJECKL(&mut self) {
        self.KBKHABGINKB = ::std::option::Option::None;
    }

    pub fn has_KENCPJJECKL(&self) -> bool {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::KENCPJJECKL(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_KENCPJJECKL(&mut self, v: ENGJLGMAOAC) {
        self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::KENCPJJECKL(v))
    }

    // Mutable pointer to the field.
    pub fn mut_KENCPJJECKL(&mut self) -> &mut ENGJLGMAOAC {
        if let ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::KENCPJJECKL(_)) = self.KBKHABGINKB {
        } else {
            self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::KENCPJJECKL(ENGJLGMAOAC::new()));
        }
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::KENCPJJECKL(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_KENCPJJECKL(&mut self) -> ENGJLGMAOAC {
        if self.has_KENCPJJECKL() {
            match self.KBKHABGINKB.take() {
                ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::KENCPJJECKL(v)) => v,
                _ => panic!(),
            }
        } else {
            ENGJLGMAOAC::new()
        }
    }

    // .BOIFCPNAOLC NHNNHJBBGAB = 747;

    pub fn NHNNHJBBGAB(&self) -> &BOIFCPNAOLC {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::NHNNHJBBGAB(ref v)) => v,
            _ => <BOIFCPNAOLC as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_NHNNHJBBGAB(&mut self) {
        self.KBKHABGINKB = ::std::option::Option::None;
    }

    pub fn has_NHNNHJBBGAB(&self) -> bool {
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::NHNNHJBBGAB(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_NHNNHJBBGAB(&mut self, v: BOIFCPNAOLC) {
        self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::NHNNHJBBGAB(v))
    }

    // Mutable pointer to the field.
    pub fn mut_NHNNHJBBGAB(&mut self) -> &mut BOIFCPNAOLC {
        if let ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::NHNNHJBBGAB(_)) = self.KBKHABGINKB {
        } else {
            self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::NHNNHJBBGAB(BOIFCPNAOLC::new()));
        }
        match self.KBKHABGINKB {
            ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::NHNNHJBBGAB(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_NHNNHJBBGAB(&mut self) -> BOIFCPNAOLC {
        if self.has_NHNNHJBBGAB() {
            match self.KBKHABGINKB.take() {
                ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::NHNNHJBBGAB(v)) => v,
                _ => panic!(),
            }
        } else {
            BOIFCPNAOLC::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, EJNNNBLNJIC>(
            "PEIIECHJBOH",
            HNADJAAFBMJ::has_PEIIECHJBOH,
            HNADJAAFBMJ::PEIIECHJBOH,
            HNADJAAFBMJ::mut_PEIIECHJBOH,
            HNADJAAFBMJ::set_PEIIECHJBOH,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HOFBPPLLJGJ>(
            "LLBPGOIFDAD",
            HNADJAAFBMJ::has_LLBPGOIFDAD,
            HNADJAAFBMJ::LLBPGOIFDAD,
            HNADJAAFBMJ::mut_LLBPGOIFDAD,
            HNADJAAFBMJ::set_LLBPGOIFDAD,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HOFBPPLLJGJ>(
            "ILBOHKPGEBN",
            HNADJAAFBMJ::has_ILBOHKPGEBN,
            HNADJAAFBMJ::ILBOHKPGEBN,
            HNADJAAFBMJ::mut_ILBOHKPGEBN,
            HNADJAAFBMJ::set_ILBOHKPGEBN,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ANDOCAGGDMH>(
            "BJLIOIKGPCK",
            HNADJAAFBMJ::has_BJLIOIKGPCK,
            HNADJAAFBMJ::BJLIOIKGPCK,
            HNADJAAFBMJ::mut_BJLIOIKGPCK,
            HNADJAAFBMJ::set_BJLIOIKGPCK,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ANDOCAGGDMH>(
            "BHCEKMIEFKC",
            HNADJAAFBMJ::has_BHCEKMIEFKC,
            HNADJAAFBMJ::BHCEKMIEFKC,
            HNADJAAFBMJ::mut_BHCEKMIEFKC,
            HNADJAAFBMJ::set_BHCEKMIEFKC,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, EFLKKNBMPHB>(
            "INMOIILMOJN",
            HNADJAAFBMJ::has_INMOIILMOJN,
            HNADJAAFBMJ::INMOIILMOJN,
            HNADJAAFBMJ::mut_INMOIILMOJN,
            HNADJAAFBMJ::set_INMOIILMOJN,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HNHNFFFGFJC>(
            "LDMGDOGJKNC",
            HNADJAAFBMJ::has_LDMGDOGJKNC,
            HNADJAAFBMJ::LDMGDOGJKNC,
            HNADJAAFBMJ::mut_LDMGDOGJKNC,
            HNADJAAFBMJ::set_LDMGDOGJKNC,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OEJIIDGGGBO>(
            "NOJFNAKKOJO",
            HNADJAAFBMJ::has_NOJFNAKKOJO,
            HNADJAAFBMJ::NOJFNAKKOJO,
            HNADJAAFBMJ::mut_NOJFNAKKOJO,
            HNADJAAFBMJ::set_NOJFNAKKOJO,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SwordTrainingEffectInfo>(
            "DOBMEMOFBDE",
            HNADJAAFBMJ::has_DOBMEMOFBDE,
            HNADJAAFBMJ::DOBMEMOFBDE,
            HNADJAAFBMJ::mut_DOBMEMOFBDE,
            HNADJAAFBMJ::set_DOBMEMOFBDE,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SwordTrainingEffectInfo>(
            "FHFOFHBEIGI",
            HNADJAAFBMJ::has_FHFOFHBEIGI,
            HNADJAAFBMJ::FHFOFHBEIGI,
            HNADJAAFBMJ::mut_FHFOFHBEIGI,
            HNADJAAFBMJ::set_FHFOFHBEIGI,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LCEMAIAAPCA>(
            "KABMHIGOCHM",
            HNADJAAFBMJ::has_KABMHIGOCHM,
            HNADJAAFBMJ::KABMHIGOCHM,
            HNADJAAFBMJ::mut_KABMHIGOCHM,
            HNADJAAFBMJ::set_KABMHIGOCHM,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "DMOGPPBEFNA",
            HNADJAAFBMJ::has_DMOGPPBEFNA,
            HNADJAAFBMJ::DMOGPPBEFNA,
            HNADJAAFBMJ::set_DMOGPPBEFNA,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "combat_rank",
            HNADJAAFBMJ::has_combat_rank,
            HNADJAAFBMJ::combat_rank,
            HNADJAAFBMJ::set_combat_rank,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SwordTrainingStatusList>(
            "IFBIMMDFOED",
            HNADJAAFBMJ::has_IFBIMMDFOED,
            HNADJAAFBMJ::IFBIMMDFOED,
            HNADJAAFBMJ::mut_IFBIMMDFOED,
            HNADJAAFBMJ::set_IFBIMMDFOED,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ENGJLGMAOAC>(
            "KENCPJJECKL",
            HNADJAAFBMJ::has_KENCPJJECKL,
            HNADJAAFBMJ::KENCPJJECKL,
            HNADJAAFBMJ::mut_KENCPJJECKL,
            HNADJAAFBMJ::set_KENCPJJECKL,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BOIFCPNAOLC>(
            "NHNNHJBBGAB",
            HNADJAAFBMJ::has_NHNNHJBBGAB,
            HNADJAAFBMJ::NHNNHJBBGAB,
            HNADJAAFBMJ::mut_NHNNHJBBGAB,
            HNADJAAFBMJ::set_NHNNHJBBGAB,
        ));
        oneofs.push(hnadjaafbmj::KBKHABGINKB::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HNADJAAFBMJ>(
            "HNADJAAFBMJ",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HNADJAAFBMJ {
    const NAME: &'static str = "HNADJAAFBMJ";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::PEIIECHJBOH(is.read_message()?));
                },
                66 => {
                    self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::LLBPGOIFDAD(is.read_message()?));
                },
                122 => {
                    self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::ILBOHKPGEBN(is.read_message()?));
                },
                114 => {
                    self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::BJLIOIKGPCK(is.read_message()?));
                },
                18 => {
                    self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::BHCEKMIEFKC(is.read_message()?));
                },
                42 => {
                    self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::INMOIILMOJN(is.read_message()?));
                },
                90 => {
                    self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::LDMGDOGJKNC(is.read_message()?));
                },
                82 => {
                    self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::NOJFNAKKOJO(is.read_message()?));
                },
                98 => {
                    self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::DOBMEMOFBDE(is.read_message()?));
                },
                74 => {
                    self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::FHFOFHBEIGI(is.read_message()?));
                },
                10 => {
                    self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::KABMHIGOCHM(is.read_message()?));
                },
                56 => {
                    self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::DMOGPPBEFNA(is.read_uint32()?));
                },
                4984 => {
                    self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::CombatRank(is.read_uint32()?));
                },
                9066 => {
                    self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::IFBIMMDFOED(is.read_message()?));
                },
                2746 => {
                    self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::KENCPJJECKL(is.read_message()?));
                },
                5978 => {
                    self.KBKHABGINKB = ::std::option::Option::Some(hnadjaafbmj::KBKHABGINKB::NHNNHJBBGAB(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.KBKHABGINKB {
            match v {
                &hnadjaafbmj::KBKHABGINKB::PEIIECHJBOH(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hnadjaafbmj::KBKHABGINKB::LLBPGOIFDAD(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hnadjaafbmj::KBKHABGINKB::ILBOHKPGEBN(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hnadjaafbmj::KBKHABGINKB::BJLIOIKGPCK(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hnadjaafbmj::KBKHABGINKB::BHCEKMIEFKC(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hnadjaafbmj::KBKHABGINKB::INMOIILMOJN(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hnadjaafbmj::KBKHABGINKB::LDMGDOGJKNC(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hnadjaafbmj::KBKHABGINKB::NOJFNAKKOJO(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hnadjaafbmj::KBKHABGINKB::DOBMEMOFBDE(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hnadjaafbmj::KBKHABGINKB::FHFOFHBEIGI(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hnadjaafbmj::KBKHABGINKB::KABMHIGOCHM(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hnadjaafbmj::KBKHABGINKB::DMOGPPBEFNA(v) => {
                    my_size += ::protobuf::rt::uint32_size(7, v);
                },
                &hnadjaafbmj::KBKHABGINKB::CombatRank(v) => {
                    my_size += ::protobuf::rt::uint32_size(623, v);
                },
                &hnadjaafbmj::KBKHABGINKB::IFBIMMDFOED(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hnadjaafbmj::KBKHABGINKB::KENCPJJECKL(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hnadjaafbmj::KBKHABGINKB::NHNNHJBBGAB(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.KBKHABGINKB {
            match v {
                &hnadjaafbmj::KBKHABGINKB::PEIIECHJBOH(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &hnadjaafbmj::KBKHABGINKB::LLBPGOIFDAD(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &hnadjaafbmj::KBKHABGINKB::ILBOHKPGEBN(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &hnadjaafbmj::KBKHABGINKB::BJLIOIKGPCK(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &hnadjaafbmj::KBKHABGINKB::BHCEKMIEFKC(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &hnadjaafbmj::KBKHABGINKB::INMOIILMOJN(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &hnadjaafbmj::KBKHABGINKB::LDMGDOGJKNC(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &hnadjaafbmj::KBKHABGINKB::NOJFNAKKOJO(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &hnadjaafbmj::KBKHABGINKB::DOBMEMOFBDE(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &hnadjaafbmj::KBKHABGINKB::FHFOFHBEIGI(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &hnadjaafbmj::KBKHABGINKB::KABMHIGOCHM(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &hnadjaafbmj::KBKHABGINKB::DMOGPPBEFNA(v) => {
                    os.write_uint32(7, v)?;
                },
                &hnadjaafbmj::KBKHABGINKB::CombatRank(v) => {
                    os.write_uint32(623, v)?;
                },
                &hnadjaafbmj::KBKHABGINKB::IFBIMMDFOED(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1133, v, os)?;
                },
                &hnadjaafbmj::KBKHABGINKB::KENCPJJECKL(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(343, v, os)?;
                },
                &hnadjaafbmj::KBKHABGINKB::NHNNHJBBGAB(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(747, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HNADJAAFBMJ {
        HNADJAAFBMJ::new()
    }

    fn clear(&mut self) {
        self.KBKHABGINKB = ::std::option::Option::None;
        self.KBKHABGINKB = ::std::option::Option::None;
        self.KBKHABGINKB = ::std::option::Option::None;
        self.KBKHABGINKB = ::std::option::Option::None;
        self.KBKHABGINKB = ::std::option::Option::None;
        self.KBKHABGINKB = ::std::option::Option::None;
        self.KBKHABGINKB = ::std::option::Option::None;
        self.KBKHABGINKB = ::std::option::Option::None;
        self.KBKHABGINKB = ::std::option::Option::None;
        self.KBKHABGINKB = ::std::option::Option::None;
        self.KBKHABGINKB = ::std::option::Option::None;
        self.KBKHABGINKB = ::std::option::Option::None;
        self.KBKHABGINKB = ::std::option::Option::None;
        self.KBKHABGINKB = ::std::option::Option::None;
        self.KBKHABGINKB = ::std::option::Option::None;
        self.KBKHABGINKB = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HNADJAAFBMJ {
        static instance: HNADJAAFBMJ = HNADJAAFBMJ {
            KBKHABGINKB: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HNADJAAFBMJ {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HNADJAAFBMJ").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HNADJAAFBMJ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HNADJAAFBMJ {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HNADJAAFBMJ`
pub mod hnadjaafbmj {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:HNADJAAFBMJ.KBKHABGINKB)
    pub enum KBKHABGINKB {
        // @@protoc_insertion_point(oneof_field:HNADJAAFBMJ.PEIIECHJBOH)
        PEIIECHJBOH(super::EJNNNBLNJIC),
        // @@protoc_insertion_point(oneof_field:HNADJAAFBMJ.LLBPGOIFDAD)
        LLBPGOIFDAD(super::HOFBPPLLJGJ),
        // @@protoc_insertion_point(oneof_field:HNADJAAFBMJ.ILBOHKPGEBN)
        ILBOHKPGEBN(super::HOFBPPLLJGJ),
        // @@protoc_insertion_point(oneof_field:HNADJAAFBMJ.BJLIOIKGPCK)
        BJLIOIKGPCK(super::ANDOCAGGDMH),
        // @@protoc_insertion_point(oneof_field:HNADJAAFBMJ.BHCEKMIEFKC)
        BHCEKMIEFKC(super::ANDOCAGGDMH),
        // @@protoc_insertion_point(oneof_field:HNADJAAFBMJ.INMOIILMOJN)
        INMOIILMOJN(super::EFLKKNBMPHB),
        // @@protoc_insertion_point(oneof_field:HNADJAAFBMJ.LDMGDOGJKNC)
        LDMGDOGJKNC(super::HNHNFFFGFJC),
        // @@protoc_insertion_point(oneof_field:HNADJAAFBMJ.NOJFNAKKOJO)
        NOJFNAKKOJO(super::OEJIIDGGGBO),
        // @@protoc_insertion_point(oneof_field:HNADJAAFBMJ.DOBMEMOFBDE)
        DOBMEMOFBDE(super::SwordTrainingEffectInfo),
        // @@protoc_insertion_point(oneof_field:HNADJAAFBMJ.FHFOFHBEIGI)
        FHFOFHBEIGI(super::SwordTrainingEffectInfo),
        // @@protoc_insertion_point(oneof_field:HNADJAAFBMJ.KABMHIGOCHM)
        KABMHIGOCHM(super::LCEMAIAAPCA),
        // @@protoc_insertion_point(oneof_field:HNADJAAFBMJ.DMOGPPBEFNA)
        DMOGPPBEFNA(u32),
        // @@protoc_insertion_point(oneof_field:HNADJAAFBMJ.combat_rank)
        CombatRank(u32),
        // @@protoc_insertion_point(oneof_field:HNADJAAFBMJ.IFBIMMDFOED)
        IFBIMMDFOED(super::SwordTrainingStatusList),
        // @@protoc_insertion_point(oneof_field:HNADJAAFBMJ.KENCPJJECKL)
        KENCPJJECKL(super::ENGJLGMAOAC),
        // @@protoc_insertion_point(oneof_field:HNADJAAFBMJ.NHNNHJBBGAB)
        NHNNHJBBGAB(super::BOIFCPNAOLC),
    }

    impl ::protobuf::Oneof for KBKHABGINKB {
    }

    impl ::protobuf::OneofFull for KBKHABGINKB {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::HNADJAAFBMJ as ::protobuf::MessageFull>::descriptor().oneof_by_name("KBKHABGINKB").unwrap()).clone()
        }
    }

    impl KBKHABGINKB {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<KBKHABGINKB>("KBKHABGINKB")
        }
    }
}

// @@protoc_insertion_point(message:KBKHABGINKB)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KBKHABGINKB {
    // message fields
    // @@protoc_insertion_point(field:KBKHABGINKB.PEIIECHJBOH)
    pub PEIIECHJBOH: i32,
    // @@protoc_insertion_point(field:KBKHABGINKB.LLBPGOIFDAD)
    pub LLBPGOIFDAD: i32,
    // @@protoc_insertion_point(field:KBKHABGINKB.ILBOHKPGEBN)
    pub ILBOHKPGEBN: i32,
    // @@protoc_insertion_point(field:KBKHABGINKB.BJLIOIKGPCK)
    pub BJLIOIKGPCK: i32,
    // @@protoc_insertion_point(field:KBKHABGINKB.BHCEKMIEFKC)
    pub BHCEKMIEFKC: i32,
    // @@protoc_insertion_point(field:KBKHABGINKB.INMOIILMOJN)
    pub INMOIILMOJN: i32,
    // @@protoc_insertion_point(field:KBKHABGINKB.LDMGDOGJKNC)
    pub LDMGDOGJKNC: i32,
    // @@protoc_insertion_point(field:KBKHABGINKB.NOJFNAKKOJO)
    pub NOJFNAKKOJO: i32,
    // @@protoc_insertion_point(field:KBKHABGINKB.DOBMEMOFBDE)
    pub DOBMEMOFBDE: i32,
    // @@protoc_insertion_point(field:KBKHABGINKB.FHFOFHBEIGI)
    pub FHFOFHBEIGI: i32,
    // @@protoc_insertion_point(field:KBKHABGINKB.KABMHIGOCHM)
    pub KABMHIGOCHM: i32,
    // @@protoc_insertion_point(field:KBKHABGINKB.DMOGPPBEFNA)
    pub DMOGPPBEFNA: i32,
    // @@protoc_insertion_point(field:KBKHABGINKB.combat_rank)
    pub combat_rank: i32,
    // @@protoc_insertion_point(field:KBKHABGINKB.IFBIMMDFOED)
    pub IFBIMMDFOED: i32,
    // @@protoc_insertion_point(field:KBKHABGINKB.KENCPJJECKL)
    pub KENCPJJECKL: i32,
    // @@protoc_insertion_point(field:KBKHABGINKB.NHNNHJBBGAB)
    pub NHNNHJBBGAB: i32,
    // special fields
    // @@protoc_insertion_point(special_field:KBKHABGINKB.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KBKHABGINKB {
    fn default() -> &'a KBKHABGINKB {
        <KBKHABGINKB as ::protobuf::Message>::default_instance()
    }
}

impl KBKHABGINKB {
    pub fn new() -> KBKHABGINKB {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PEIIECHJBOH",
            |m: &KBKHABGINKB| { &m.PEIIECHJBOH },
            |m: &mut KBKHABGINKB| { &mut m.PEIIECHJBOH },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LLBPGOIFDAD",
            |m: &KBKHABGINKB| { &m.LLBPGOIFDAD },
            |m: &mut KBKHABGINKB| { &mut m.LLBPGOIFDAD },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ILBOHKPGEBN",
            |m: &KBKHABGINKB| { &m.ILBOHKPGEBN },
            |m: &mut KBKHABGINKB| { &mut m.ILBOHKPGEBN },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "BJLIOIKGPCK",
            |m: &KBKHABGINKB| { &m.BJLIOIKGPCK },
            |m: &mut KBKHABGINKB| { &mut m.BJLIOIKGPCK },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "BHCEKMIEFKC",
            |m: &KBKHABGINKB| { &m.BHCEKMIEFKC },
            |m: &mut KBKHABGINKB| { &mut m.BHCEKMIEFKC },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "INMOIILMOJN",
            |m: &KBKHABGINKB| { &m.INMOIILMOJN },
            |m: &mut KBKHABGINKB| { &mut m.INMOIILMOJN },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LDMGDOGJKNC",
            |m: &KBKHABGINKB| { &m.LDMGDOGJKNC },
            |m: &mut KBKHABGINKB| { &mut m.LDMGDOGJKNC },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NOJFNAKKOJO",
            |m: &KBKHABGINKB| { &m.NOJFNAKKOJO },
            |m: &mut KBKHABGINKB| { &mut m.NOJFNAKKOJO },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DOBMEMOFBDE",
            |m: &KBKHABGINKB| { &m.DOBMEMOFBDE },
            |m: &mut KBKHABGINKB| { &mut m.DOBMEMOFBDE },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "FHFOFHBEIGI",
            |m: &KBKHABGINKB| { &m.FHFOFHBEIGI },
            |m: &mut KBKHABGINKB| { &mut m.FHFOFHBEIGI },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "KABMHIGOCHM",
            |m: &KBKHABGINKB| { &m.KABMHIGOCHM },
            |m: &mut KBKHABGINKB| { &mut m.KABMHIGOCHM },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DMOGPPBEFNA",
            |m: &KBKHABGINKB| { &m.DMOGPPBEFNA },
            |m: &mut KBKHABGINKB| { &mut m.DMOGPPBEFNA },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "combat_rank",
            |m: &KBKHABGINKB| { &m.combat_rank },
            |m: &mut KBKHABGINKB| { &mut m.combat_rank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "IFBIMMDFOED",
            |m: &KBKHABGINKB| { &m.IFBIMMDFOED },
            |m: &mut KBKHABGINKB| { &mut m.IFBIMMDFOED },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "KENCPJJECKL",
            |m: &KBKHABGINKB| { &m.KENCPJJECKL },
            |m: &mut KBKHABGINKB| { &mut m.KENCPJJECKL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NHNNHJBBGAB",
            |m: &KBKHABGINKB| { &m.NHNNHJBBGAB },
            |m: &mut KBKHABGINKB| { &mut m.NHNNHJBBGAB },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KBKHABGINKB>(
            "KBKHABGINKB",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KBKHABGINKB {
    const NAME: &'static str = "KBKHABGINKB";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.PEIIECHJBOH = is.read_int32()?;
                },
                64 => {
                    self.LLBPGOIFDAD = is.read_int32()?;
                },
                120 => {
                    self.ILBOHKPGEBN = is.read_int32()?;
                },
                112 => {
                    self.BJLIOIKGPCK = is.read_int32()?;
                },
                16 => {
                    self.BHCEKMIEFKC = is.read_int32()?;
                },
                40 => {
                    self.INMOIILMOJN = is.read_int32()?;
                },
                88 => {
                    self.LDMGDOGJKNC = is.read_int32()?;
                },
                80 => {
                    self.NOJFNAKKOJO = is.read_int32()?;
                },
                96 => {
                    self.DOBMEMOFBDE = is.read_int32()?;
                },
                72 => {
                    self.FHFOFHBEIGI = is.read_int32()?;
                },
                8 => {
                    self.KABMHIGOCHM = is.read_int32()?;
                },
                56 => {
                    self.DMOGPPBEFNA = is.read_int32()?;
                },
                4984 => {
                    self.combat_rank = is.read_int32()?;
                },
                9064 => {
                    self.IFBIMMDFOED = is.read_int32()?;
                },
                2744 => {
                    self.KENCPJJECKL = is.read_int32()?;
                },
                5976 => {
                    self.NHNNHJBBGAB = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.PEIIECHJBOH != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.PEIIECHJBOH);
        }
        if self.LLBPGOIFDAD != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.LLBPGOIFDAD);
        }
        if self.ILBOHKPGEBN != 0 {
            my_size += ::protobuf::rt::int32_size(15, self.ILBOHKPGEBN);
        }
        if self.BJLIOIKGPCK != 0 {
            my_size += ::protobuf::rt::int32_size(14, self.BJLIOIKGPCK);
        }
        if self.BHCEKMIEFKC != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.BHCEKMIEFKC);
        }
        if self.INMOIILMOJN != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.INMOIILMOJN);
        }
        if self.LDMGDOGJKNC != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.LDMGDOGJKNC);
        }
        if self.NOJFNAKKOJO != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.NOJFNAKKOJO);
        }
        if self.DOBMEMOFBDE != 0 {
            my_size += ::protobuf::rt::int32_size(12, self.DOBMEMOFBDE);
        }
        if self.FHFOFHBEIGI != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.FHFOFHBEIGI);
        }
        if self.KABMHIGOCHM != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.KABMHIGOCHM);
        }
        if self.DMOGPPBEFNA != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.DMOGPPBEFNA);
        }
        if self.combat_rank != 0 {
            my_size += ::protobuf::rt::int32_size(623, self.combat_rank);
        }
        if self.IFBIMMDFOED != 0 {
            my_size += ::protobuf::rt::int32_size(1133, self.IFBIMMDFOED);
        }
        if self.KENCPJJECKL != 0 {
            my_size += ::protobuf::rt::int32_size(343, self.KENCPJJECKL);
        }
        if self.NHNNHJBBGAB != 0 {
            my_size += ::protobuf::rt::int32_size(747, self.NHNNHJBBGAB);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.PEIIECHJBOH != 0 {
            os.write_int32(3, self.PEIIECHJBOH)?;
        }
        if self.LLBPGOIFDAD != 0 {
            os.write_int32(8, self.LLBPGOIFDAD)?;
        }
        if self.ILBOHKPGEBN != 0 {
            os.write_int32(15, self.ILBOHKPGEBN)?;
        }
        if self.BJLIOIKGPCK != 0 {
            os.write_int32(14, self.BJLIOIKGPCK)?;
        }
        if self.BHCEKMIEFKC != 0 {
            os.write_int32(2, self.BHCEKMIEFKC)?;
        }
        if self.INMOIILMOJN != 0 {
            os.write_int32(5, self.INMOIILMOJN)?;
        }
        if self.LDMGDOGJKNC != 0 {
            os.write_int32(11, self.LDMGDOGJKNC)?;
        }
        if self.NOJFNAKKOJO != 0 {
            os.write_int32(10, self.NOJFNAKKOJO)?;
        }
        if self.DOBMEMOFBDE != 0 {
            os.write_int32(12, self.DOBMEMOFBDE)?;
        }
        if self.FHFOFHBEIGI != 0 {
            os.write_int32(9, self.FHFOFHBEIGI)?;
        }
        if self.KABMHIGOCHM != 0 {
            os.write_int32(1, self.KABMHIGOCHM)?;
        }
        if self.DMOGPPBEFNA != 0 {
            os.write_int32(7, self.DMOGPPBEFNA)?;
        }
        if self.combat_rank != 0 {
            os.write_int32(623, self.combat_rank)?;
        }
        if self.IFBIMMDFOED != 0 {
            os.write_int32(1133, self.IFBIMMDFOED)?;
        }
        if self.KENCPJJECKL != 0 {
            os.write_int32(343, self.KENCPJJECKL)?;
        }
        if self.NHNNHJBBGAB != 0 {
            os.write_int32(747, self.NHNNHJBBGAB)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KBKHABGINKB {
        KBKHABGINKB::new()
    }

    fn clear(&mut self) {
        self.PEIIECHJBOH = 0;
        self.LLBPGOIFDAD = 0;
        self.ILBOHKPGEBN = 0;
        self.BJLIOIKGPCK = 0;
        self.BHCEKMIEFKC = 0;
        self.INMOIILMOJN = 0;
        self.LDMGDOGJKNC = 0;
        self.NOJFNAKKOJO = 0;
        self.DOBMEMOFBDE = 0;
        self.FHFOFHBEIGI = 0;
        self.KABMHIGOCHM = 0;
        self.DMOGPPBEFNA = 0;
        self.combat_rank = 0;
        self.IFBIMMDFOED = 0;
        self.KENCPJJECKL = 0;
        self.NHNNHJBBGAB = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KBKHABGINKB {
        static instance: KBKHABGINKB = KBKHABGINKB {
            PEIIECHJBOH: 0,
            LLBPGOIFDAD: 0,
            ILBOHKPGEBN: 0,
            BJLIOIKGPCK: 0,
            BHCEKMIEFKC: 0,
            INMOIILMOJN: 0,
            LDMGDOGJKNC: 0,
            NOJFNAKKOJO: 0,
            DOBMEMOFBDE: 0,
            FHFOFHBEIGI: 0,
            KABMHIGOCHM: 0,
            DMOGPPBEFNA: 0,
            combat_rank: 0,
            IFBIMMDFOED: 0,
            KENCPJJECKL: 0,
            NHNNHJBBGAB: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KBKHABGINKB {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KBKHABGINKB").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KBKHABGINKB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KBKHABGINKB {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LCEMAIAAPCA)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LCEMAIAAPCA {
    // message fields
    // @@protoc_insertion_point(field:LCEMAIAAPCA.IAGJGJKGJBL)
    pub IAGJGJKGJBL: u32,
    // special fields
    // @@protoc_insertion_point(special_field:LCEMAIAAPCA.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LCEMAIAAPCA {
    fn default() -> &'a LCEMAIAAPCA {
        <LCEMAIAAPCA as ::protobuf::Message>::default_instance()
    }
}

impl LCEMAIAAPCA {
    pub fn new() -> LCEMAIAAPCA {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "IAGJGJKGJBL",
            |m: &LCEMAIAAPCA| { &m.IAGJGJKGJBL },
            |m: &mut LCEMAIAAPCA| { &mut m.IAGJGJKGJBL },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LCEMAIAAPCA>(
            "LCEMAIAAPCA",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LCEMAIAAPCA {
    const NAME: &'static str = "LCEMAIAAPCA";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                56 => {
                    self.IAGJGJKGJBL = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.IAGJGJKGJBL != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.IAGJGJKGJBL);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.IAGJGJKGJBL != 0 {
            os.write_uint32(7, self.IAGJGJKGJBL)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LCEMAIAAPCA {
        LCEMAIAAPCA::new()
    }

    fn clear(&mut self) {
        self.IAGJGJKGJBL = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LCEMAIAAPCA {
        static instance: LCEMAIAAPCA = LCEMAIAAPCA {
            IAGJGJKGJBL: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LCEMAIAAPCA {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LCEMAIAAPCA").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LCEMAIAAPCA {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LCEMAIAAPCA {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EJNNNBLNJIC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EJNNNBLNJIC {
    // message fields
    // @@protoc_insertion_point(field:EJNNNBLNJIC.status_type)
    pub status_type: ::protobuf::EnumOrUnknown<SwordTrainingStatusType>,
    // @@protoc_insertion_point(field:EJNNNBLNJIC.ILGEENMAONM)
    pub ILGEENMAONM: u32,
    // @@protoc_insertion_point(field:EJNNNBLNJIC.PJHIPNNJDDP)
    pub PJHIPNNJDDP: u32,
    // special fields
    // @@protoc_insertion_point(special_field:EJNNNBLNJIC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EJNNNBLNJIC {
    fn default() -> &'a EJNNNBLNJIC {
        <EJNNNBLNJIC as ::protobuf::Message>::default_instance()
    }
}

impl EJNNNBLNJIC {
    pub fn new() -> EJNNNBLNJIC {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status_type",
            |m: &EJNNNBLNJIC| { &m.status_type },
            |m: &mut EJNNNBLNJIC| { &mut m.status_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ILGEENMAONM",
            |m: &EJNNNBLNJIC| { &m.ILGEENMAONM },
            |m: &mut EJNNNBLNJIC| { &mut m.ILGEENMAONM },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PJHIPNNJDDP",
            |m: &EJNNNBLNJIC| { &m.PJHIPNNJDDP },
            |m: &mut EJNNNBLNJIC| { &mut m.PJHIPNNJDDP },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EJNNNBLNJIC>(
            "EJNNNBLNJIC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EJNNNBLNJIC {
    const NAME: &'static str = "EJNNNBLNJIC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                120 => {
                    self.status_type = is.read_enum_or_unknown()?;
                },
                88 => {
                    self.ILGEENMAONM = is.read_uint32()?;
                },
                8 => {
                    self.PJHIPNNJDDP = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.status_type != ::protobuf::EnumOrUnknown::new(SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(15, self.status_type.value());
        }
        if self.ILGEENMAONM != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.ILGEENMAONM);
        }
        if self.PJHIPNNJDDP != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.PJHIPNNJDDP);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.status_type != ::protobuf::EnumOrUnknown::new(SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_NONE) {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&self.status_type))?;
        }
        if self.ILGEENMAONM != 0 {
            os.write_uint32(11, self.ILGEENMAONM)?;
        }
        if self.PJHIPNNJDDP != 0 {
            os.write_uint32(1, self.PJHIPNNJDDP)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EJNNNBLNJIC {
        EJNNNBLNJIC::new()
    }

    fn clear(&mut self) {
        self.status_type = ::protobuf::EnumOrUnknown::new(SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_NONE);
        self.ILGEENMAONM = 0;
        self.PJHIPNNJDDP = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EJNNNBLNJIC {
        static instance: EJNNNBLNJIC = EJNNNBLNJIC {
            status_type: ::protobuf::EnumOrUnknown::from_i32(0),
            ILGEENMAONM: 0,
            PJHIPNNJDDP: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EJNNNBLNJIC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EJNNNBLNJIC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EJNNNBLNJIC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EJNNNBLNJIC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HOFBPPLLJGJ)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HOFBPPLLJGJ {
    // message fields
    // @@protoc_insertion_point(field:HOFBPPLLJGJ.PJHIPNNJDDP)
    pub PJHIPNNJDDP: u32,
    // @@protoc_insertion_point(field:HOFBPPLLJGJ.ILGEENMAONM)
    pub ILGEENMAONM: u32,
    // special fields
    // @@protoc_insertion_point(special_field:HOFBPPLLJGJ.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HOFBPPLLJGJ {
    fn default() -> &'a HOFBPPLLJGJ {
        <HOFBPPLLJGJ as ::protobuf::Message>::default_instance()
    }
}

impl HOFBPPLLJGJ {
    pub fn new() -> HOFBPPLLJGJ {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PJHIPNNJDDP",
            |m: &HOFBPPLLJGJ| { &m.PJHIPNNJDDP },
            |m: &mut HOFBPPLLJGJ| { &mut m.PJHIPNNJDDP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ILGEENMAONM",
            |m: &HOFBPPLLJGJ| { &m.ILGEENMAONM },
            |m: &mut HOFBPPLLJGJ| { &mut m.ILGEENMAONM },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HOFBPPLLJGJ>(
            "HOFBPPLLJGJ",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HOFBPPLLJGJ {
    const NAME: &'static str = "HOFBPPLLJGJ";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.PJHIPNNJDDP = is.read_uint32()?;
                },
                56 => {
                    self.ILGEENMAONM = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.PJHIPNNJDDP != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.PJHIPNNJDDP);
        }
        if self.ILGEENMAONM != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.ILGEENMAONM);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.PJHIPNNJDDP != 0 {
            os.write_uint32(2, self.PJHIPNNJDDP)?;
        }
        if self.ILGEENMAONM != 0 {
            os.write_uint32(7, self.ILGEENMAONM)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HOFBPPLLJGJ {
        HOFBPPLLJGJ::new()
    }

    fn clear(&mut self) {
        self.PJHIPNNJDDP = 0;
        self.ILGEENMAONM = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HOFBPPLLJGJ {
        static instance: HOFBPPLLJGJ = HOFBPPLLJGJ {
            PJHIPNNJDDP: 0,
            ILGEENMAONM: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HOFBPPLLJGJ {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HOFBPPLLJGJ").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HOFBPPLLJGJ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HOFBPPLLJGJ {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ANDOCAGGDMH)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ANDOCAGGDMH {
    // message fields
    // @@protoc_insertion_point(field:ANDOCAGGDMH.ILGEENMAONM)
    pub ILGEENMAONM: u32,
    // @@protoc_insertion_point(field:ANDOCAGGDMH.PJHIPNNJDDP)
    pub PJHIPNNJDDP: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ANDOCAGGDMH.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ANDOCAGGDMH {
    fn default() -> &'a ANDOCAGGDMH {
        <ANDOCAGGDMH as ::protobuf::Message>::default_instance()
    }
}

impl ANDOCAGGDMH {
    pub fn new() -> ANDOCAGGDMH {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ILGEENMAONM",
            |m: &ANDOCAGGDMH| { &m.ILGEENMAONM },
            |m: &mut ANDOCAGGDMH| { &mut m.ILGEENMAONM },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PJHIPNNJDDP",
            |m: &ANDOCAGGDMH| { &m.PJHIPNNJDDP },
            |m: &mut ANDOCAGGDMH| { &mut m.PJHIPNNJDDP },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ANDOCAGGDMH>(
            "ANDOCAGGDMH",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ANDOCAGGDMH {
    const NAME: &'static str = "ANDOCAGGDMH";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.ILGEENMAONM = is.read_uint32()?;
                },
                48 => {
                    self.PJHIPNNJDDP = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ILGEENMAONM != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.ILGEENMAONM);
        }
        if self.PJHIPNNJDDP != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.PJHIPNNJDDP);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ILGEENMAONM != 0 {
            os.write_uint32(2, self.ILGEENMAONM)?;
        }
        if self.PJHIPNNJDDP != 0 {
            os.write_uint32(6, self.PJHIPNNJDDP)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ANDOCAGGDMH {
        ANDOCAGGDMH::new()
    }

    fn clear(&mut self) {
        self.ILGEENMAONM = 0;
        self.PJHIPNNJDDP = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ANDOCAGGDMH {
        static instance: ANDOCAGGDMH = ANDOCAGGDMH {
            ILGEENMAONM: 0,
            PJHIPNNJDDP: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ANDOCAGGDMH {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ANDOCAGGDMH").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ANDOCAGGDMH {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ANDOCAGGDMH {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EFLKKNBMPHB)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EFLKKNBMPHB {
    // message fields
    // @@protoc_insertion_point(field:EFLKKNBMPHB.level)
    pub level: u32,
    // @@protoc_insertion_point(field:EFLKKNBMPHB.unique_id)
    pub unique_id: u32,
    // @@protoc_insertion_point(field:EFLKKNBMPHB.AKDDEGHFEGG)
    pub AKDDEGHFEGG: u32,
    // special fields
    // @@protoc_insertion_point(special_field:EFLKKNBMPHB.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EFLKKNBMPHB {
    fn default() -> &'a EFLKKNBMPHB {
        <EFLKKNBMPHB as ::protobuf::Message>::default_instance()
    }
}

impl EFLKKNBMPHB {
    pub fn new() -> EFLKKNBMPHB {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "level",
            |m: &EFLKKNBMPHB| { &m.level },
            |m: &mut EFLKKNBMPHB| { &mut m.level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &EFLKKNBMPHB| { &m.unique_id },
            |m: &mut EFLKKNBMPHB| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "AKDDEGHFEGG",
            |m: &EFLKKNBMPHB| { &m.AKDDEGHFEGG },
            |m: &mut EFLKKNBMPHB| { &mut m.AKDDEGHFEGG },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EFLKKNBMPHB>(
            "EFLKKNBMPHB",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EFLKKNBMPHB {
    const NAME: &'static str = "EFLKKNBMPHB";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                120 => {
                    self.level = is.read_uint32()?;
                },
                88 => {
                    self.unique_id = is.read_uint32()?;
                },
                48 => {
                    self.AKDDEGHFEGG = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.level != 0 {
            my_size += ::protobuf::rt::uint32_size(15, self.level);
        }
        if self.unique_id != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.unique_id);
        }
        if self.AKDDEGHFEGG != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.AKDDEGHFEGG);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.level != 0 {
            os.write_uint32(15, self.level)?;
        }
        if self.unique_id != 0 {
            os.write_uint32(11, self.unique_id)?;
        }
        if self.AKDDEGHFEGG != 0 {
            os.write_uint32(6, self.AKDDEGHFEGG)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EFLKKNBMPHB {
        EFLKKNBMPHB::new()
    }

    fn clear(&mut self) {
        self.level = 0;
        self.unique_id = 0;
        self.AKDDEGHFEGG = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EFLKKNBMPHB {
        static instance: EFLKKNBMPHB = EFLKKNBMPHB {
            level: 0,
            unique_id: 0,
            AKDDEGHFEGG: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EFLKKNBMPHB {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EFLKKNBMPHB").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EFLKKNBMPHB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EFLKKNBMPHB {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HNHNFFFGFJC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HNHNFFFGFJC {
    // message fields
    // @@protoc_insertion_point(field:HNHNFFFGFJC.MGKDFNBENAI)
    pub MGKDFNBENAI: u32,
    // @@protoc_insertion_point(field:HNHNFFFGFJC.PCMAAKHAEBC)
    pub PCMAAKHAEBC: ::protobuf::MessageField<SwordTrainingTurnInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:HNHNFFFGFJC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HNHNFFFGFJC {
    fn default() -> &'a HNHNFFFGFJC {
        <HNHNFFFGFJC as ::protobuf::Message>::default_instance()
    }
}

impl HNHNFFFGFJC {
    pub fn new() -> HNHNFFFGFJC {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MGKDFNBENAI",
            |m: &HNHNFFFGFJC| { &m.MGKDFNBENAI },
            |m: &mut HNHNFFFGFJC| { &mut m.MGKDFNBENAI },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SwordTrainingTurnInfo>(
            "PCMAAKHAEBC",
            |m: &HNHNFFFGFJC| { &m.PCMAAKHAEBC },
            |m: &mut HNHNFFFGFJC| { &mut m.PCMAAKHAEBC },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HNHNFFFGFJC>(
            "HNHNFFFGFJC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HNHNFFFGFJC {
    const NAME: &'static str = "HNHNFFFGFJC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.MGKDFNBENAI = is.read_uint32()?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.PCMAAKHAEBC)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.MGKDFNBENAI != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.MGKDFNBENAI);
        }
        if let Some(v) = self.PCMAAKHAEBC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.MGKDFNBENAI != 0 {
            os.write_uint32(10, self.MGKDFNBENAI)?;
        }
        if let Some(v) = self.PCMAAKHAEBC.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HNHNFFFGFJC {
        HNHNFFFGFJC::new()
    }

    fn clear(&mut self) {
        self.MGKDFNBENAI = 0;
        self.PCMAAKHAEBC.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HNHNFFFGFJC {
        static instance: HNHNFFFGFJC = HNHNFFFGFJC {
            MGKDFNBENAI: 0,
            PCMAAKHAEBC: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HNHNFFFGFJC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HNHNFFFGFJC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HNHNFFFGFJC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HNHNFFFGFJC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BECAJOBHPIP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BECAJOBHPIP {
    // message fields
    // @@protoc_insertion_point(field:BECAJOBHPIP.LHMPHPEODNP)
    pub LHMPHPEODNP: u32,
    // @@protoc_insertion_point(field:BECAJOBHPIP.NBBEBBCAKBE)
    pub NBBEBBCAKBE: bool,
    // special fields
    // @@protoc_insertion_point(special_field:BECAJOBHPIP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BECAJOBHPIP {
    fn default() -> &'a BECAJOBHPIP {
        <BECAJOBHPIP as ::protobuf::Message>::default_instance()
    }
}

impl BECAJOBHPIP {
    pub fn new() -> BECAJOBHPIP {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LHMPHPEODNP",
            |m: &BECAJOBHPIP| { &m.LHMPHPEODNP },
            |m: &mut BECAJOBHPIP| { &mut m.LHMPHPEODNP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NBBEBBCAKBE",
            |m: &BECAJOBHPIP| { &m.NBBEBBCAKBE },
            |m: &mut BECAJOBHPIP| { &mut m.NBBEBBCAKBE },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BECAJOBHPIP>(
            "BECAJOBHPIP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BECAJOBHPIP {
    const NAME: &'static str = "BECAJOBHPIP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                112 => {
                    self.LHMPHPEODNP = is.read_uint32()?;
                },
                104 => {
                    self.NBBEBBCAKBE = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.LHMPHPEODNP != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.LHMPHPEODNP);
        }
        if self.NBBEBBCAKBE != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.LHMPHPEODNP != 0 {
            os.write_uint32(14, self.LHMPHPEODNP)?;
        }
        if self.NBBEBBCAKBE != false {
            os.write_bool(13, self.NBBEBBCAKBE)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BECAJOBHPIP {
        BECAJOBHPIP::new()
    }

    fn clear(&mut self) {
        self.LHMPHPEODNP = 0;
        self.NBBEBBCAKBE = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BECAJOBHPIP {
        static instance: BECAJOBHPIP = BECAJOBHPIP {
            LHMPHPEODNP: 0,
            NBBEBBCAKBE: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BECAJOBHPIP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BECAJOBHPIP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BECAJOBHPIP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BECAJOBHPIP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BFGHEKNAALJ)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BFGHEKNAALJ {
    // message fields
    // @@protoc_insertion_point(field:BFGHEKNAALJ.IPHCFMPAMNF)
    pub IPHCFMPAMNF: ::std::vec::Vec<BFDCFCKHILP>,
    // special fields
    // @@protoc_insertion_point(special_field:BFGHEKNAALJ.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BFGHEKNAALJ {
    fn default() -> &'a BFGHEKNAALJ {
        <BFGHEKNAALJ as ::protobuf::Message>::default_instance()
    }
}

impl BFGHEKNAALJ {
    pub fn new() -> BFGHEKNAALJ {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "IPHCFMPAMNF",
            |m: &BFGHEKNAALJ| { &m.IPHCFMPAMNF },
            |m: &mut BFGHEKNAALJ| { &mut m.IPHCFMPAMNF },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BFGHEKNAALJ>(
            "BFGHEKNAALJ",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BFGHEKNAALJ {
    const NAME: &'static str = "BFGHEKNAALJ";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                42 => {
                    self.IPHCFMPAMNF.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.IPHCFMPAMNF {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.IPHCFMPAMNF {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BFGHEKNAALJ {
        BFGHEKNAALJ::new()
    }

    fn clear(&mut self) {
        self.IPHCFMPAMNF.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BFGHEKNAALJ {
        static instance: BFGHEKNAALJ = BFGHEKNAALJ {
            IPHCFMPAMNF: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BFGHEKNAALJ {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BFGHEKNAALJ").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BFGHEKNAALJ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BFGHEKNAALJ {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DNLEFEGOBEG)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DNLEFEGOBEG {
    // message fields
    // @@protoc_insertion_point(field:DNLEFEGOBEG.progress)
    pub progress: u32,
    // @@protoc_insertion_point(field:DNLEFEGOBEG.id)
    pub id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:DNLEFEGOBEG.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DNLEFEGOBEG {
    fn default() -> &'a DNLEFEGOBEG {
        <DNLEFEGOBEG as ::protobuf::Message>::default_instance()
    }
}

impl DNLEFEGOBEG {
    pub fn new() -> DNLEFEGOBEG {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "progress",
            |m: &DNLEFEGOBEG| { &m.progress },
            |m: &mut DNLEFEGOBEG| { &mut m.progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &DNLEFEGOBEG| { &m.id },
            |m: &mut DNLEFEGOBEG| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DNLEFEGOBEG>(
            "DNLEFEGOBEG",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DNLEFEGOBEG {
    const NAME: &'static str = "DNLEFEGOBEG";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                56 => {
                    self.progress = is.read_uint32()?;
                },
                120 => {
                    self.id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.progress != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.progress);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(15, self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.progress != 0 {
            os.write_uint32(7, self.progress)?;
        }
        if self.id != 0 {
            os.write_uint32(15, self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DNLEFEGOBEG {
        DNLEFEGOBEG::new()
    }

    fn clear(&mut self) {
        self.progress = 0;
        self.id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DNLEFEGOBEG {
        static instance: DNLEFEGOBEG = DNLEFEGOBEG {
            progress: 0,
            id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DNLEFEGOBEG {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DNLEFEGOBEG").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DNLEFEGOBEG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DNLEFEGOBEG {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:KOBFGKFDMJE)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KOBFGKFDMJE {
    // message fields
    // @@protoc_insertion_point(field:KOBFGKFDMJE.FGCDDCJHIAG)
    pub FGCDDCJHIAG: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:KOBFGKFDMJE.AKPGGHKCAIF)
    pub AKPGGHKCAIF: ::std::vec::Vec<DNLEFEGOBEG>,
    // special fields
    // @@protoc_insertion_point(special_field:KOBFGKFDMJE.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KOBFGKFDMJE {
    fn default() -> &'a KOBFGKFDMJE {
        <KOBFGKFDMJE as ::protobuf::Message>::default_instance()
    }
}

impl KOBFGKFDMJE {
    pub fn new() -> KOBFGKFDMJE {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "FGCDDCJHIAG",
            |m: &KOBFGKFDMJE| { &m.FGCDDCJHIAG },
            |m: &mut KOBFGKFDMJE| { &mut m.FGCDDCJHIAG },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "AKPGGHKCAIF",
            |m: &KOBFGKFDMJE| { &m.AKPGGHKCAIF },
            |m: &mut KOBFGKFDMJE| { &mut m.AKPGGHKCAIF },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KOBFGKFDMJE>(
            "KOBFGKFDMJE",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KOBFGKFDMJE {
    const NAME: &'static str = "KOBFGKFDMJE";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.FGCDDCJHIAG)?;
                },
                40 => {
                    self.FGCDDCJHIAG.push(is.read_uint32()?);
                },
                90 => {
                    self.AKPGGHKCAIF.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.FGCDDCJHIAG {
            my_size += ::protobuf::rt::uint32_size(5, *value);
        };
        for value in &self.AKPGGHKCAIF {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.FGCDDCJHIAG {
            os.write_uint32(5, *v)?;
        };
        for v in &self.AKPGGHKCAIF {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KOBFGKFDMJE {
        KOBFGKFDMJE::new()
    }

    fn clear(&mut self) {
        self.FGCDDCJHIAG.clear();
        self.AKPGGHKCAIF.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KOBFGKFDMJE {
        static instance: KOBFGKFDMJE = KOBFGKFDMJE {
            FGCDDCJHIAG: ::std::vec::Vec::new(),
            AKPGGHKCAIF: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KOBFGKFDMJE {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KOBFGKFDMJE").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KOBFGKFDMJE {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KOBFGKFDMJE {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetSwordTrainingDataCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetSwordTrainingDataCsReq {
    // special fields
    // @@protoc_insertion_point(special_field:GetSwordTrainingDataCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSwordTrainingDataCsReq {
    fn default() -> &'a GetSwordTrainingDataCsReq {
        <GetSwordTrainingDataCsReq as ::protobuf::Message>::default_instance()
    }
}

impl GetSwordTrainingDataCsReq {
    pub fn new() -> GetSwordTrainingDataCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSwordTrainingDataCsReq>(
            "GetSwordTrainingDataCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSwordTrainingDataCsReq {
    const NAME: &'static str = "GetSwordTrainingDataCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSwordTrainingDataCsReq {
        GetSwordTrainingDataCsReq::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSwordTrainingDataCsReq {
        static instance: GetSwordTrainingDataCsReq = GetSwordTrainingDataCsReq {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSwordTrainingDataCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSwordTrainingDataCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSwordTrainingDataCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSwordTrainingDataCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetSwordTrainingDataScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetSwordTrainingDataScRsp {
    // message fields
    // @@protoc_insertion_point(field:GetSwordTrainingDataScRsp.story_id_list)
    pub story_id_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:GetSwordTrainingDataScRsp.game_info)
    pub game_info: ::protobuf::MessageField<SwordTrainingGameInfo>,
    // @@protoc_insertion_point(field:GetSwordTrainingDataScRsp.AILAGENLDGI)
    pub AILAGENLDGI: u32,
    // @@protoc_insertion_point(field:GetSwordTrainingDataScRsp.DIGIDEKCKPF)
    pub DIGIDEKCKPF: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:GetSwordTrainingDataScRsp.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:GetSwordTrainingDataScRsp.IMJLPHEJMBB)
    pub IMJLPHEJMBB: ::protobuf::MessageField<KOBFGKFDMJE>,
    // @@protoc_insertion_point(field:GetSwordTrainingDataScRsp.DPHNBKLJEHM)
    pub DPHNBKLJEHM: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:GetSwordTrainingDataScRsp.BNNIMFGFOAH)
    pub BNNIMFGFOAH: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:GetSwordTrainingDataScRsp.GBDANLKCLMG)
    pub GBDANLKCLMG: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:GetSwordTrainingDataScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSwordTrainingDataScRsp {
    fn default() -> &'a GetSwordTrainingDataScRsp {
        <GetSwordTrainingDataScRsp as ::protobuf::Message>::default_instance()
    }
}

impl GetSwordTrainingDataScRsp {
    pub fn new() -> GetSwordTrainingDataScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "story_id_list",
            |m: &GetSwordTrainingDataScRsp| { &m.story_id_list },
            |m: &mut GetSwordTrainingDataScRsp| { &mut m.story_id_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SwordTrainingGameInfo>(
            "game_info",
            |m: &GetSwordTrainingDataScRsp| { &m.game_info },
            |m: &mut GetSwordTrainingDataScRsp| { &mut m.game_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "AILAGENLDGI",
            |m: &GetSwordTrainingDataScRsp| { &m.AILAGENLDGI },
            |m: &mut GetSwordTrainingDataScRsp| { &mut m.AILAGENLDGI },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "DIGIDEKCKPF",
            |m: &GetSwordTrainingDataScRsp| { &m.DIGIDEKCKPF },
            |m: &mut GetSwordTrainingDataScRsp| { &mut m.DIGIDEKCKPF },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &GetSwordTrainingDataScRsp| { &m.retcode },
            |m: &mut GetSwordTrainingDataScRsp| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KOBFGKFDMJE>(
            "IMJLPHEJMBB",
            |m: &GetSwordTrainingDataScRsp| { &m.IMJLPHEJMBB },
            |m: &mut GetSwordTrainingDataScRsp| { &mut m.IMJLPHEJMBB },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "DPHNBKLJEHM",
            |m: &GetSwordTrainingDataScRsp| { &m.DPHNBKLJEHM },
            |m: &mut GetSwordTrainingDataScRsp| { &mut m.DPHNBKLJEHM },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "BNNIMFGFOAH",
            |m: &GetSwordTrainingDataScRsp| { &m.BNNIMFGFOAH },
            |m: &mut GetSwordTrainingDataScRsp| { &mut m.BNNIMFGFOAH },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "GBDANLKCLMG",
            |m: &GetSwordTrainingDataScRsp| { &m.GBDANLKCLMG },
            |m: &mut GetSwordTrainingDataScRsp| { &mut m.GBDANLKCLMG },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSwordTrainingDataScRsp>(
            "GetSwordTrainingDataScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSwordTrainingDataScRsp {
    const NAME: &'static str = "GetSwordTrainingDataScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                106 => {
                    is.read_repeated_packed_uint32_into(&mut self.story_id_list)?;
                },
                104 => {
                    self.story_id_list.push(is.read_uint32()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_info)?;
                },
                64 => {
                    self.AILAGENLDGI = is.read_uint32()?;
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.DIGIDEKCKPF)?;
                },
                40 => {
                    self.DIGIDEKCKPF.push(is.read_uint32()?);
                },
                96 => {
                    self.retcode = is.read_uint32()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.IMJLPHEJMBB)?;
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.DPHNBKLJEHM)?;
                },
                72 => {
                    self.DPHNBKLJEHM.push(is.read_uint32()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.BNNIMFGFOAH)?;
                },
                80 => {
                    self.BNNIMFGFOAH.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.GBDANLKCLMG)?;
                },
                16 => {
                    self.GBDANLKCLMG.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.story_id_list {
            my_size += ::protobuf::rt::uint32_size(13, *value);
        };
        if let Some(v) = self.game_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.AILAGENLDGI != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.AILAGENLDGI);
        }
        for value in &self.DIGIDEKCKPF {
            my_size += ::protobuf::rt::uint32_size(5, *value);
        };
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.retcode);
        }
        if let Some(v) = self.IMJLPHEJMBB.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.DPHNBKLJEHM {
            my_size += ::protobuf::rt::uint32_size(9, *value);
        };
        for value in &self.BNNIMFGFOAH {
            my_size += ::protobuf::rt::uint32_size(10, *value);
        };
        for value in &self.GBDANLKCLMG {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.story_id_list {
            os.write_uint32(13, *v)?;
        };
        if let Some(v) = self.game_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if self.AILAGENLDGI != 0 {
            os.write_uint32(8, self.AILAGENLDGI)?;
        }
        for v in &self.DIGIDEKCKPF {
            os.write_uint32(5, *v)?;
        };
        if self.retcode != 0 {
            os.write_uint32(12, self.retcode)?;
        }
        if let Some(v) = self.IMJLPHEJMBB.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.DPHNBKLJEHM {
            os.write_uint32(9, *v)?;
        };
        for v in &self.BNNIMFGFOAH {
            os.write_uint32(10, *v)?;
        };
        for v in &self.GBDANLKCLMG {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSwordTrainingDataScRsp {
        GetSwordTrainingDataScRsp::new()
    }

    fn clear(&mut self) {
        self.story_id_list.clear();
        self.game_info.clear();
        self.AILAGENLDGI = 0;
        self.DIGIDEKCKPF.clear();
        self.retcode = 0;
        self.IMJLPHEJMBB.clear();
        self.DPHNBKLJEHM.clear();
        self.BNNIMFGFOAH.clear();
        self.GBDANLKCLMG.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSwordTrainingDataScRsp {
        static instance: GetSwordTrainingDataScRsp = GetSwordTrainingDataScRsp {
            story_id_list: ::std::vec::Vec::new(),
            game_info: ::protobuf::MessageField::none(),
            AILAGENLDGI: 0,
            DIGIDEKCKPF: ::std::vec::Vec::new(),
            retcode: 0,
            IMJLPHEJMBB: ::protobuf::MessageField::none(),
            DPHNBKLJEHM: ::std::vec::Vec::new(),
            BNNIMFGFOAH: ::std::vec::Vec::new(),
            GBDANLKCLMG: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSwordTrainingDataScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSwordTrainingDataScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSwordTrainingDataScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSwordTrainingDataScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:IOMJGKBIAFK)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IOMJGKBIAFK {
    // message fields
    // @@protoc_insertion_point(field:IOMJGKBIAFK.ECFPHAADBDI)
    pub ECFPHAADBDI: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:IOMJGKBIAFK.AOBGMOJOFLP)
    pub AOBGMOJOFLP: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:IOMJGKBIAFK.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IOMJGKBIAFK {
    fn default() -> &'a IOMJGKBIAFK {
        <IOMJGKBIAFK as ::protobuf::Message>::default_instance()
    }
}

impl IOMJGKBIAFK {
    pub fn new() -> IOMJGKBIAFK {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ECFPHAADBDI",
            |m: &IOMJGKBIAFK| { &m.ECFPHAADBDI },
            |m: &mut IOMJGKBIAFK| { &mut m.ECFPHAADBDI },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "AOBGMOJOFLP",
            |m: &IOMJGKBIAFK| { &m.AOBGMOJOFLP },
            |m: &mut IOMJGKBIAFK| { &mut m.AOBGMOJOFLP },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IOMJGKBIAFK>(
            "IOMJGKBIAFK",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IOMJGKBIAFK {
    const NAME: &'static str = "IOMJGKBIAFK";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.ECFPHAADBDI)?;
                },
                24 => {
                    self.ECFPHAADBDI.push(is.read_uint32()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.AOBGMOJOFLP)?;
                },
                72 => {
                    self.AOBGMOJOFLP.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ECFPHAADBDI {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        for value in &self.AOBGMOJOFLP {
            my_size += ::protobuf::rt::uint32_size(9, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ECFPHAADBDI {
            os.write_uint32(3, *v)?;
        };
        for v in &self.AOBGMOJOFLP {
            os.write_uint32(9, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IOMJGKBIAFK {
        IOMJGKBIAFK::new()
    }

    fn clear(&mut self) {
        self.ECFPHAADBDI.clear();
        self.AOBGMOJOFLP.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IOMJGKBIAFK {
        static instance: IOMJGKBIAFK = IOMJGKBIAFK {
            ECFPHAADBDI: ::std::vec::Vec::new(),
            AOBGMOJOFLP: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IOMJGKBIAFK {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IOMJGKBIAFK").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IOMJGKBIAFK {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IOMJGKBIAFK {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:IGBCHKMINLM)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IGBCHKMINLM {
    // message fields
    // @@protoc_insertion_point(field:IGBCHKMINLM.AOBGMOJOFLP)
    pub AOBGMOJOFLP: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:IGBCHKMINLM.retcode)
    pub retcode: u32,
    // special fields
    // @@protoc_insertion_point(special_field:IGBCHKMINLM.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IGBCHKMINLM {
    fn default() -> &'a IGBCHKMINLM {
        <IGBCHKMINLM as ::protobuf::Message>::default_instance()
    }
}

impl IGBCHKMINLM {
    pub fn new() -> IGBCHKMINLM {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "AOBGMOJOFLP",
            |m: &IGBCHKMINLM| { &m.AOBGMOJOFLP },
            |m: &mut IGBCHKMINLM| { &mut m.AOBGMOJOFLP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &IGBCHKMINLM| { &m.retcode },
            |m: &mut IGBCHKMINLM| { &mut m.retcode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IGBCHKMINLM>(
            "IGBCHKMINLM",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IGBCHKMINLM {
    const NAME: &'static str = "IGBCHKMINLM";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.AOBGMOJOFLP)?;
                },
                72 => {
                    self.AOBGMOJOFLP.push(is.read_uint32()?);
                },
                88 => {
                    self.retcode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.AOBGMOJOFLP {
            my_size += ::protobuf::rt::uint32_size(9, *value);
        };
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.retcode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.AOBGMOJOFLP {
            os.write_uint32(9, *v)?;
        };
        if self.retcode != 0 {
            os.write_uint32(11, self.retcode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IGBCHKMINLM {
        IGBCHKMINLM::new()
    }

    fn clear(&mut self) {
        self.AOBGMOJOFLP.clear();
        self.retcode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IGBCHKMINLM {
        static instance: IGBCHKMINLM = IGBCHKMINLM {
            AOBGMOJOFLP: ::std::vec::Vec::new(),
            retcode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IGBCHKMINLM {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IGBCHKMINLM").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IGBCHKMINLM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IGBCHKMINLM {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LANKBIELLHP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LANKBIELLHP {
    // message fields
    // @@protoc_insertion_point(field:LANKBIELLHP.ADENLFJOOPL)
    pub ADENLFJOOPL: u32,
    // special fields
    // @@protoc_insertion_point(special_field:LANKBIELLHP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LANKBIELLHP {
    fn default() -> &'a LANKBIELLHP {
        <LANKBIELLHP as ::protobuf::Message>::default_instance()
    }
}

impl LANKBIELLHP {
    pub fn new() -> LANKBIELLHP {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ADENLFJOOPL",
            |m: &LANKBIELLHP| { &m.ADENLFJOOPL },
            |m: &mut LANKBIELLHP| { &mut m.ADENLFJOOPL },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LANKBIELLHP>(
            "LANKBIELLHP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LANKBIELLHP {
    const NAME: &'static str = "LANKBIELLHP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                104 => {
                    self.ADENLFJOOPL = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ADENLFJOOPL != 0 {
            my_size += ::protobuf::rt::uint32_size(13, self.ADENLFJOOPL);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ADENLFJOOPL != 0 {
            os.write_uint32(13, self.ADENLFJOOPL)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LANKBIELLHP {
        LANKBIELLHP::new()
    }

    fn clear(&mut self) {
        self.ADENLFJOOPL = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LANKBIELLHP {
        static instance: LANKBIELLHP = LANKBIELLHP {
            ADENLFJOOPL: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LANKBIELLHP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LANKBIELLHP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LANKBIELLHP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LANKBIELLHP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EACNAKCAJHP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EACNAKCAJHP {
    // message fields
    // @@protoc_insertion_point(field:EACNAKCAJHP.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:EACNAKCAJHP.DBJOEONEGCE)
    pub DBJOEONEGCE: ::protobuf::MessageField<SwordTrainingPartnerAbility>,
    // special fields
    // @@protoc_insertion_point(special_field:EACNAKCAJHP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EACNAKCAJHP {
    fn default() -> &'a EACNAKCAJHP {
        <EACNAKCAJHP as ::protobuf::Message>::default_instance()
    }
}

impl EACNAKCAJHP {
    pub fn new() -> EACNAKCAJHP {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &EACNAKCAJHP| { &m.retcode },
            |m: &mut EACNAKCAJHP| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SwordTrainingPartnerAbility>(
            "DBJOEONEGCE",
            |m: &EACNAKCAJHP| { &m.DBJOEONEGCE },
            |m: &mut EACNAKCAJHP| { &mut m.DBJOEONEGCE },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EACNAKCAJHP>(
            "EACNAKCAJHP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EACNAKCAJHP {
    const NAME: &'static str = "EACNAKCAJHP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                96 => {
                    self.retcode = is.read_uint32()?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.DBJOEONEGCE)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.retcode);
        }
        if let Some(v) = self.DBJOEONEGCE.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(12, self.retcode)?;
        }
        if let Some(v) = self.DBJOEONEGCE.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EACNAKCAJHP {
        EACNAKCAJHP::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.DBJOEONEGCE.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EACNAKCAJHP {
        static instance: EACNAKCAJHP = EACNAKCAJHP {
            retcode: 0,
            DBJOEONEGCE: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EACNAKCAJHP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EACNAKCAJHP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EACNAKCAJHP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EACNAKCAJHP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:JJLLFHOLLGC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct JJLLFHOLLGC {
    // message fields
    // @@protoc_insertion_point(field:JJLLFHOLLGC.MDPMCJGPIIO)
    pub MDPMCJGPIIO: ::protobuf::EnumOrUnknown<SwordTrainingDailyPhaseType>,
    // special fields
    // @@protoc_insertion_point(special_field:JJLLFHOLLGC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a JJLLFHOLLGC {
    fn default() -> &'a JJLLFHOLLGC {
        <JJLLFHOLLGC as ::protobuf::Message>::default_instance()
    }
}

impl JJLLFHOLLGC {
    pub fn new() -> JJLLFHOLLGC {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MDPMCJGPIIO",
            |m: &JJLLFHOLLGC| { &m.MDPMCJGPIIO },
            |m: &mut JJLLFHOLLGC| { &mut m.MDPMCJGPIIO },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JJLLFHOLLGC>(
            "JJLLFHOLLGC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for JJLLFHOLLGC {
    const NAME: &'static str = "JJLLFHOLLGC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                40 => {
                    self.MDPMCJGPIIO = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.MDPMCJGPIIO != ::protobuf::EnumOrUnknown::new(SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(5, self.MDPMCJGPIIO.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.MDPMCJGPIIO != ::protobuf::EnumOrUnknown::new(SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_NONE) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.MDPMCJGPIIO))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> JJLLFHOLLGC {
        JJLLFHOLLGC::new()
    }

    fn clear(&mut self) {
        self.MDPMCJGPIIO = ::protobuf::EnumOrUnknown::new(SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static JJLLFHOLLGC {
        static instance: JJLLFHOLLGC = JJLLFHOLLGC {
            MDPMCJGPIIO: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for JJLLFHOLLGC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("JJLLFHOLLGC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for JJLLFHOLLGC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JJLLFHOLLGC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ELKMCNJBFAD)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ELKMCNJBFAD {
    // message fields
    // @@protoc_insertion_point(field:ELKMCNJBFAD.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:ELKMCNJBFAD.BPMPJHFFELH)
    pub BPMPJHFFELH: bool,
    // @@protoc_insertion_point(field:ELKMCNJBFAD.DCECFOKFIHH)
    pub DCECFOKFIHH: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ELKMCNJBFAD.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ELKMCNJBFAD {
    fn default() -> &'a ELKMCNJBFAD {
        <ELKMCNJBFAD as ::protobuf::Message>::default_instance()
    }
}

impl ELKMCNJBFAD {
    pub fn new() -> ELKMCNJBFAD {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &ELKMCNJBFAD| { &m.retcode },
            |m: &mut ELKMCNJBFAD| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "BPMPJHFFELH",
            |m: &ELKMCNJBFAD| { &m.BPMPJHFFELH },
            |m: &mut ELKMCNJBFAD| { &mut m.BPMPJHFFELH },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DCECFOKFIHH",
            |m: &ELKMCNJBFAD| { &m.DCECFOKFIHH },
            |m: &mut ELKMCNJBFAD| { &mut m.DCECFOKFIHH },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ELKMCNJBFAD>(
            "ELKMCNJBFAD",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ELKMCNJBFAD {
    const NAME: &'static str = "ELKMCNJBFAD";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                40 => {
                    self.retcode = is.read_uint32()?;
                },
                120 => {
                    self.BPMPJHFFELH = is.read_bool()?;
                },
                16 => {
                    self.DCECFOKFIHH = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.retcode);
        }
        if self.BPMPJHFFELH != false {
            my_size += 1 + 1;
        }
        if self.DCECFOKFIHH != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.DCECFOKFIHH);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(5, self.retcode)?;
        }
        if self.BPMPJHFFELH != false {
            os.write_bool(15, self.BPMPJHFFELH)?;
        }
        if self.DCECFOKFIHH != 0 {
            os.write_uint32(2, self.DCECFOKFIHH)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ELKMCNJBFAD {
        ELKMCNJBFAD::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.BPMPJHFFELH = false;
        self.DCECFOKFIHH = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ELKMCNJBFAD {
        static instance: ELKMCNJBFAD = ELKMCNJBFAD {
            retcode: 0,
            BPMPJHFFELH: false,
            DCECFOKFIHH: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ELKMCNJBFAD {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ELKMCNJBFAD").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ELKMCNJBFAD {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ELKMCNJBFAD {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PMDKCCPGMDE)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PMDKCCPGMDE {
    // message fields
    // @@protoc_insertion_point(field:PMDKCCPGMDE.MFNFDHAGAPH)
    pub MFNFDHAGAPH: u32,
    // special fields
    // @@protoc_insertion_point(special_field:PMDKCCPGMDE.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PMDKCCPGMDE {
    fn default() -> &'a PMDKCCPGMDE {
        <PMDKCCPGMDE as ::protobuf::Message>::default_instance()
    }
}

impl PMDKCCPGMDE {
    pub fn new() -> PMDKCCPGMDE {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MFNFDHAGAPH",
            |m: &PMDKCCPGMDE| { &m.MFNFDHAGAPH },
            |m: &mut PMDKCCPGMDE| { &mut m.MFNFDHAGAPH },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PMDKCCPGMDE>(
            "PMDKCCPGMDE",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PMDKCCPGMDE {
    const NAME: &'static str = "PMDKCCPGMDE";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                40 => {
                    self.MFNFDHAGAPH = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.MFNFDHAGAPH != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.MFNFDHAGAPH);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.MFNFDHAGAPH != 0 {
            os.write_uint32(5, self.MFNFDHAGAPH)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PMDKCCPGMDE {
        PMDKCCPGMDE::new()
    }

    fn clear(&mut self) {
        self.MFNFDHAGAPH = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PMDKCCPGMDE {
        static instance: PMDKCCPGMDE = PMDKCCPGMDE {
            MFNFDHAGAPH: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PMDKCCPGMDE {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PMDKCCPGMDE").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PMDKCCPGMDE {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PMDKCCPGMDE {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:KEDCGGPPBLB)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KEDCGGPPBLB {
    // message fields
    // @@protoc_insertion_point(field:KEDCGGPPBLB.retcode)
    pub retcode: u32,
    // special fields
    // @@protoc_insertion_point(special_field:KEDCGGPPBLB.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KEDCGGPPBLB {
    fn default() -> &'a KEDCGGPPBLB {
        <KEDCGGPPBLB as ::protobuf::Message>::default_instance()
    }
}

impl KEDCGGPPBLB {
    pub fn new() -> KEDCGGPPBLB {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &KEDCGGPPBLB| { &m.retcode },
            |m: &mut KEDCGGPPBLB| { &mut m.retcode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KEDCGGPPBLB>(
            "KEDCGGPPBLB",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KEDCGGPPBLB {
    const NAME: &'static str = "KEDCGGPPBLB";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                96 => {
                    self.retcode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.retcode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(12, self.retcode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KEDCGGPPBLB {
        KEDCGGPPBLB::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KEDCGGPPBLB {
        static instance: KEDCGGPPBLB = KEDCGGPPBLB {
            retcode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KEDCGGPPBLB {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KEDCGGPPBLB").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KEDCGGPPBLB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KEDCGGPPBLB {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FCCLHJINFED)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FCCLHJINFED {
    // special fields
    // @@protoc_insertion_point(special_field:FCCLHJINFED.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FCCLHJINFED {
    fn default() -> &'a FCCLHJINFED {
        <FCCLHJINFED as ::protobuf::Message>::default_instance()
    }
}

impl FCCLHJINFED {
    pub fn new() -> FCCLHJINFED {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FCCLHJINFED>(
            "FCCLHJINFED",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FCCLHJINFED {
    const NAME: &'static str = "FCCLHJINFED";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FCCLHJINFED {
        FCCLHJINFED::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FCCLHJINFED {
        static instance: FCCLHJINFED = FCCLHJINFED {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FCCLHJINFED {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FCCLHJINFED").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FCCLHJINFED {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FCCLHJINFED {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ENLDPPNFOGP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ENLDPPNFOGP {
    // message fields
    // @@protoc_insertion_point(field:ENLDPPNFOGP.retcode)
    pub retcode: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ENLDPPNFOGP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ENLDPPNFOGP {
    fn default() -> &'a ENLDPPNFOGP {
        <ENLDPPNFOGP as ::protobuf::Message>::default_instance()
    }
}

impl ENLDPPNFOGP {
    pub fn new() -> ENLDPPNFOGP {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &ENLDPPNFOGP| { &m.retcode },
            |m: &mut ENLDPPNFOGP| { &mut m.retcode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ENLDPPNFOGP>(
            "ENLDPPNFOGP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ENLDPPNFOGP {
    const NAME: &'static str = "ENLDPPNFOGP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                56 => {
                    self.retcode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.retcode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(7, self.retcode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ENLDPPNFOGP {
        ENLDPPNFOGP::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ENLDPPNFOGP {
        static instance: ENLDPPNFOGP = ENLDPPNFOGP {
            retcode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ENLDPPNFOGP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ENLDPPNFOGP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ENLDPPNFOGP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ENLDPPNFOGP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:AGBEKCNNNJH)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AGBEKCNNNJH {
    // special fields
    // @@protoc_insertion_point(special_field:AGBEKCNNNJH.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AGBEKCNNNJH {
    fn default() -> &'a AGBEKCNNNJH {
        <AGBEKCNNNJH as ::protobuf::Message>::default_instance()
    }
}

impl AGBEKCNNNJH {
    pub fn new() -> AGBEKCNNNJH {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AGBEKCNNNJH>(
            "AGBEKCNNNJH",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AGBEKCNNNJH {
    const NAME: &'static str = "AGBEKCNNNJH";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AGBEKCNNNJH {
        AGBEKCNNNJH::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AGBEKCNNNJH {
        static instance: AGBEKCNNNJH = AGBEKCNNNJH {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AGBEKCNNNJH {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AGBEKCNNNJH").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AGBEKCNNNJH {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AGBEKCNNNJH {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NFAIOAMFDEM)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NFAIOAMFDEM {
    // message fields
    // @@protoc_insertion_point(field:NFAIOAMFDEM.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:NFAIOAMFDEM.battle_info)
    pub battle_info: ::protobuf::MessageField<super::SceneBattleInfo::SceneBattleInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:NFAIOAMFDEM.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NFAIOAMFDEM {
    fn default() -> &'a NFAIOAMFDEM {
        <NFAIOAMFDEM as ::protobuf::Message>::default_instance()
    }
}

impl NFAIOAMFDEM {
    pub fn new() -> NFAIOAMFDEM {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &NFAIOAMFDEM| { &m.retcode },
            |m: &mut NFAIOAMFDEM| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::SceneBattleInfo::SceneBattleInfo>(
            "battle_info",
            |m: &NFAIOAMFDEM| { &m.battle_info },
            |m: &mut NFAIOAMFDEM| { &mut m.battle_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NFAIOAMFDEM>(
            "NFAIOAMFDEM",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NFAIOAMFDEM {
    const NAME: &'static str = "NFAIOAMFDEM";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.retcode = is.read_uint32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.battle_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.retcode);
        }
        if let Some(v) = self.battle_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(4, self.retcode)?;
        }
        if let Some(v) = self.battle_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NFAIOAMFDEM {
        NFAIOAMFDEM::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.battle_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NFAIOAMFDEM {
        static instance: NFAIOAMFDEM = NFAIOAMFDEM {
            retcode: 0,
            battle_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NFAIOAMFDEM {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NFAIOAMFDEM").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NFAIOAMFDEM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NFAIOAMFDEM {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NBNELCONAPD)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NBNELCONAPD {
    // message fields
    // @@protoc_insertion_point(field:NBNELCONAPD.CCLGMCIMGLH)
    pub CCLGMCIMGLH: u32,
    // special fields
    // @@protoc_insertion_point(special_field:NBNELCONAPD.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NBNELCONAPD {
    fn default() -> &'a NBNELCONAPD {
        <NBNELCONAPD as ::protobuf::Message>::default_instance()
    }
}

impl NBNELCONAPD {
    pub fn new() -> NBNELCONAPD {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CCLGMCIMGLH",
            |m: &NBNELCONAPD| { &m.CCLGMCIMGLH },
            |m: &mut NBNELCONAPD| { &mut m.CCLGMCIMGLH },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NBNELCONAPD>(
            "NBNELCONAPD",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NBNELCONAPD {
    const NAME: &'static str = "NBNELCONAPD";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.CCLGMCIMGLH = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.CCLGMCIMGLH != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.CCLGMCIMGLH);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.CCLGMCIMGLH != 0 {
            os.write_uint32(10, self.CCLGMCIMGLH)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NBNELCONAPD {
        NBNELCONAPD::new()
    }

    fn clear(&mut self) {
        self.CCLGMCIMGLH = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NBNELCONAPD {
        static instance: NBNELCONAPD = NBNELCONAPD {
            CCLGMCIMGLH: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NBNELCONAPD {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NBNELCONAPD").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NBNELCONAPD {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NBNELCONAPD {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NHCJMPNEDDI)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NHCJMPNEDDI {
    // message fields
    // @@protoc_insertion_point(field:NHCJMPNEDDI.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:NHCJMPNEDDI.CCLGMCIMGLH)
    pub CCLGMCIMGLH: u32,
    // special fields
    // @@protoc_insertion_point(special_field:NHCJMPNEDDI.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NHCJMPNEDDI {
    fn default() -> &'a NHCJMPNEDDI {
        <NHCJMPNEDDI as ::protobuf::Message>::default_instance()
    }
}

impl NHCJMPNEDDI {
    pub fn new() -> NHCJMPNEDDI {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &NHCJMPNEDDI| { &m.retcode },
            |m: &mut NHCJMPNEDDI| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CCLGMCIMGLH",
            |m: &NHCJMPNEDDI| { &m.CCLGMCIMGLH },
            |m: &mut NHCJMPNEDDI| { &mut m.CCLGMCIMGLH },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NHCJMPNEDDI>(
            "NHCJMPNEDDI",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NHCJMPNEDDI {
    const NAME: &'static str = "NHCJMPNEDDI";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.retcode = is.read_uint32()?;
                },
                40 => {
                    self.CCLGMCIMGLH = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.retcode);
        }
        if self.CCLGMCIMGLH != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.CCLGMCIMGLH);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(6, self.retcode)?;
        }
        if self.CCLGMCIMGLH != 0 {
            os.write_uint32(5, self.CCLGMCIMGLH)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NHCJMPNEDDI {
        NHCJMPNEDDI::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.CCLGMCIMGLH = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NHCJMPNEDDI {
        static instance: NHCJMPNEDDI = NHCJMPNEDDI {
            retcode: 0,
            CCLGMCIMGLH: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NHCJMPNEDDI {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NHCJMPNEDDI").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NHCJMPNEDDI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NHCJMPNEDDI {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingStartGameCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingStartGameCsReq {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingStartGameCsReq.story_id)
    pub story_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingStartGameCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingStartGameCsReq {
    fn default() -> &'a SwordTrainingStartGameCsReq {
        <SwordTrainingStartGameCsReq as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingStartGameCsReq {
    pub fn new() -> SwordTrainingStartGameCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "story_id",
            |m: &SwordTrainingStartGameCsReq| { &m.story_id },
            |m: &mut SwordTrainingStartGameCsReq| { &mut m.story_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingStartGameCsReq>(
            "SwordTrainingStartGameCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingStartGameCsReq {
    const NAME: &'static str = "SwordTrainingStartGameCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.story_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.story_id != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.story_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.story_id != 0 {
            os.write_uint32(10, self.story_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingStartGameCsReq {
        SwordTrainingStartGameCsReq::new()
    }

    fn clear(&mut self) {
        self.story_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingStartGameCsReq {
        static instance: SwordTrainingStartGameCsReq = SwordTrainingStartGameCsReq {
            story_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingStartGameCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingStartGameCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingStartGameCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingStartGameCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingStartGameScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingStartGameScRsp {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingStartGameScRsp.game_info)
    pub game_info: ::protobuf::MessageField<SwordTrainingGameInfo>,
    // @@protoc_insertion_point(field:SwordTrainingStartGameScRsp.retcode)
    pub retcode: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingStartGameScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingStartGameScRsp {
    fn default() -> &'a SwordTrainingStartGameScRsp {
        <SwordTrainingStartGameScRsp as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingStartGameScRsp {
    pub fn new() -> SwordTrainingStartGameScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SwordTrainingGameInfo>(
            "game_info",
            |m: &SwordTrainingStartGameScRsp| { &m.game_info },
            |m: &mut SwordTrainingStartGameScRsp| { &mut m.game_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &SwordTrainingStartGameScRsp| { &m.retcode },
            |m: &mut SwordTrainingStartGameScRsp| { &mut m.retcode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingStartGameScRsp>(
            "SwordTrainingStartGameScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingStartGameScRsp {
    const NAME: &'static str = "SwordTrainingStartGameScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_info)?;
                },
                72 => {
                    self.retcode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.retcode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if self.retcode != 0 {
            os.write_uint32(9, self.retcode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingStartGameScRsp {
        SwordTrainingStartGameScRsp::new()
    }

    fn clear(&mut self) {
        self.game_info.clear();
        self.retcode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingStartGameScRsp {
        static instance: SwordTrainingStartGameScRsp = SwordTrainingStartGameScRsp {
            game_info: ::protobuf::MessageField::none(),
            retcode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingStartGameScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingStartGameScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingStartGameScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingStartGameScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ECDJBHNLCMG)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ECDJBHNLCMG {
    // message fields
    // @@protoc_insertion_point(field:ECDJBHNLCMG.LHMPHPEODNP)
    pub LHMPHPEODNP: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ECDJBHNLCMG.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ECDJBHNLCMG {
    fn default() -> &'a ECDJBHNLCMG {
        <ECDJBHNLCMG as ::protobuf::Message>::default_instance()
    }
}

impl ECDJBHNLCMG {
    pub fn new() -> ECDJBHNLCMG {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LHMPHPEODNP",
            |m: &ECDJBHNLCMG| { &m.LHMPHPEODNP },
            |m: &mut ECDJBHNLCMG| { &mut m.LHMPHPEODNP },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ECDJBHNLCMG>(
            "ECDJBHNLCMG",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ECDJBHNLCMG {
    const NAME: &'static str = "ECDJBHNLCMG";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.LHMPHPEODNP = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.LHMPHPEODNP != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.LHMPHPEODNP);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.LHMPHPEODNP != 0 {
            os.write_uint32(10, self.LHMPHPEODNP)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ECDJBHNLCMG {
        ECDJBHNLCMG::new()
    }

    fn clear(&mut self) {
        self.LHMPHPEODNP = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ECDJBHNLCMG {
        static instance: ECDJBHNLCMG = ECDJBHNLCMG {
            LHMPHPEODNP: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ECDJBHNLCMG {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ECDJBHNLCMG").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ECDJBHNLCMG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ECDJBHNLCMG {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PEAGMIKINCF)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PEAGMIKINCF {
    // message fields
    // @@protoc_insertion_point(field:PEAGMIKINCF.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:PEAGMIKINCF.LHMPHPEODNP)
    pub LHMPHPEODNP: u32,
    // special fields
    // @@protoc_insertion_point(special_field:PEAGMIKINCF.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PEAGMIKINCF {
    fn default() -> &'a PEAGMIKINCF {
        <PEAGMIKINCF as ::protobuf::Message>::default_instance()
    }
}

impl PEAGMIKINCF {
    pub fn new() -> PEAGMIKINCF {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &PEAGMIKINCF| { &m.retcode },
            |m: &mut PEAGMIKINCF| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LHMPHPEODNP",
            |m: &PEAGMIKINCF| { &m.LHMPHPEODNP },
            |m: &mut PEAGMIKINCF| { &mut m.LHMPHPEODNP },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PEAGMIKINCF>(
            "PEAGMIKINCF",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PEAGMIKINCF {
    const NAME: &'static str = "PEAGMIKINCF";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                72 => {
                    self.retcode = is.read_uint32()?;
                },
                32 => {
                    self.LHMPHPEODNP = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.retcode);
        }
        if self.LHMPHPEODNP != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.LHMPHPEODNP);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(9, self.retcode)?;
        }
        if self.LHMPHPEODNP != 0 {
            os.write_uint32(4, self.LHMPHPEODNP)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PEAGMIKINCF {
        PEAGMIKINCF::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.LHMPHPEODNP = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PEAGMIKINCF {
        static instance: PEAGMIKINCF = PEAGMIKINCF {
            retcode: 0,
            LHMPHPEODNP: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PEAGMIKINCF {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PEAGMIKINCF").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PEAGMIKINCF {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PEAGMIKINCF {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MJLBEIOLCPC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MJLBEIOLCPC {
    // special fields
    // @@protoc_insertion_point(special_field:MJLBEIOLCPC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MJLBEIOLCPC {
    fn default() -> &'a MJLBEIOLCPC {
        <MJLBEIOLCPC as ::protobuf::Message>::default_instance()
    }
}

impl MJLBEIOLCPC {
    pub fn new() -> MJLBEIOLCPC {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MJLBEIOLCPC>(
            "MJLBEIOLCPC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MJLBEIOLCPC {
    const NAME: &'static str = "MJLBEIOLCPC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MJLBEIOLCPC {
        MJLBEIOLCPC::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MJLBEIOLCPC {
        static instance: MJLBEIOLCPC = MJLBEIOLCPC {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MJLBEIOLCPC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MJLBEIOLCPC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MJLBEIOLCPC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MJLBEIOLCPC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PCBOEDPMHOI)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PCBOEDPMHOI {
    // message fields
    // @@protoc_insertion_point(field:PCBOEDPMHOI.retcode)
    pub retcode: u32,
    // special fields
    // @@protoc_insertion_point(special_field:PCBOEDPMHOI.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PCBOEDPMHOI {
    fn default() -> &'a PCBOEDPMHOI {
        <PCBOEDPMHOI as ::protobuf::Message>::default_instance()
    }
}

impl PCBOEDPMHOI {
    pub fn new() -> PCBOEDPMHOI {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &PCBOEDPMHOI| { &m.retcode },
            |m: &mut PCBOEDPMHOI| { &mut m.retcode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PCBOEDPMHOI>(
            "PCBOEDPMHOI",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PCBOEDPMHOI {
    const NAME: &'static str = "PCBOEDPMHOI";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.retcode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.retcode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(3, self.retcode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PCBOEDPMHOI {
        PCBOEDPMHOI::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PCBOEDPMHOI {
        static instance: PCBOEDPMHOI = PCBOEDPMHOI {
            retcode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PCBOEDPMHOI {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PCBOEDPMHOI").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PCBOEDPMHOI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PCBOEDPMHOI {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DLBJKLCHJHK)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DLBJKLCHJHK {
    // message fields
    // @@protoc_insertion_point(field:DLBJKLCHJHK.reason)
    pub reason: ::protobuf::EnumOrUnknown<SwordTrainingGameSettle>,
    // @@protoc_insertion_point(field:DLBJKLCHJHK.PCMAAKHAEBC)
    pub PCMAAKHAEBC: u32,
    // @@protoc_insertion_point(field:DLBJKLCHJHK.story_id)
    pub story_id: u32,
    // @@protoc_insertion_point(field:DLBJKLCHJHK.DKFLLECGCCK)
    pub DKFLLECGCCK: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:DLBJKLCHJHK.CKEDFNKALOI)
    pub CKEDFNKALOI: u32,
    // @@protoc_insertion_point(field:DLBJKLCHJHK.CIDICFBPHAF)
    pub CIDICFBPHAF: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:DLBJKLCHJHK.OOJPFKLPHFH)
    pub OOJPFKLPHFH: u32,
    // @@protoc_insertion_point(field:DLBJKLCHJHK.reward)
    pub reward: ::protobuf::MessageField<super::ItemList::ItemList>,
    // special fields
    // @@protoc_insertion_point(special_field:DLBJKLCHJHK.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DLBJKLCHJHK {
    fn default() -> &'a DLBJKLCHJHK {
        <DLBJKLCHJHK as ::protobuf::Message>::default_instance()
    }
}

impl DLBJKLCHJHK {
    pub fn new() -> DLBJKLCHJHK {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reason",
            |m: &DLBJKLCHJHK| { &m.reason },
            |m: &mut DLBJKLCHJHK| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PCMAAKHAEBC",
            |m: &DLBJKLCHJHK| { &m.PCMAAKHAEBC },
            |m: &mut DLBJKLCHJHK| { &mut m.PCMAAKHAEBC },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "story_id",
            |m: &DLBJKLCHJHK| { &m.story_id },
            |m: &mut DLBJKLCHJHK| { &mut m.story_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "DKFLLECGCCK",
            |m: &DLBJKLCHJHK| { &m.DKFLLECGCCK },
            |m: &mut DLBJKLCHJHK| { &mut m.DKFLLECGCCK },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CKEDFNKALOI",
            |m: &DLBJKLCHJHK| { &m.CKEDFNKALOI },
            |m: &mut DLBJKLCHJHK| { &mut m.CKEDFNKALOI },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "CIDICFBPHAF",
            |m: &DLBJKLCHJHK| { &m.CIDICFBPHAF },
            |m: &mut DLBJKLCHJHK| { &mut m.CIDICFBPHAF },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OOJPFKLPHFH",
            |m: &DLBJKLCHJHK| { &m.OOJPFKLPHFH },
            |m: &mut DLBJKLCHJHK| { &mut m.OOJPFKLPHFH },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::ItemList::ItemList>(
            "reward",
            |m: &DLBJKLCHJHK| { &m.reward },
            |m: &mut DLBJKLCHJHK| { &mut m.reward },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DLBJKLCHJHK>(
            "DLBJKLCHJHK",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DLBJKLCHJHK {
    const NAME: &'static str = "DLBJKLCHJHK";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.reason = is.read_enum_or_unknown()?;
                },
                8 => {
                    self.PCMAAKHAEBC = is.read_uint32()?;
                },
                56 => {
                    self.story_id = is.read_uint32()?;
                },
                90 => {
                    is.read_repeated_packed_uint32_into(&mut self.DKFLLECGCCK)?;
                },
                88 => {
                    self.DKFLLECGCCK.push(is.read_uint32()?);
                },
                120 => {
                    self.CKEDFNKALOI = is.read_uint32()?;
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.CIDICFBPHAF)?;
                },
                24 => {
                    self.CIDICFBPHAF.push(is.read_uint32()?);
                },
                48 => {
                    self.OOJPFKLPHFH = is.read_uint32()?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reward)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.reason != ::protobuf::EnumOrUnknown::new(SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_NONE) {
            my_size += ::protobuf::rt::int32_size(2, self.reason.value());
        }
        if self.PCMAAKHAEBC != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.PCMAAKHAEBC);
        }
        if self.story_id != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.story_id);
        }
        for value in &self.DKFLLECGCCK {
            my_size += ::protobuf::rt::uint32_size(11, *value);
        };
        if self.CKEDFNKALOI != 0 {
            my_size += ::protobuf::rt::uint32_size(15, self.CKEDFNKALOI);
        }
        for value in &self.CIDICFBPHAF {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        if self.OOJPFKLPHFH != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.OOJPFKLPHFH);
        }
        if let Some(v) = self.reward.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.reason != ::protobuf::EnumOrUnknown::new(SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_NONE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.reason))?;
        }
        if self.PCMAAKHAEBC != 0 {
            os.write_uint32(1, self.PCMAAKHAEBC)?;
        }
        if self.story_id != 0 {
            os.write_uint32(7, self.story_id)?;
        }
        for v in &self.DKFLLECGCCK {
            os.write_uint32(11, *v)?;
        };
        if self.CKEDFNKALOI != 0 {
            os.write_uint32(15, self.CKEDFNKALOI)?;
        }
        for v in &self.CIDICFBPHAF {
            os.write_uint32(3, *v)?;
        };
        if self.OOJPFKLPHFH != 0 {
            os.write_uint32(6, self.OOJPFKLPHFH)?;
        }
        if let Some(v) = self.reward.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DLBJKLCHJHK {
        DLBJKLCHJHK::new()
    }

    fn clear(&mut self) {
        self.reason = ::protobuf::EnumOrUnknown::new(SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_NONE);
        self.PCMAAKHAEBC = 0;
        self.story_id = 0;
        self.DKFLLECGCCK.clear();
        self.CKEDFNKALOI = 0;
        self.CIDICFBPHAF.clear();
        self.OOJPFKLPHFH = 0;
        self.reward.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DLBJKLCHJHK {
        static instance: DLBJKLCHJHK = DLBJKLCHJHK {
            reason: ::protobuf::EnumOrUnknown::from_i32(0),
            PCMAAKHAEBC: 0,
            story_id: 0,
            DKFLLECGCCK: ::std::vec::Vec::new(),
            CKEDFNKALOI: 0,
            CIDICFBPHAF: ::std::vec::Vec::new(),
            OOJPFKLPHFH: 0,
            reward: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DLBJKLCHJHK {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DLBJKLCHJHK").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DLBJKLCHJHK {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DLBJKLCHJHK {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:AKMPGPMADKO)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AKMPGPMADKO {
    // message fields
    // @@protoc_insertion_point(field:AKMPGPMADKO.AKPGGHKCAIF)
    pub AKPGGHKCAIF: ::std::vec::Vec<DNLEFEGOBEG>,
    // @@protoc_insertion_point(field:AKMPGPMADKO.FGCDDCJHIAG)
    pub FGCDDCJHIAG: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:AKMPGPMADKO.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AKMPGPMADKO {
    fn default() -> &'a AKMPGPMADKO {
        <AKMPGPMADKO as ::protobuf::Message>::default_instance()
    }
}

impl AKMPGPMADKO {
    pub fn new() -> AKMPGPMADKO {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "AKPGGHKCAIF",
            |m: &AKMPGPMADKO| { &m.AKPGGHKCAIF },
            |m: &mut AKMPGPMADKO| { &mut m.AKPGGHKCAIF },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "FGCDDCJHIAG",
            |m: &AKMPGPMADKO| { &m.FGCDDCJHIAG },
            |m: &mut AKMPGPMADKO| { &mut m.FGCDDCJHIAG },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AKMPGPMADKO>(
            "AKMPGPMADKO",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AKMPGPMADKO {
    const NAME: &'static str = "AKMPGPMADKO";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    self.AKPGGHKCAIF.push(is.read_message()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.FGCDDCJHIAG)?;
                },
                72 => {
                    self.FGCDDCJHIAG.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.AKPGGHKCAIF {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.FGCDDCJHIAG {
            my_size += ::protobuf::rt::uint32_size(9, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.AKPGGHKCAIF {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.FGCDDCJHIAG {
            os.write_uint32(9, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AKMPGPMADKO {
        AKMPGPMADKO::new()
    }

    fn clear(&mut self) {
        self.AKPGGHKCAIF.clear();
        self.FGCDDCJHIAG.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AKMPGPMADKO {
        static instance: AKMPGPMADKO = AKMPGPMADKO {
            AKPGGHKCAIF: ::std::vec::Vec::new(),
            FGCDDCJHIAG: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AKMPGPMADKO {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AKMPGPMADKO").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AKMPGPMADKO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AKMPGPMADKO {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingFinishEndingHintCsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingFinishEndingHintCsReq {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingFinishEndingHintCsReq.hint_id)
    pub hint_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingFinishEndingHintCsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingFinishEndingHintCsReq {
    fn default() -> &'a SwordTrainingFinishEndingHintCsReq {
        <SwordTrainingFinishEndingHintCsReq as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingFinishEndingHintCsReq {
    pub fn new() -> SwordTrainingFinishEndingHintCsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hint_id",
            |m: &SwordTrainingFinishEndingHintCsReq| { &m.hint_id },
            |m: &mut SwordTrainingFinishEndingHintCsReq| { &mut m.hint_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingFinishEndingHintCsReq>(
            "SwordTrainingFinishEndingHintCsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingFinishEndingHintCsReq {
    const NAME: &'static str = "SwordTrainingFinishEndingHintCsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                120 => {
                    self.hint_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.hint_id != 0 {
            my_size += ::protobuf::rt::uint32_size(15, self.hint_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.hint_id != 0 {
            os.write_uint32(15, self.hint_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingFinishEndingHintCsReq {
        SwordTrainingFinishEndingHintCsReq::new()
    }

    fn clear(&mut self) {
        self.hint_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingFinishEndingHintCsReq {
        static instance: SwordTrainingFinishEndingHintCsReq = SwordTrainingFinishEndingHintCsReq {
            hint_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingFinishEndingHintCsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingFinishEndingHintCsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingFinishEndingHintCsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingFinishEndingHintCsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwordTrainingFinishEndingHintScRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwordTrainingFinishEndingHintScRsp {
    // message fields
    // @@protoc_insertion_point(field:SwordTrainingFinishEndingHintScRsp.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:SwordTrainingFinishEndingHintScRsp.item_list)
    pub item_list: ::protobuf::MessageField<super::ItemList::ItemList>,
    // @@protoc_insertion_point(field:SwordTrainingFinishEndingHintScRsp.hint_id)
    pub hint_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SwordTrainingFinishEndingHintScRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwordTrainingFinishEndingHintScRsp {
    fn default() -> &'a SwordTrainingFinishEndingHintScRsp {
        <SwordTrainingFinishEndingHintScRsp as ::protobuf::Message>::default_instance()
    }
}

impl SwordTrainingFinishEndingHintScRsp {
    pub fn new() -> SwordTrainingFinishEndingHintScRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &SwordTrainingFinishEndingHintScRsp| { &m.retcode },
            |m: &mut SwordTrainingFinishEndingHintScRsp| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::ItemList::ItemList>(
            "item_list",
            |m: &SwordTrainingFinishEndingHintScRsp| { &m.item_list },
            |m: &mut SwordTrainingFinishEndingHintScRsp| { &mut m.item_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hint_id",
            |m: &SwordTrainingFinishEndingHintScRsp| { &m.hint_id },
            |m: &mut SwordTrainingFinishEndingHintScRsp| { &mut m.hint_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwordTrainingFinishEndingHintScRsp>(
            "SwordTrainingFinishEndingHintScRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwordTrainingFinishEndingHintScRsp {
    const NAME: &'static str = "SwordTrainingFinishEndingHintScRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                56 => {
                    self.retcode = is.read_uint32()?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.item_list)?;
                },
                32 => {
                    self.hint_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.retcode);
        }
        if let Some(v) = self.item_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.hint_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.hint_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(7, self.retcode)?;
        }
        if let Some(v) = self.item_list.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if self.hint_id != 0 {
            os.write_uint32(4, self.hint_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwordTrainingFinishEndingHintScRsp {
        SwordTrainingFinishEndingHintScRsp::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.item_list.clear();
        self.hint_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwordTrainingFinishEndingHintScRsp {
        static instance: SwordTrainingFinishEndingHintScRsp = SwordTrainingFinishEndingHintScRsp {
            retcode: 0,
            item_list: ::protobuf::MessageField::none(),
            hint_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwordTrainingFinishEndingHintScRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwordTrainingFinishEndingHintScRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwordTrainingFinishEndingHintScRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwordTrainingFinishEndingHintScRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DCOLJDKGDBN)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DCOLJDKGDBN {
    // message fields
    // @@protoc_insertion_point(field:DCOLJDKGDBN.OKOANEAKGOE)
    pub OKOANEAKGOE: u32,
    // special fields
    // @@protoc_insertion_point(special_field:DCOLJDKGDBN.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DCOLJDKGDBN {
    fn default() -> &'a DCOLJDKGDBN {
        <DCOLJDKGDBN as ::protobuf::Message>::default_instance()
    }
}

impl DCOLJDKGDBN {
    pub fn new() -> DCOLJDKGDBN {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OKOANEAKGOE",
            |m: &DCOLJDKGDBN| { &m.OKOANEAKGOE },
            |m: &mut DCOLJDKGDBN| { &mut m.OKOANEAKGOE },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DCOLJDKGDBN>(
            "DCOLJDKGDBN",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DCOLJDKGDBN {
    const NAME: &'static str = "DCOLJDKGDBN";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.OKOANEAKGOE = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.OKOANEAKGOE != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.OKOANEAKGOE);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.OKOANEAKGOE != 0 {
            os.write_uint32(1, self.OKOANEAKGOE)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DCOLJDKGDBN {
        DCOLJDKGDBN::new()
    }

    fn clear(&mut self) {
        self.OKOANEAKGOE = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DCOLJDKGDBN {
        static instance: DCOLJDKGDBN = DCOLJDKGDBN {
            OKOANEAKGOE: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DCOLJDKGDBN {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DCOLJDKGDBN").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DCOLJDKGDBN {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DCOLJDKGDBN {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NPJPKIGLBJP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NPJPKIGLBJP {
    // message fields
    // @@protoc_insertion_point(field:NPJPKIGLBJP.OKOANEAKGOE)
    pub OKOANEAKGOE: u32,
    // @@protoc_insertion_point(field:NPJPKIGLBJP.retcode)
    pub retcode: u32,
    // special fields
    // @@protoc_insertion_point(special_field:NPJPKIGLBJP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NPJPKIGLBJP {
    fn default() -> &'a NPJPKIGLBJP {
        <NPJPKIGLBJP as ::protobuf::Message>::default_instance()
    }
}

impl NPJPKIGLBJP {
    pub fn new() -> NPJPKIGLBJP {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OKOANEAKGOE",
            |m: &NPJPKIGLBJP| { &m.OKOANEAKGOE },
            |m: &mut NPJPKIGLBJP| { &mut m.OKOANEAKGOE },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &NPJPKIGLBJP| { &m.retcode },
            |m: &mut NPJPKIGLBJP| { &mut m.retcode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NPJPKIGLBJP>(
            "NPJPKIGLBJP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NPJPKIGLBJP {
    const NAME: &'static str = "NPJPKIGLBJP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.OKOANEAKGOE = is.read_uint32()?;
                },
                96 => {
                    self.retcode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.OKOANEAKGOE != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.OKOANEAKGOE);
        }
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.retcode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.OKOANEAKGOE != 0 {
            os.write_uint32(4, self.OKOANEAKGOE)?;
        }
        if self.retcode != 0 {
            os.write_uint32(12, self.retcode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NPJPKIGLBJP {
        NPJPKIGLBJP::new()
    }

    fn clear(&mut self) {
        self.OKOANEAKGOE = 0;
        self.retcode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NPJPKIGLBJP {
        static instance: NPJPKIGLBJP = NPJPKIGLBJP {
            OKOANEAKGOE: 0,
            retcode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NPJPKIGLBJP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NPJPKIGLBJP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NPJPKIGLBJP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NPJPKIGLBJP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:KPABJCCEADF)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KPABJCCEADF {
    // special fields
    // @@protoc_insertion_point(special_field:KPABJCCEADF.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KPABJCCEADF {
    fn default() -> &'a KPABJCCEADF {
        <KPABJCCEADF as ::protobuf::Message>::default_instance()
    }
}

impl KPABJCCEADF {
    pub fn new() -> KPABJCCEADF {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KPABJCCEADF>(
            "KPABJCCEADF",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KPABJCCEADF {
    const NAME: &'static str = "KPABJCCEADF";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KPABJCCEADF {
        KPABJCCEADF::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KPABJCCEADF {
        static instance: KPABJCCEADF = KPABJCCEADF {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KPABJCCEADF {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KPABJCCEADF").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KPABJCCEADF {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KPABJCCEADF {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:KAONBIOFBBD)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KAONBIOFBBD {
    // message fields
    // @@protoc_insertion_point(field:KAONBIOFBBD.game_info)
    pub game_info: ::protobuf::MessageField<SwordTrainingGameInfo>,
    // @@protoc_insertion_point(field:KAONBIOFBBD.retcode)
    pub retcode: u32,
    // special fields
    // @@protoc_insertion_point(special_field:KAONBIOFBBD.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KAONBIOFBBD {
    fn default() -> &'a KAONBIOFBBD {
        <KAONBIOFBBD as ::protobuf::Message>::default_instance()
    }
}

impl KAONBIOFBBD {
    pub fn new() -> KAONBIOFBBD {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SwordTrainingGameInfo>(
            "game_info",
            |m: &KAONBIOFBBD| { &m.game_info },
            |m: &mut KAONBIOFBBD| { &mut m.game_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &KAONBIOFBBD| { &m.retcode },
            |m: &mut KAONBIOFBBD| { &mut m.retcode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KAONBIOFBBD>(
            "KAONBIOFBBD",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KAONBIOFBBD {
    const NAME: &'static str = "KAONBIOFBBD";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_info)?;
                },
                24 => {
                    self.retcode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.retcode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if self.retcode != 0 {
            os.write_uint32(3, self.retcode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KAONBIOFBBD {
        KAONBIOFBBD::new()
    }

    fn clear(&mut self) {
        self.game_info.clear();
        self.retcode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KAONBIOFBBD {
        static instance: KAONBIOFBBD = KAONBIOFBBD {
            game_info: ::protobuf::MessageField::none(),
            retcode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KAONBIOFBBD {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KAONBIOFBBD").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KAONBIOFBBD {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KAONBIOFBBD {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EFCDNJALEOJ)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EFCDNJALEOJ {
    // special fields
    // @@protoc_insertion_point(special_field:EFCDNJALEOJ.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EFCDNJALEOJ {
    fn default() -> &'a EFCDNJALEOJ {
        <EFCDNJALEOJ as ::protobuf::Message>::default_instance()
    }
}

impl EFCDNJALEOJ {
    pub fn new() -> EFCDNJALEOJ {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EFCDNJALEOJ>(
            "EFCDNJALEOJ",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EFCDNJALEOJ {
    const NAME: &'static str = "EFCDNJALEOJ";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EFCDNJALEOJ {
        EFCDNJALEOJ::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EFCDNJALEOJ {
        static instance: EFCDNJALEOJ = EFCDNJALEOJ {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EFCDNJALEOJ {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EFCDNJALEOJ").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EFCDNJALEOJ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EFCDNJALEOJ {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGNHMHLODCO)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGNHMHLODCO {
    // message fields
    // @@protoc_insertion_point(field:CGNHMHLODCO.battle_info)
    pub battle_info: ::protobuf::MessageField<super::SceneBattleInfo::SceneBattleInfo>,
    // @@protoc_insertion_point(field:CGNHMHLODCO.retcode)
    pub retcode: u32,
    // special fields
    // @@protoc_insertion_point(special_field:CGNHMHLODCO.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGNHMHLODCO {
    fn default() -> &'a CGNHMHLODCO {
        <CGNHMHLODCO as ::protobuf::Message>::default_instance()
    }
}

impl CGNHMHLODCO {
    pub fn new() -> CGNHMHLODCO {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::SceneBattleInfo::SceneBattleInfo>(
            "battle_info",
            |m: &CGNHMHLODCO| { &m.battle_info },
            |m: &mut CGNHMHLODCO| { &mut m.battle_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &CGNHMHLODCO| { &m.retcode },
            |m: &mut CGNHMHLODCO| { &mut m.retcode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGNHMHLODCO>(
            "CGNHMHLODCO",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGNHMHLODCO {
    const NAME: &'static str = "CGNHMHLODCO";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.battle_info)?;
                },
                96 => {
                    self.retcode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.battle_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.retcode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.battle_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if self.retcode != 0 {
            os.write_uint32(12, self.retcode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGNHMHLODCO {
        CGNHMHLODCO::new()
    }

    fn clear(&mut self) {
        self.battle_info.clear();
        self.retcode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGNHMHLODCO {
        static instance: CGNHMHLODCO = CGNHMHLODCO {
            battle_info: ::protobuf::MessageField::none(),
            retcode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGNHMHLODCO {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGNHMHLODCO").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGNHMHLODCO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGNHMHLODCO {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PBLFCMEHPFO)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PBLFCMEHPFO {
    // message fields
    // @@protoc_insertion_point(field:PBLFCMEHPFO.LJEPIBBDFNJ)
    pub LJEPIBBDFNJ: u32,
    // @@protoc_insertion_point(field:PBLFCMEHPFO.NAEKJBOEMCA)
    pub NAEKJBOEMCA: u32,
    // @@protoc_insertion_point(field:PBLFCMEHPFO.FEJOAEALKDF)
    pub FEJOAEALKDF: ::std::vec::Vec<SwordTrainingStatus>,
    // special fields
    // @@protoc_insertion_point(special_field:PBLFCMEHPFO.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PBLFCMEHPFO {
    fn default() -> &'a PBLFCMEHPFO {
        <PBLFCMEHPFO as ::protobuf::Message>::default_instance()
    }
}

impl PBLFCMEHPFO {
    pub fn new() -> PBLFCMEHPFO {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LJEPIBBDFNJ",
            |m: &PBLFCMEHPFO| { &m.LJEPIBBDFNJ },
            |m: &mut PBLFCMEHPFO| { &mut m.LJEPIBBDFNJ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NAEKJBOEMCA",
            |m: &PBLFCMEHPFO| { &m.NAEKJBOEMCA },
            |m: &mut PBLFCMEHPFO| { &mut m.NAEKJBOEMCA },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "FEJOAEALKDF",
            |m: &PBLFCMEHPFO| { &m.FEJOAEALKDF },
            |m: &mut PBLFCMEHPFO| { &mut m.FEJOAEALKDF },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PBLFCMEHPFO>(
            "PBLFCMEHPFO",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PBLFCMEHPFO {
    const NAME: &'static str = "PBLFCMEHPFO";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.LJEPIBBDFNJ = is.read_uint32()?;
                },
                48 => {
                    self.NAEKJBOEMCA = is.read_uint32()?;
                },
                34 => {
                    self.FEJOAEALKDF.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.LJEPIBBDFNJ != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.LJEPIBBDFNJ);
        }
        if self.NAEKJBOEMCA != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.NAEKJBOEMCA);
        }
        for value in &self.FEJOAEALKDF {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.LJEPIBBDFNJ != 0 {
            os.write_uint32(2, self.LJEPIBBDFNJ)?;
        }
        if self.NAEKJBOEMCA != 0 {
            os.write_uint32(6, self.NAEKJBOEMCA)?;
        }
        for v in &self.FEJOAEALKDF {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PBLFCMEHPFO {
        PBLFCMEHPFO::new()
    }

    fn clear(&mut self) {
        self.LJEPIBBDFNJ = 0;
        self.NAEKJBOEMCA = 0;
        self.FEJOAEALKDF.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PBLFCMEHPFO {
        static instance: PBLFCMEHPFO = PBLFCMEHPFO {
            LJEPIBBDFNJ: 0,
            NAEKJBOEMCA: 0,
            FEJOAEALKDF: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PBLFCMEHPFO {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PBLFCMEHPFO").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PBLFCMEHPFO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBLFCMEHPFO {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HLDHAFGIPOE)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HLDHAFGIPOE {
    // message fields
    // @@protoc_insertion_point(field:HLDHAFGIPOE.IFMANDPGKIE)
    pub IFMANDPGKIE: u32,
    // special fields
    // @@protoc_insertion_point(special_field:HLDHAFGIPOE.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HLDHAFGIPOE {
    fn default() -> &'a HLDHAFGIPOE {
        <HLDHAFGIPOE as ::protobuf::Message>::default_instance()
    }
}

impl HLDHAFGIPOE {
    pub fn new() -> HLDHAFGIPOE {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "IFMANDPGKIE",
            |m: &HLDHAFGIPOE| { &m.IFMANDPGKIE },
            |m: &mut HLDHAFGIPOE| { &mut m.IFMANDPGKIE },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HLDHAFGIPOE>(
            "HLDHAFGIPOE",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HLDHAFGIPOE {
    const NAME: &'static str = "HLDHAFGIPOE";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.IFMANDPGKIE = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.IFMANDPGKIE != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.IFMANDPGKIE);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.IFMANDPGKIE != 0 {
            os.write_uint32(10, self.IFMANDPGKIE)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HLDHAFGIPOE {
        HLDHAFGIPOE::new()
    }

    fn clear(&mut self) {
        self.IFMANDPGKIE = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HLDHAFGIPOE {
        static instance: HLDHAFGIPOE = HLDHAFGIPOE {
            IFMANDPGKIE: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HLDHAFGIPOE {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HLDHAFGIPOE").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HLDHAFGIPOE {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HLDHAFGIPOE {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:KLEHMMANNOI)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KLEHMMANNOI {
    // message fields
    // @@protoc_insertion_point(field:KLEHMMANNOI.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:KLEHMMANNOI.reward)
    pub reward: ::protobuf::MessageField<super::ItemList::ItemList>,
    // special fields
    // @@protoc_insertion_point(special_field:KLEHMMANNOI.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KLEHMMANNOI {
    fn default() -> &'a KLEHMMANNOI {
        <KLEHMMANNOI as ::protobuf::Message>::default_instance()
    }
}

impl KLEHMMANNOI {
    pub fn new() -> KLEHMMANNOI {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &KLEHMMANNOI| { &m.retcode },
            |m: &mut KLEHMMANNOI| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::ItemList::ItemList>(
            "reward",
            |m: &KLEHMMANNOI| { &m.reward },
            |m: &mut KLEHMMANNOI| { &mut m.reward },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KLEHMMANNOI>(
            "KLEHMMANNOI",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KLEHMMANNOI {
    const NAME: &'static str = "KLEHMMANNOI";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                72 => {
                    self.retcode = is.read_uint32()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reward)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.retcode);
        }
        if let Some(v) = self.reward.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(9, self.retcode)?;
        }
        if let Some(v) = self.reward.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KLEHMMANNOI {
        KLEHMMANNOI::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.reward.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KLEHMMANNOI {
        static instance: KLEHMMANNOI = KLEHMMANNOI {
            retcode: 0,
            reward: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KLEHMMANNOI {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KLEHMMANNOI").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KLEHMMANNOI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KLEHMMANNOI {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MNABGDHDJAJ)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MNABGDHDJAJ {
    // message fields
    // @@protoc_insertion_point(field:MNABGDHDJAJ.story_id)
    pub story_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:MNABGDHDJAJ.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MNABGDHDJAJ {
    fn default() -> &'a MNABGDHDJAJ {
        <MNABGDHDJAJ as ::protobuf::Message>::default_instance()
    }
}

impl MNABGDHDJAJ {
    pub fn new() -> MNABGDHDJAJ {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "story_id",
            |m: &MNABGDHDJAJ| { &m.story_id },
            |m: &mut MNABGDHDJAJ| { &mut m.story_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MNABGDHDJAJ>(
            "MNABGDHDJAJ",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MNABGDHDJAJ {
    const NAME: &'static str = "MNABGDHDJAJ";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.story_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.story_id != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.story_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.story_id != 0 {
            os.write_uint32(10, self.story_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MNABGDHDJAJ {
        MNABGDHDJAJ::new()
    }

    fn clear(&mut self) {
        self.story_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MNABGDHDJAJ {
        static instance: MNABGDHDJAJ = MNABGDHDJAJ {
            story_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MNABGDHDJAJ {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MNABGDHDJAJ").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MNABGDHDJAJ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MNABGDHDJAJ {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PPLNOKJDGPC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PPLNOKJDGPC {
    // message fields
    // @@protoc_insertion_point(field:PPLNOKJDGPC.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:PPLNOKJDGPC.game_info)
    pub game_info: ::protobuf::MessageField<SwordTrainingGameInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:PPLNOKJDGPC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PPLNOKJDGPC {
    fn default() -> &'a PPLNOKJDGPC {
        <PPLNOKJDGPC as ::protobuf::Message>::default_instance()
    }
}

impl PPLNOKJDGPC {
    pub fn new() -> PPLNOKJDGPC {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &PPLNOKJDGPC| { &m.retcode },
            |m: &mut PPLNOKJDGPC| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SwordTrainingGameInfo>(
            "game_info",
            |m: &PPLNOKJDGPC| { &m.game_info },
            |m: &mut PPLNOKJDGPC| { &mut m.game_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PPLNOKJDGPC>(
            "PPLNOKJDGPC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PPLNOKJDGPC {
    const NAME: &'static str = "PPLNOKJDGPC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                112 => {
                    self.retcode = is.read_uint32()?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.retcode);
        }
        if let Some(v) = self.game_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(14, self.retcode)?;
        }
        if let Some(v) = self.game_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PPLNOKJDGPC {
        PPLNOKJDGPC::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.game_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PPLNOKJDGPC {
        static instance: PPLNOKJDGPC = PPLNOKJDGPC {
            retcode: 0,
            game_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PPLNOKJDGPC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PPLNOKJDGPC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PPLNOKJDGPC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PPLNOKJDGPC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NENMDHEHAKM)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NENMDHEHAKM {
    // special fields
    // @@protoc_insertion_point(special_field:NENMDHEHAKM.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NENMDHEHAKM {
    fn default() -> &'a NENMDHEHAKM {
        <NENMDHEHAKM as ::protobuf::Message>::default_instance()
    }
}

impl NENMDHEHAKM {
    pub fn new() -> NENMDHEHAKM {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NENMDHEHAKM>(
            "NENMDHEHAKM",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NENMDHEHAKM {
    const NAME: &'static str = "NENMDHEHAKM";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NENMDHEHAKM {
        NENMDHEHAKM::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NENMDHEHAKM {
        static instance: NENMDHEHAKM = NENMDHEHAKM {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NENMDHEHAKM {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NENMDHEHAKM").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NENMDHEHAKM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NENMDHEHAKM {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:AGAIFKGBKCD)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AGAIFKGBKCD {
    // message fields
    // @@protoc_insertion_point(field:AGAIFKGBKCD.rank)
    pub rank: u32,
    // @@protoc_insertion_point(field:AGAIFKGBKCD.retcode)
    pub retcode: u32,
    // special fields
    // @@protoc_insertion_point(special_field:AGAIFKGBKCD.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AGAIFKGBKCD {
    fn default() -> &'a AGAIFKGBKCD {
        <AGAIFKGBKCD as ::protobuf::Message>::default_instance()
    }
}

impl AGAIFKGBKCD {
    pub fn new() -> AGAIFKGBKCD {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rank",
            |m: &AGAIFKGBKCD| { &m.rank },
            |m: &mut AGAIFKGBKCD| { &mut m.rank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &AGAIFKGBKCD| { &m.retcode },
            |m: &mut AGAIFKGBKCD| { &mut m.retcode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AGAIFKGBKCD>(
            "AGAIFKGBKCD",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AGAIFKGBKCD {
    const NAME: &'static str = "AGAIFKGBKCD";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rank = is.read_uint32()?;
                },
                64 => {
                    self.retcode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.rank != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.rank);
        }
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.retcode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.rank != 0 {
            os.write_uint32(1, self.rank)?;
        }
        if self.retcode != 0 {
            os.write_uint32(8, self.retcode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AGAIFKGBKCD {
        AGAIFKGBKCD::new()
    }

    fn clear(&mut self) {
        self.rank = 0;
        self.retcode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AGAIFKGBKCD {
        static instance: AGAIFKGBKCD = AGAIFKGBKCD {
            rank: 0,
            retcode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AGAIFKGBKCD {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AGAIFKGBKCD").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AGAIFKGBKCD {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AGAIFKGBKCD {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LDBDDLPJEEP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LDBDDLPJEEP {
    // message fields
    // @@protoc_insertion_point(field:LDBDDLPJEEP.CCLGMCIMGLH)
    pub CCLGMCIMGLH: u32,
    // special fields
    // @@protoc_insertion_point(special_field:LDBDDLPJEEP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LDBDDLPJEEP {
    fn default() -> &'a LDBDDLPJEEP {
        <LDBDDLPJEEP as ::protobuf::Message>::default_instance()
    }
}

impl LDBDDLPJEEP {
    pub fn new() -> LDBDDLPJEEP {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CCLGMCIMGLH",
            |m: &LDBDDLPJEEP| { &m.CCLGMCIMGLH },
            |m: &mut LDBDDLPJEEP| { &mut m.CCLGMCIMGLH },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LDBDDLPJEEP>(
            "LDBDDLPJEEP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LDBDDLPJEEP {
    const NAME: &'static str = "LDBDDLPJEEP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.CCLGMCIMGLH = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.CCLGMCIMGLH != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.CCLGMCIMGLH);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.CCLGMCIMGLH != 0 {
            os.write_uint32(1, self.CCLGMCIMGLH)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LDBDDLPJEEP {
        LDBDDLPJEEP::new()
    }

    fn clear(&mut self) {
        self.CCLGMCIMGLH = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LDBDDLPJEEP {
        static instance: LDBDDLPJEEP = LDBDDLPJEEP {
            CCLGMCIMGLH: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LDBDDLPJEEP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LDBDDLPJEEP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LDBDDLPJEEP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LDBDDLPJEEP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BNBHKDENLOE)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BNBHKDENLOE {
    // message fields
    // @@protoc_insertion_point(field:BNBHKDENLOE.retcode)
    pub retcode: u32,
    // @@protoc_insertion_point(field:BNBHKDENLOE.CCLGMCIMGLH)
    pub CCLGMCIMGLH: u32,
    // special fields
    // @@protoc_insertion_point(special_field:BNBHKDENLOE.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BNBHKDENLOE {
    fn default() -> &'a BNBHKDENLOE {
        <BNBHKDENLOE as ::protobuf::Message>::default_instance()
    }
}

impl BNBHKDENLOE {
    pub fn new() -> BNBHKDENLOE {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retcode",
            |m: &BNBHKDENLOE| { &m.retcode },
            |m: &mut BNBHKDENLOE| { &mut m.retcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CCLGMCIMGLH",
            |m: &BNBHKDENLOE| { &m.CCLGMCIMGLH },
            |m: &mut BNBHKDENLOE| { &mut m.CCLGMCIMGLH },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BNBHKDENLOE>(
            "BNBHKDENLOE",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BNBHKDENLOE {
    const NAME: &'static str = "BNBHKDENLOE";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                72 => {
                    self.retcode = is.read_uint32()?;
                },
                48 => {
                    self.CCLGMCIMGLH = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.retcode != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.retcode);
        }
        if self.CCLGMCIMGLH != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.CCLGMCIMGLH);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.retcode != 0 {
            os.write_uint32(9, self.retcode)?;
        }
        if self.CCLGMCIMGLH != 0 {
            os.write_uint32(6, self.CCLGMCIMGLH)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BNBHKDENLOE {
        BNBHKDENLOE::new()
    }

    fn clear(&mut self) {
        self.retcode = 0;
        self.CCLGMCIMGLH = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BNBHKDENLOE {
        static instance: BNBHKDENLOE = BNBHKDENLOE {
            retcode: 0,
            CCLGMCIMGLH: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BNBHKDENLOE {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BNBHKDENLOE").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BNBHKDENLOE {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BNBHKDENLOE {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:IMPNHHHPMBA)
pub enum IMPNHHHPMBA {
    // @@protoc_insertion_point(enum_value:IMPNHHHPMBA.SWORD_TRAIN_GAME_SOURCE_TYPE_NONE)
    SWORD_TRAIN_GAME_SOURCE_TYPE_NONE = 0,
    // @@protoc_insertion_point(enum_value:IMPNHHHPMBA.SWORD_TRAIN_GAME_SOURCE_TYPE_TURN_SETTLE)
    SWORD_TRAIN_GAME_SOURCE_TYPE_TURN_SETTLE = 1,
    // @@protoc_insertion_point(enum_value:IMPNHHHPMBA.SWORD_TRAIN_GAME_SOURCE_TYPE_STATUS_UPGRADE)
    SWORD_TRAIN_GAME_SOURCE_TYPE_STATUS_UPGRADE = 2,
    // @@protoc_insertion_point(enum_value:IMPNHHHPMBA.SWORD_TRAIN_GAME_SOURCE_TYPE_ACTION)
    SWORD_TRAIN_GAME_SOURCE_TYPE_ACTION = 3,
    // @@protoc_insertion_point(enum_value:IMPNHHHPMBA.SWORD_TRAIN_GAME_SOURCE_TYPE_ACTION_HINT)
    SWORD_TRAIN_GAME_SOURCE_TYPE_ACTION_HINT = 4,
    // @@protoc_insertion_point(enum_value:IMPNHHHPMBA.SWORD_TRAIN_GAME_SOURCE_TYPE_STORY)
    SWORD_TRAIN_GAME_SOURCE_TYPE_STORY = 5,
    // @@protoc_insertion_point(enum_value:IMPNHHHPMBA.SWORD_TRAIN_GAME_SOURCE_TYPE_EXAM_BONUS)
    SWORD_TRAIN_GAME_SOURCE_TYPE_EXAM_BONUS = 6,
    // @@protoc_insertion_point(enum_value:IMPNHHHPMBA.SWORD_TRAIN_GAME_SOURCE_TYPE_DIALOGUE)
    SWORD_TRAIN_GAME_SOURCE_TYPE_DIALOGUE = 7,
}

impl ::protobuf::Enum for IMPNHHHPMBA {
    const NAME: &'static str = "IMPNHHHPMBA";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<IMPNHHHPMBA> {
        match value {
            0 => ::std::option::Option::Some(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_NONE),
            1 => ::std::option::Option::Some(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_TURN_SETTLE),
            2 => ::std::option::Option::Some(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_STATUS_UPGRADE),
            3 => ::std::option::Option::Some(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_ACTION),
            4 => ::std::option::Option::Some(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_ACTION_HINT),
            5 => ::std::option::Option::Some(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_STORY),
            6 => ::std::option::Option::Some(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_EXAM_BONUS),
            7 => ::std::option::Option::Some(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_DIALOGUE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<IMPNHHHPMBA> {
        match str {
            "SWORD_TRAIN_GAME_SOURCE_TYPE_NONE" => ::std::option::Option::Some(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_NONE),
            "SWORD_TRAIN_GAME_SOURCE_TYPE_TURN_SETTLE" => ::std::option::Option::Some(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_TURN_SETTLE),
            "SWORD_TRAIN_GAME_SOURCE_TYPE_STATUS_UPGRADE" => ::std::option::Option::Some(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_STATUS_UPGRADE),
            "SWORD_TRAIN_GAME_SOURCE_TYPE_ACTION" => ::std::option::Option::Some(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_ACTION),
            "SWORD_TRAIN_GAME_SOURCE_TYPE_ACTION_HINT" => ::std::option::Option::Some(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_ACTION_HINT),
            "SWORD_TRAIN_GAME_SOURCE_TYPE_STORY" => ::std::option::Option::Some(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_STORY),
            "SWORD_TRAIN_GAME_SOURCE_TYPE_EXAM_BONUS" => ::std::option::Option::Some(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_EXAM_BONUS),
            "SWORD_TRAIN_GAME_SOURCE_TYPE_DIALOGUE" => ::std::option::Option::Some(IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_DIALOGUE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [IMPNHHHPMBA] = &[
        IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_NONE,
        IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_TURN_SETTLE,
        IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_STATUS_UPGRADE,
        IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_ACTION,
        IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_ACTION_HINT,
        IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_STORY,
        IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_EXAM_BONUS,
        IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_DIALOGUE,
    ];
}

impl ::protobuf::EnumFull for IMPNHHHPMBA {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("IMPNHHHPMBA").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for IMPNHHHPMBA {
    fn default() -> Self {
        IMPNHHHPMBA::SWORD_TRAIN_GAME_SOURCE_TYPE_NONE
    }
}

impl IMPNHHHPMBA {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<IMPNHHHPMBA>("IMPNHHHPMBA")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SwordTrainingDailyPhaseType)
pub enum SwordTrainingDailyPhaseType {
    // @@protoc_insertion_point(enum_value:SwordTrainingDailyPhaseType.SWORD_TRAINING_DAILY_PHASE_TYPE_NONE)
    SWORD_TRAINING_DAILY_PHASE_TYPE_NONE = 0,
    // @@protoc_insertion_point(enum_value:SwordTrainingDailyPhaseType.SWORD_TRAINING_DAILY_PHASE_TYPE_MORNING)
    SWORD_TRAINING_DAILY_PHASE_TYPE_MORNING = 1,
    // @@protoc_insertion_point(enum_value:SwordTrainingDailyPhaseType.SWORD_TRAINING_DAILY_PHASE_TYPE_NOON)
    SWORD_TRAINING_DAILY_PHASE_TYPE_NOON = 2,
    // @@protoc_insertion_point(enum_value:SwordTrainingDailyPhaseType.SWORD_TRAINING_DAILY_PHASE_TYPE_AFTERNOON)
    SWORD_TRAINING_DAILY_PHASE_TYPE_AFTERNOON = 3,
    // @@protoc_insertion_point(enum_value:SwordTrainingDailyPhaseType.SWORD_TRAINING_DAILY_PHASE_TYPE_EVENING)
    SWORD_TRAINING_DAILY_PHASE_TYPE_EVENING = 4,
}

impl ::protobuf::Enum for SwordTrainingDailyPhaseType {
    const NAME: &'static str = "SwordTrainingDailyPhaseType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SwordTrainingDailyPhaseType> {
        match value {
            0 => ::std::option::Option::Some(SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_NONE),
            1 => ::std::option::Option::Some(SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_MORNING),
            2 => ::std::option::Option::Some(SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_NOON),
            3 => ::std::option::Option::Some(SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_AFTERNOON),
            4 => ::std::option::Option::Some(SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_EVENING),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SwordTrainingDailyPhaseType> {
        match str {
            "SWORD_TRAINING_DAILY_PHASE_TYPE_NONE" => ::std::option::Option::Some(SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_NONE),
            "SWORD_TRAINING_DAILY_PHASE_TYPE_MORNING" => ::std::option::Option::Some(SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_MORNING),
            "SWORD_TRAINING_DAILY_PHASE_TYPE_NOON" => ::std::option::Option::Some(SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_NOON),
            "SWORD_TRAINING_DAILY_PHASE_TYPE_AFTERNOON" => ::std::option::Option::Some(SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_AFTERNOON),
            "SWORD_TRAINING_DAILY_PHASE_TYPE_EVENING" => ::std::option::Option::Some(SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_EVENING),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SwordTrainingDailyPhaseType] = &[
        SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_NONE,
        SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_MORNING,
        SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_NOON,
        SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_AFTERNOON,
        SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_EVENING,
    ];
}

impl ::protobuf::EnumFull for SwordTrainingDailyPhaseType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SwordTrainingDailyPhaseType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SwordTrainingDailyPhaseType {
    fn default() -> Self {
        SwordTrainingDailyPhaseType::SWORD_TRAINING_DAILY_PHASE_TYPE_NONE
    }
}

impl SwordTrainingDailyPhaseType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SwordTrainingDailyPhaseType>("SwordTrainingDailyPhaseType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SwordTrainingStatusType)
pub enum SwordTrainingStatusType {
    // @@protoc_insertion_point(enum_value:SwordTrainingStatusType.SWORD_TRAINING_STATUS_TYPE_NONE)
    SWORD_TRAINING_STATUS_TYPE_NONE = 0,
    // @@protoc_insertion_point(enum_value:SwordTrainingStatusType.SWORD_TRAINING_STATUS_TYPE_POWER)
    SWORD_TRAINING_STATUS_TYPE_POWER = 1,
    // @@protoc_insertion_point(enum_value:SwordTrainingStatusType.SWORD_TRAINING_STATUS_TYPE_AGILITY)
    SWORD_TRAINING_STATUS_TYPE_AGILITY = 2,
    // @@protoc_insertion_point(enum_value:SwordTrainingStatusType.SWORD_TRAINING_STATUS_TYPE_TOUGHNESS)
    SWORD_TRAINING_STATUS_TYPE_TOUGHNESS = 3,
    // @@protoc_insertion_point(enum_value:SwordTrainingStatusType.SWORD_TRAINING_STATUS_TYPE_PERCEPTION)
    SWORD_TRAINING_STATUS_TYPE_PERCEPTION = 4,
    // @@protoc_insertion_point(enum_value:SwordTrainingStatusType._SWORD_TRAINING_STATUS_TYPE_MAX)
    _SWORD_TRAINING_STATUS_TYPE_MAX = 5,
}

impl ::protobuf::Enum for SwordTrainingStatusType {
    const NAME: &'static str = "SwordTrainingStatusType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SwordTrainingStatusType> {
        match value {
            0 => ::std::option::Option::Some(SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_NONE),
            1 => ::std::option::Option::Some(SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_POWER),
            2 => ::std::option::Option::Some(SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_AGILITY),
            3 => ::std::option::Option::Some(SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_TOUGHNESS),
            4 => ::std::option::Option::Some(SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_PERCEPTION),
            5 => ::std::option::Option::Some(SwordTrainingStatusType::_SWORD_TRAINING_STATUS_TYPE_MAX),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SwordTrainingStatusType> {
        match str {
            "SWORD_TRAINING_STATUS_TYPE_NONE" => ::std::option::Option::Some(SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_NONE),
            "SWORD_TRAINING_STATUS_TYPE_POWER" => ::std::option::Option::Some(SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_POWER),
            "SWORD_TRAINING_STATUS_TYPE_AGILITY" => ::std::option::Option::Some(SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_AGILITY),
            "SWORD_TRAINING_STATUS_TYPE_TOUGHNESS" => ::std::option::Option::Some(SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_TOUGHNESS),
            "SWORD_TRAINING_STATUS_TYPE_PERCEPTION" => ::std::option::Option::Some(SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_PERCEPTION),
            "_SWORD_TRAINING_STATUS_TYPE_MAX" => ::std::option::Option::Some(SwordTrainingStatusType::_SWORD_TRAINING_STATUS_TYPE_MAX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SwordTrainingStatusType] = &[
        SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_NONE,
        SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_POWER,
        SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_AGILITY,
        SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_TOUGHNESS,
        SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_PERCEPTION,
        SwordTrainingStatusType::_SWORD_TRAINING_STATUS_TYPE_MAX,
    ];
}

impl ::protobuf::EnumFull for SwordTrainingStatusType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SwordTrainingStatusType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SwordTrainingStatusType {
    fn default() -> Self {
        SwordTrainingStatusType::SWORD_TRAINING_STATUS_TYPE_NONE
    }
}

impl SwordTrainingStatusType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SwordTrainingStatusType>("SwordTrainingStatusType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SwordTrainingGameSettle)
pub enum SwordTrainingGameSettle {
    // @@protoc_insertion_point(enum_value:SwordTrainingGameSettle.SWORD_TRAINING_GAME_SETTLE_NONE)
    SWORD_TRAINING_GAME_SETTLE_NONE = 0,
    // @@protoc_insertion_point(enum_value:SwordTrainingGameSettle.SWORD_TRAINING_GAME_SETTLE_FINISH)
    SWORD_TRAINING_GAME_SETTLE_FINISH = 1,
    // @@protoc_insertion_point(enum_value:SwordTrainingGameSettle.SWORD_TRAINING_GAME_SETTLE_GIVE_UP)
    SWORD_TRAINING_GAME_SETTLE_GIVE_UP = 2,
    // @@protoc_insertion_point(enum_value:SwordTrainingGameSettle.SWORD_TRAINING_GAME_SETTLE_BATTLE_FAILED)
    SWORD_TRAINING_GAME_SETTLE_BATTLE_FAILED = 3,
    // @@protoc_insertion_point(enum_value:SwordTrainingGameSettle.SWORD_TRAINING_GAME_SETTLE_FORCE)
    SWORD_TRAINING_GAME_SETTLE_FORCE = 4,
    // @@protoc_insertion_point(enum_value:SwordTrainingGameSettle.SWORD_TRAINING_GAME_SETTLE_BY_RESTORE)
    SWORD_TRAINING_GAME_SETTLE_BY_RESTORE = 5,
}

impl ::protobuf::Enum for SwordTrainingGameSettle {
    const NAME: &'static str = "SwordTrainingGameSettle";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SwordTrainingGameSettle> {
        match value {
            0 => ::std::option::Option::Some(SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_NONE),
            1 => ::std::option::Option::Some(SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_FINISH),
            2 => ::std::option::Option::Some(SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_GIVE_UP),
            3 => ::std::option::Option::Some(SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_BATTLE_FAILED),
            4 => ::std::option::Option::Some(SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_FORCE),
            5 => ::std::option::Option::Some(SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_BY_RESTORE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SwordTrainingGameSettle> {
        match str {
            "SWORD_TRAINING_GAME_SETTLE_NONE" => ::std::option::Option::Some(SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_NONE),
            "SWORD_TRAINING_GAME_SETTLE_FINISH" => ::std::option::Option::Some(SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_FINISH),
            "SWORD_TRAINING_GAME_SETTLE_GIVE_UP" => ::std::option::Option::Some(SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_GIVE_UP),
            "SWORD_TRAINING_GAME_SETTLE_BATTLE_FAILED" => ::std::option::Option::Some(SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_BATTLE_FAILED),
            "SWORD_TRAINING_GAME_SETTLE_FORCE" => ::std::option::Option::Some(SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_FORCE),
            "SWORD_TRAINING_GAME_SETTLE_BY_RESTORE" => ::std::option::Option::Some(SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_BY_RESTORE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SwordTrainingGameSettle] = &[
        SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_NONE,
        SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_FINISH,
        SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_GIVE_UP,
        SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_BATTLE_FAILED,
        SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_FORCE,
        SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_BY_RESTORE,
    ];
}

impl ::protobuf::EnumFull for SwordTrainingGameSettle {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SwordTrainingGameSettle").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SwordTrainingGameSettle {
    fn default() -> Self {
        SwordTrainingGameSettle::SWORD_TRAINING_GAME_SETTLE_NONE
    }
}

impl SwordTrainingGameSettle {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SwordTrainingGameSettle>("SwordTrainingGameSettle")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1bActivitySwordTraining.proto\x1a\x15SceneBattleInfo.proto\x1a\x0eIt\
    emList.proto\"\xe5\x04\n\x15SwordTrainingGameInfo\x126\n\nskill_info\x18\
    \x0f\x20\x01(\x0b2\x17.SwordTrainingSkillInfoR\tskillInfo\x12R\n\x19swor\
    d_training_story_info\x18\x03\x20\x01(\x0b2\x17.SwordTrainingStoryInfoR\
    \x16swordTrainingStoryInfo\x12F\n\x10status_type_info\x18\x0c\x20\x01(\
    \x0b2\x1c.SwordTrainingStatusTypeInfoR\x0estatusTypeInfo\x12<\n\x0cpartn\
    er_info\x18\x0e\x20\x01(\x0b2\x19.SwordTrainingPartnerInfoR\x0bpartnerIn\
    fo\x123\n\tturn_info\x18\x02\x20\x01(\x0b2\x16.SwordTrainingTurnInfoR\
    \x08turnInfo\x12B\n\x0epending_action\x18\x01\x20\x01(\x0b2\x1b.SwordTra\
    iningPendingActionR\rpendingAction\x12\x20\n\x0bMGKDFNBENAI\x18\x05\x20\
    \x01(\rR\x0bMGKDFNBENAI\x12B\n\x10effect_info_list\x18\x08\x20\x03(\x0b2\
    \x18.SwordTrainingEffectInfoR\x0eeffectInfoList\x12\x20\n\x0bDPHNBKLJEHM\
    \x18\x06\x20\x03(\rR\x0bDPHNBKLJEHM\x129\n\x0baction_info\x18\x0b\x20\
    \x01(\x0b2\x18.SwordTrainingActionInfoR\nactionInfo\"4\n\x1eSwordTrainin\
    gGetSkillInfoCsReq\x12\x12\n\x04slot\x18\x01\x20\x01(\rR\x04slot\"\x92\
    \x01\n\x1eSwordTrainingGetSkillInfoScRsp\x12\x12\n\x04slot\x18\x02\x20\
    \x01(\rR\x04slot\x12\x18\n\x07retcode\x18\x0f\x20\x01(\rR\x07retcode\x12\
    \x20\n\x0bNHPHHAPJODG\x18\x07\x20\x03(\rR\x0bNHPHHAPJODG\x12\x20\n\x0bFE\
    KILLBIEKO\x18\x05\x20\x03(\rR\x0bFEKILLBIEKO\"W\n\x17SwordTrainingEffect\
    Info\x12\x1f\n\x0beffect_type\x18\t\x20\x01(\rR\neffectType\x12\x1b\n\tc\
    onfig_id\x18\x06\x20\x01(\rR\x08configId\"\xa0\x01\n\x16SwordTrainingSki\
    llInfo\x12\x20\n\x0bOAJMNPADHGA\x18\x0e\x20\x01(\rR\x0bOAJMNPADHGA\x12\
    \x20\n\x0bPAOJAAONCBF\x18\x07\x20\x01(\rR\x0bPAOJAAONCBF\x12\x20\n\x0bBC\
    MNPJJHJAD\x18\x01\x20\x01(\rR\x0bBCMNPJJHJAD\x12\x20\n\x0bFEKILLBIEKO\
    \x18\x02\x20\x03(\rR\x0bFEKILLBIEKO\"R\n\x14SwordTrainingPartner\x12\x1d\
    \n\npartner_id\x18\x06\x20\x01(\rR\tpartnerId\x12\x1b\n\tavatar_id\x18\
    \x0b\x20\x01(\rR\x08avatarId\"T\n\x18SwordTrainingPartnerInfo\x128\n\x0c\
    partner_list\x18\t\x20\x03(\x0b2\x15.SwordTrainingPartnerR\x0bpartnerLis\
    t\"\x92\x01\n\x16SwordTrainingStoryInfo\x12\x19\n\x08story_id\x18\x07\
    \x20\x01(\rR\x07storyId\x12\x17\n\x07hint_id\x18\x06\x20\x01(\rR\x06hint\
    Id\x12\"\n\rstory_id_list\x18\x03\x20\x03(\rR\x0bstoryIdList\x12\x20\n\
    \x0bHCMJKFEAADP\x18\x0b\x20\x03(\rR\x0bHCMJKFEAADP\"\x94\x01\n\x13SwordT\
    rainingStatus\x12\x20\n\x0bDIBKEHHCPAP\x18\n\x20\x01(\rR\x0bDIBKEHHCPAP\
    \x12\x20\n\x0bPCLPEHLNDAF\x18\x04\x20\x01(\rR\x0bPCLPEHLNDAF\x129\n\x0bs\
    tatus_type\x18\x07\x20\x01(\x0e2\x18.SwordTrainingStatusTypeR\nstatusTyp\
    e\"\x96\x01\n\x1bSwordTrainingStatusTypeInfo\x12\x1f\n\x0bskill_point\
    \x18\x06\x20\x01(\rR\nskillPoint\x125\n\x0bstatus_list\x18\x0e\x20\x03(\
    \x0b2\x14.SwordTrainingStatusR\nstatusList\x12\x1f\n\x0bcombat_rank\x18\
    \x03\x20\x01(\rR\ncombatRank\"P\n\x17SwordTrainingStatusList\x125\n\x0bs\
    tatus_list\x18\x05\x20\x03(\x0b2\x14.SwordTrainingStatusR\nstatusList\"H\
    \n\x13SwordTrainingAction\x12\x1b\n\tunique_id\x18\x06\x20\x01(\rR\x08un\
    iqueId\x12\x14\n\x05level\x18\x01\x20\x01(\rR\x05level\"P\n\x17SwordTrai\
    ningActionInfo\x125\n\x0baction_list\x18\x02\x20\x03(\x0b2\x14.SwordTrai\
    ningActionR\nactionList\"\xba\x01\n\x15SwordTrainingTurnInfo\x12\x18\n\
    \x07turn_id\x18\xf8\x04\x20\x01(\rR\x06turnId\x12?\n\x0baction_turn\x18\
    \x0e\x20\x01(\x0b2\x1c.SwordTrainingActionTurnInfoH\0R\nactionTurn\x129\
    \n\texam_turn\x18\x04\x20\x01(\x0b2\x1a.SwordTrainingExamTurnInfoH\0R\
    \x08examTurnB\x0b\n\tturn_info\"Q\n\x0bNEMGFNPGEDK\x12\x20\n\x0bPAOKBIDA\
    NEJ\x18\x0e\x20\x01(\x05R\x0bPAOKBIDANEJ\x12\x20\n\x0bMMAKPNLBHII\x18\
    \x04\x20\x01(\x05R\x0bMMAKPNLBHII\"\x83\x01\n\x1bSwordTrainingPartnerAbi\
    lity\x12\x20\n\x0bADENLFJOOPL\x18\x0c\x20\x01(\rR\x0bADENLFJOOPL\x12\x20\
    \n\x0bPBNBFPABMFP\x18\x08\x20\x01(\rR\x0bPBNBFPABMFP\x12\x20\n\x0bMCKOMC\
    KFKLG\x18\x04\x20\x01(\rR\x0bMCKOMCKFKLG\"\xbf\x01\n\x1bSwordTrainingAct\
    ionTurnInfo\x12\x20\n\x0bJHINDCDBNML\x18\x0e\x20\x03(\rR\x0bJHINDCDBNML\
    \x12>\n\x0bGPJGAFFCMNG\x18\x0b\x20\x01(\x0e2\x1c.SwordTrainingDailyPhase\
    TypeR\x0bGPJGAFFCMNG\x12>\n\x0bLOJFKFFCEAA\x18\n\x20\x03(\x0b2\x1c.Sword\
    TrainingPartnerAbilityR\x0bLOJFKFFCEAA\"=\n\x19SwordTrainingExamTurnInfo\
    \x12\x20\n\x0bNONMKEIGEGF\x18\r\x20\x01(\rR\x0bNONMKEIGEGF\"\xb6\x03\n\
    \x1aSwordTrainingPendingAction\x120\n\x0bPCPAFLJBGDD\x18\x02\x20\x01(\
    \x0b2\x0c.PKGODKBNAAMH\0R\x0bPCPAFLJBGDD\x120\n\x0bLGBCIKNKPOK\x18\x03\
    \x20\x01(\x0b2\x0c.NJAHHFGIMBFH\0R\x0bLGBCIKNKPOK\x120\n\x0bJAHPBDGDIGN\
    \x18\t\x20\x01(\x0b2\x0c.NGFELCGLDGBH\0R\x0bJAHPBDGDIGN\x120\n\x0bOLNKGJ\
    DOECP\x18\x0e\x20\x01(\x0b2\x0c.OALMPFHPFPKH\0R\x0bOLNKGJDOECP\x120\n\
    \x0bDAIBJMDJPKJ\x18\x05\x20\x01(\x0b2\x0c.OEJIIDGGGBOH\0R\x0bDAIBJMDJPKJ\
    \x120\n\x0bAOPBDFIBFPH\x18\x04\x20\x01(\x0b2\x0c.BOIFCPNAOLCH\0R\x0bAOPB\
    DFIBFPH\x120\n\x0bAEPOACPOGND\x18\x07\x20\x01(\x0b2\x0c.LFNDEHMBKNNH\0R\
    \x0bAEPOACPOGND\x120\n\x0bAFGIMCBOJFL\x18\x0c\x20\x01(\x0b2\x0c.ENGJLGMA\
    OACH\0R\x0bAFGIMCBOJFLB\x08\n\x06action\"\x9d\x02\n\x0bABHNAFELEME\x12\
    \x20\n\x0bPCPAFLJBGDD\x18\x02\x20\x01(\x05R\x0bPCPAFLJBGDD\x12\x20\n\x0b\
    LGBCIKNKPOK\x18\x03\x20\x01(\x05R\x0bLGBCIKNKPOK\x12\x20\n\x0bJAHPBDGDIG\
    N\x18\t\x20\x01(\x05R\x0bJAHPBDGDIGN\x12\x20\n\x0bOLNKGJDOECP\x18\x0e\
    \x20\x01(\x05R\x0bOLNKGJDOECP\x12\x20\n\x0bDAIBJMDJPKJ\x18\x05\x20\x01(\
    \x05R\x0bDAIBJMDJPKJ\x12\x20\n\x0bAOPBDFIBFPH\x18\x04\x20\x01(\x05R\x0bA\
    OPBDFIBFPH\x12\x20\n\x0bAEPOACPOGND\x18\x07\x20\x01(\x05R\x0bAEPOACPOGND\
    \x12\x20\n\x0bAFGIMCBOJFL\x18\x0c\x20\x01(\x05R\x0bAFGIMCBOJFL\"\r\n\x0b\
    PKGODKBNAAM\"\r\n\x0bNJAHHFGIMBF\"/\n\x0bNGFELCGLDGB\x12\x20\n\x0bIAGJGJ\
    KGJBL\x18\n\x20\x01(\rR\x0bIAGJGJKGJBL\"\r\n\x0bOALMPFHPFPK\"Q\n\x0bOEJI\
    IDGGGBO\x12\x20\n\x0bLHMPHPEODNP\x18\x04\x20\x01(\rR\x0bLHMPHPEODNP\x12\
    \x20\n\x0bNBBEBBCAKBE\x18\x05\x20\x01(\x08R\x0bNBBEBBCAKBE\"\r\n\x0bBOIF\
    CPNAOLC\"\r\n\x0bLFNDEHMBKNN\"Q\n\x0bENGJLGMAOAC\x12\x20\n\x0bLHMPHPEODN\
    P\x18\x05\x20\x01(\rR\x0bLHMPHPEODNP\x12\x20\n\x0bMIIDPLKIHDA\x18\x01\
    \x20\x01(\x08R\x0bMIIDPLKIHDA\"c\n\x0bBFDCFCKHILP\x12$\n\x06action\x18\
    \x01\x20\x01(\x0b2\x0c.HNADJAAFBMJR\x06action\x12.\n\x0bLGEKDBJJLNI\x18\
    \x0e\x20\x01(\x0e2\x0c.IMPNHHHPMBAR\x0bLGEKDBJJLNI\"\xc7\x06\n\x0bHNADJA\
    AFBMJ\x120\n\x0bPEIIECHJBOH\x18\x03\x20\x01(\x0b2\x0c.EJNNNBLNJICH\0R\
    \x0bPEIIECHJBOH\x120\n\x0bLLBPGOIFDAD\x18\x08\x20\x01(\x0b2\x0c.HOFBPPLL\
    JGJH\0R\x0bLLBPGOIFDAD\x120\n\x0bILBOHKPGEBN\x18\x0f\x20\x01(\x0b2\x0c.H\
    OFBPPLLJGJH\0R\x0bILBOHKPGEBN\x120\n\x0bBJLIOIKGPCK\x18\x0e\x20\x01(\x0b\
    2\x0c.ANDOCAGGDMHH\0R\x0bBJLIOIKGPCK\x120\n\x0bBHCEKMIEFKC\x18\x02\x20\
    \x01(\x0b2\x0c.ANDOCAGGDMHH\0R\x0bBHCEKMIEFKC\x120\n\x0bINMOIILMOJN\x18\
    \x05\x20\x01(\x0b2\x0c.EFLKKNBMPHBH\0R\x0bINMOIILMOJN\x120\n\x0bLDMGDOGJ\
    KNC\x18\x0b\x20\x01(\x0b2\x0c.HNHNFFFGFJCH\0R\x0bLDMGDOGJKNC\x120\n\x0bN\
    OJFNAKKOJO\x18\n\x20\x01(\x0b2\x0c.OEJIIDGGGBOH\0R\x0bNOJFNAKKOJO\x12<\n\
    \x0bDOBMEMOFBDE\x18\x0c\x20\x01(\x0b2\x18.SwordTrainingEffectInfoH\0R\
    \x0bDOBMEMOFBDE\x12<\n\x0bFHFOFHBEIGI\x18\t\x20\x01(\x0b2\x18.SwordTrain\
    ingEffectInfoH\0R\x0bFHFOFHBEIGI\x120\n\x0bKABMHIGOCHM\x18\x01\x20\x01(\
    \x0b2\x0c.LCEMAIAAPCAH\0R\x0bKABMHIGOCHM\x12\"\n\x0bDMOGPPBEFNA\x18\x07\
    \x20\x01(\rH\0R\x0bDMOGPPBEFNA\x12\"\n\x0bcombat_rank\x18\xef\x04\x20\
    \x01(\rH\0R\ncombatRank\x12=\n\x0bIFBIMMDFOED\x18\xed\x08\x20\x01(\x0b2\
    \x18.SwordTrainingStatusListH\0R\x0bIFBIMMDFOED\x121\n\x0bKENCPJJECKL\
    \x18\xd7\x02\x20\x01(\x0b2\x0c.ENGJLGMAOACH\0R\x0bKENCPJJECKL\x121\n\x0b\
    NHNNHJBBGAB\x18\xeb\x05\x20\x01(\x0b2\x0c.BOIFCPNAOLCH\0R\x0bNHNNHJBBGAB\
    B\r\n\x0bKBKHABGINKB\"\xb0\x04\n\x0bKBKHABGINKB\x12\x20\n\x0bPEIIECHJBOH\
    \x18\x03\x20\x01(\x05R\x0bPEIIECHJBOH\x12\x20\n\x0bLLBPGOIFDAD\x18\x08\
    \x20\x01(\x05R\x0bLLBPGOIFDAD\x12\x20\n\x0bILBOHKPGEBN\x18\x0f\x20\x01(\
    \x05R\x0bILBOHKPGEBN\x12\x20\n\x0bBJLIOIKGPCK\x18\x0e\x20\x01(\x05R\x0bB\
    JLIOIKGPCK\x12\x20\n\x0bBHCEKMIEFKC\x18\x02\x20\x01(\x05R\x0bBHCEKMIEFKC\
    \x12\x20\n\x0bINMOIILMOJN\x18\x05\x20\x01(\x05R\x0bINMOIILMOJN\x12\x20\n\
    \x0bLDMGDOGJKNC\x18\x0b\x20\x01(\x05R\x0bLDMGDOGJKNC\x12\x20\n\x0bNOJFNA\
    KKOJO\x18\n\x20\x01(\x05R\x0bNOJFNAKKOJO\x12\x20\n\x0bDOBMEMOFBDE\x18\
    \x0c\x20\x01(\x05R\x0bDOBMEMOFBDE\x12\x20\n\x0bFHFOFHBEIGI\x18\t\x20\x01\
    (\x05R\x0bFHFOFHBEIGI\x12\x20\n\x0bKABMHIGOCHM\x18\x01\x20\x01(\x05R\x0b\
    KABMHIGOCHM\x12\x20\n\x0bDMOGPPBEFNA\x18\x07\x20\x01(\x05R\x0bDMOGPPBEFN\
    A\x12\x20\n\x0bcombat_rank\x18\xef\x04\x20\x01(\x05R\ncombatRank\x12!\n\
    \x0bIFBIMMDFOED\x18\xed\x08\x20\x01(\x05R\x0bIFBIMMDFOED\x12!\n\x0bKENCP\
    JJECKL\x18\xd7\x02\x20\x01(\x05R\x0bKENCPJJECKL\x12!\n\x0bNHNNHJBBGAB\
    \x18\xeb\x05\x20\x01(\x05R\x0bNHNNHJBBGAB\"/\n\x0bLCEMAIAAPCA\x12\x20\n\
    \x0bIAGJGJKGJBL\x18\x07\x20\x01(\rR\x0bIAGJGJKGJBL\"\x8c\x01\n\x0bEJNNNB\
    LNJIC\x129\n\x0bstatus_type\x18\x0f\x20\x01(\x0e2\x18.SwordTrainingStatu\
    sTypeR\nstatusType\x12\x20\n\x0bILGEENMAONM\x18\x0b\x20\x01(\rR\x0bILGEE\
    NMAONM\x12\x20\n\x0bPJHIPNNJDDP\x18\x01\x20\x01(\rR\x0bPJHIPNNJDDP\"Q\n\
    \x0bHOFBPPLLJGJ\x12\x20\n\x0bPJHIPNNJDDP\x18\x02\x20\x01(\rR\x0bPJHIPNNJ\
    DDP\x12\x20\n\x0bILGEENMAONM\x18\x07\x20\x01(\rR\x0bILGEENMAONM\"Q\n\x0b\
    ANDOCAGGDMH\x12\x20\n\x0bILGEENMAONM\x18\x02\x20\x01(\rR\x0bILGEENMAONM\
    \x12\x20\n\x0bPJHIPNNJDDP\x18\x06\x20\x01(\rR\x0bPJHIPNNJDDP\"b\n\x0bEFL\
    KKNBMPHB\x12\x14\n\x05level\x18\x0f\x20\x01(\rR\x05level\x12\x1b\n\tuniq\
    ue_id\x18\x0b\x20\x01(\rR\x08uniqueId\x12\x20\n\x0bAKDDEGHFEGG\x18\x06\
    \x20\x01(\rR\x0bAKDDEGHFEGG\"i\n\x0bHNHNFFFGFJC\x12\x20\n\x0bMGKDFNBENAI\
    \x18\n\x20\x01(\rR\x0bMGKDFNBENAI\x128\n\x0bPCMAAKHAEBC\x18\r\x20\x01(\
    \x0b2\x16.SwordTrainingTurnInfoR\x0bPCMAAKHAEBC\"Q\n\x0bBECAJOBHPIP\x12\
    \x20\n\x0bLHMPHPEODNP\x18\x0e\x20\x01(\rR\x0bLHMPHPEODNP\x12\x20\n\x0bNB\
    BEBBCAKBE\x18\r\x20\x01(\x08R\x0bNBBEBBCAKBE\"=\n\x0bBFGHEKNAALJ\x12.\n\
    \x0bIPHCFMPAMNF\x18\x05\x20\x03(\x0b2\x0c.BFDCFCKHILPR\x0bIPHCFMPAMNF\"9\
    \n\x0bDNLEFEGOBEG\x12\x1a\n\x08progress\x18\x07\x20\x01(\rR\x08progress\
    \x12\x0e\n\x02id\x18\x0f\x20\x01(\rR\x02id\"_\n\x0bKOBFGKFDMJE\x12\x20\n\
    \x0bFGCDDCJHIAG\x18\x05\x20\x03(\rR\x0bFGCDDCJHIAG\x12.\n\x0bAKPGGHKCAIF\
    \x18\x0b\x20\x03(\x0b2\x0c.DNLEFEGOBEGR\x0bAKPGGHKCAIF\"\x1b\n\x19GetSwo\
    rdTrainingDataCsReq\"\xe8\x02\n\x19GetSwordTrainingDataScRsp\x12\"\n\rst\
    ory_id_list\x18\r\x20\x03(\rR\x0bstoryIdList\x123\n\tgame_info\x18\x0b\
    \x20\x01(\x0b2\x16.SwordTrainingGameInfoR\x08gameInfo\x12\x20\n\x0bAILAG\
    ENLDGI\x18\x08\x20\x01(\rR\x0bAILAGENLDGI\x12\x20\n\x0bDIGIDEKCKPF\x18\
    \x05\x20\x03(\rR\x0bDIGIDEKCKPF\x12\x18\n\x07retcode\x18\x0c\x20\x01(\rR\
    \x07retcode\x12.\n\x0bIMJLPHEJMBB\x18\x07\x20\x01(\x0b2\x0c.KOBFGKFDMJER\
    \x0bIMJLPHEJMBB\x12\x20\n\x0bDPHNBKLJEHM\x18\t\x20\x03(\rR\x0bDPHNBKLJEH\
    M\x12\x20\n\x0bBNNIMFGFOAH\x18\n\x20\x03(\rR\x0bBNNIMFGFOAH\x12\x20\n\
    \x0bGBDANLKCLMG\x18\x02\x20\x03(\rR\x0bGBDANLKCLMG\"Q\n\x0bIOMJGKBIAFK\
    \x12\x20\n\x0bECFPHAADBDI\x18\x03\x20\x03(\rR\x0bECFPHAADBDI\x12\x20\n\
    \x0bAOBGMOJOFLP\x18\t\x20\x03(\rR\x0bAOBGMOJOFLP\"I\n\x0bIGBCHKMINLM\x12\
    \x20\n\x0bAOBGMOJOFLP\x18\t\x20\x03(\rR\x0bAOBGMOJOFLP\x12\x18\n\x07retc\
    ode\x18\x0b\x20\x01(\rR\x07retcode\"/\n\x0bLANKBIELLHP\x12\x20\n\x0bADEN\
    LFJOOPL\x18\r\x20\x01(\rR\x0bADENLFJOOPL\"g\n\x0bEACNAKCAJHP\x12\x18\n\
    \x07retcode\x18\x0c\x20\x01(\rR\x07retcode\x12>\n\x0bDBJOEONEGCE\x18\r\
    \x20\x01(\x0b2\x1c.SwordTrainingPartnerAbilityR\x0bDBJOEONEGCE\"M\n\x0bJ\
    JLLFHOLLGC\x12>\n\x0bMDPMCJGPIIO\x18\x05\x20\x01(\x0e2\x1c.SwordTraining\
    DailyPhaseTypeR\x0bMDPMCJGPIIO\"k\n\x0bELKMCNJBFAD\x12\x18\n\x07retcode\
    \x18\x05\x20\x01(\rR\x07retcode\x12\x20\n\x0bBPMPJHFFELH\x18\x0f\x20\x01\
    (\x08R\x0bBPMPJHFFELH\x12\x20\n\x0bDCECFOKFIHH\x18\x02\x20\x01(\rR\x0bDC\
    ECFOKFIHH\"/\n\x0bPMDKCCPGMDE\x12\x20\n\x0bMFNFDHAGAPH\x18\x05\x20\x01(\
    \rR\x0bMFNFDHAGAPH\"'\n\x0bKEDCGGPPBLB\x12\x18\n\x07retcode\x18\x0c\x20\
    \x01(\rR\x07retcode\"\r\n\x0bFCCLHJINFED\"'\n\x0bENLDPPNFOGP\x12\x18\n\
    \x07retcode\x18\x07\x20\x01(\rR\x07retcode\"\r\n\x0bAGBEKCNNNJH\"Z\n\x0b\
    NFAIOAMFDEM\x12\x18\n\x07retcode\x18\x04\x20\x01(\rR\x07retcode\x121\n\
    \x0bbattle_info\x18\x03\x20\x01(\x0b2\x10.SceneBattleInfoR\nbattleInfo\"\
    /\n\x0bNBNELCONAPD\x12\x20\n\x0bCCLGMCIMGLH\x18\n\x20\x01(\rR\x0bCCLGMCI\
    MGLH\"I\n\x0bNHCJMPNEDDI\x12\x18\n\x07retcode\x18\x06\x20\x01(\rR\x07ret\
    code\x12\x20\n\x0bCCLGMCIMGLH\x18\x05\x20\x01(\rR\x0bCCLGMCIMGLH\"8\n\
    \x1bSwordTrainingStartGameCsReq\x12\x19\n\x08story_id\x18\n\x20\x01(\rR\
    \x07storyId\"l\n\x1bSwordTrainingStartGameScRsp\x123\n\tgame_info\x18\
    \x05\x20\x01(\x0b2\x16.SwordTrainingGameInfoR\x08gameInfo\x12\x18\n\x07r\
    etcode\x18\t\x20\x01(\rR\x07retcode\"/\n\x0bECDJBHNLCMG\x12\x20\n\x0bLHM\
    PHPEODNP\x18\n\x20\x01(\rR\x0bLHMPHPEODNP\"I\n\x0bPEAGMIKINCF\x12\x18\n\
    \x07retcode\x18\t\x20\x01(\rR\x07retcode\x12\x20\n\x0bLHMPHPEODNP\x18\
    \x04\x20\x01(\rR\x0bLHMPHPEODNP\"\r\n\x0bMJLBEIOLCPC\"'\n\x0bPCBOEDPMHOI\
    \x12\x18\n\x07retcode\x18\x03\x20\x01(\rR\x07retcode\"\xa7\x02\n\x0bDLBJ\
    KLCHJHK\x120\n\x06reason\x18\x02\x20\x01(\x0e2\x18.SwordTrainingGameSett\
    leR\x06reason\x12\x20\n\x0bPCMAAKHAEBC\x18\x01\x20\x01(\rR\x0bPCMAAKHAEB\
    C\x12\x19\n\x08story_id\x18\x07\x20\x01(\rR\x07storyId\x12\x20\n\x0bDKFL\
    LECGCCK\x18\x0b\x20\x03(\rR\x0bDKFLLECGCCK\x12\x20\n\x0bCKEDFNKALOI\x18\
    \x0f\x20\x01(\rR\x0bCKEDFNKALOI\x12\x20\n\x0bCIDICFBPHAF\x18\x03\x20\x03\
    (\rR\x0bCIDICFBPHAF\x12\x20\n\x0bOOJPFKLPHFH\x18\x06\x20\x01(\rR\x0bOOJP\
    FKLPHFH\x12!\n\x06reward\x18\x0c\x20\x01(\x0b2\t.ItemListR\x06reward\"_\
    \n\x0bAKMPGPMADKO\x12.\n\x0bAKPGGHKCAIF\x18\x04\x20\x03(\x0b2\x0c.DNLEFE\
    GOBEGR\x0bAKPGGHKCAIF\x12\x20\n\x0bFGCDDCJHIAG\x18\t\x20\x03(\rR\x0bFGCD\
    DCJHIAG\"=\n\"SwordTrainingFinishEndingHintCsReq\x12\x17\n\x07hint_id\
    \x18\x0f\x20\x01(\rR\x06hintId\"\x7f\n\"SwordTrainingFinishEndingHintScR\
    sp\x12\x18\n\x07retcode\x18\x07\x20\x01(\rR\x07retcode\x12&\n\titem_list\
    \x18\x0e\x20\x01(\x0b2\t.ItemListR\x08itemList\x12\x17\n\x07hint_id\x18\
    \x04\x20\x01(\rR\x06hintId\"/\n\x0bDCOLJDKGDBN\x12\x20\n\x0bOKOANEAKGOE\
    \x18\x01\x20\x01(\rR\x0bOKOANEAKGOE\"I\n\x0bNPJPKIGLBJP\x12\x20\n\x0bOKO\
    ANEAKGOE\x18\x04\x20\x01(\rR\x0bOKOANEAKGOE\x12\x18\n\x07retcode\x18\x0c\
    \x20\x01(\rR\x07retcode\"\r\n\x0bKPABJCCEADF\"\\\n\x0bKAONBIOFBBD\x123\n\
    \tgame_info\x18\x0e\x20\x01(\x0b2\x16.SwordTrainingGameInfoR\x08gameInfo\
    \x12\x18\n\x07retcode\x18\x03\x20\x01(\rR\x07retcode\"\r\n\x0bEFCDNJALEO\
    J\"Z\n\x0bCGNHMHLODCO\x121\n\x0bbattle_info\x18\x08\x20\x01(\x0b2\x10.Sc\
    eneBattleInfoR\nbattleInfo\x12\x18\n\x07retcode\x18\x0c\x20\x01(\rR\x07r\
    etcode\"\x89\x01\n\x0bPBLFCMEHPFO\x12\x20\n\x0bLJEPIBBDFNJ\x18\x02\x20\
    \x01(\rR\x0bLJEPIBBDFNJ\x12\x20\n\x0bNAEKJBOEMCA\x18\x06\x20\x01(\rR\x0b\
    NAEKJBOEMCA\x126\n\x0bFEJOAEALKDF\x18\x04\x20\x03(\x0b2\x14.SwordTrainin\
    gStatusR\x0bFEJOAEALKDF\"/\n\x0bHLDHAFGIPOE\x12\x20\n\x0bIFMANDPGKIE\x18\
    \n\x20\x01(\rR\x0bIFMANDPGKIE\"J\n\x0bKLEHMMANNOI\x12\x18\n\x07retcode\
    \x18\t\x20\x01(\rR\x07retcode\x12!\n\x06reward\x18\x04\x20\x01(\x0b2\t.I\
    temListR\x06reward\"(\n\x0bMNABGDHDJAJ\x12\x19\n\x08story_id\x18\n\x20\
    \x01(\rR\x07storyId\"\\\n\x0bPPLNOKJDGPC\x12\x18\n\x07retcode\x18\x0e\
    \x20\x01(\rR\x07retcode\x123\n\tgame_info\x18\x0c\x20\x01(\x0b2\x16.Swor\
    dTrainingGameInfoR\x08gameInfo\"\r\n\x0bNENMDHEHAKM\";\n\x0bAGAIFKGBKCD\
    \x12\x12\n\x04rank\x18\x01\x20\x01(\rR\x04rank\x12\x18\n\x07retcode\x18\
    \x08\x20\x01(\rR\x07retcode\"/\n\x0bLDBDDLPJEEP\x12\x20\n\x0bCCLGMCIMGLH\
    \x18\x01\x20\x01(\rR\x0bCCLGMCIMGLH\"I\n\x0bBNBHKDENLOE\x12\x18\n\x07ret\
    code\x18\t\x20\x01(\rR\x07retcode\x12\x20\n\x0bCCLGMCIMGLH\x18\x06\x20\
    \x01(\rR\x0bCCLGMCIMGLH*\xea\x02\n\x0bIMPNHHHPMBA\x12%\n!SWORD_TRAIN_GAM\
    E_SOURCE_TYPE_NONE\x10\0\x12,\n(SWORD_TRAIN_GAME_SOURCE_TYPE_TURN_SETTLE\
    \x10\x01\x12/\n+SWORD_TRAIN_GAME_SOURCE_TYPE_STATUS_UPGRADE\x10\x02\x12'\
    \n#SWORD_TRAIN_GAME_SOURCE_TYPE_ACTION\x10\x03\x12,\n(SWORD_TRAIN_GAME_S\
    OURCE_TYPE_ACTION_HINT\x10\x04\x12&\n\"SWORD_TRAIN_GAME_SOURCE_TYPE_STOR\
    Y\x10\x05\x12+\n'SWORD_TRAIN_GAME_SOURCE_TYPE_EXAM_BONUS\x10\x06\x12)\n%\
    SWORD_TRAIN_GAME_SOURCE_TYPE_DIALOGUE\x10\x07*\xfa\x01\n\x1bSwordTrainin\
    gDailyPhaseType\x12(\n$SWORD_TRAINING_DAILY_PHASE_TYPE_NONE\x10\0\x12+\n\
    'SWORD_TRAINING_DAILY_PHASE_TYPE_MORNING\x10\x01\x12(\n$SWORD_TRAINING_D\
    AILY_PHASE_TYPE_NOON\x10\x02\x12-\n)SWORD_TRAINING_DAILY_PHASE_TYPE_AFTE\
    RNOON\x10\x03\x12+\n'SWORD_TRAINING_DAILY_PHASE_TYPE_EVENING\x10\x04*\
    \x86\x02\n\x17SwordTrainingStatusType\x12#\n\x1fSWORD_TRAINING_STATUS_TY\
    PE_NONE\x10\0\x12$\n\x20SWORD_TRAINING_STATUS_TYPE_POWER\x10\x01\x12&\n\
    \"SWORD_TRAINING_STATUS_TYPE_AGILITY\x10\x02\x12(\n$SWORD_TRAINING_STATU\
    S_TYPE_TOUGHNESS\x10\x03\x12)\n%SWORD_TRAINING_STATUS_TYPE_PERCEPTION\
    \x10\x04\x12#\n\x1f_SWORD_TRAINING_STATUS_TYPE_MAX\x10\x05*\x8c\x02\n\
    \x17SwordTrainingGameSettle\x12#\n\x1fSWORD_TRAINING_GAME_SETTLE_NONE\
    \x10\0\x12%\n!SWORD_TRAINING_GAME_SETTLE_FINISH\x10\x01\x12&\n\"SWORD_TR\
    AINING_GAME_SETTLE_GIVE_UP\x10\x02\x12,\n(SWORD_TRAINING_GAME_SETTLE_BAT\
    TLE_FAILED\x10\x03\x12$\n\x20SWORD_TRAINING_GAME_SETTLE_FORCE\x10\x04\
    \x12)\n%SWORD_TRAINING_GAME_SETTLE_BY_RESTORE\x10\x05B\x15\n\x13emu.luna\
    rcore.protob\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::SceneBattleInfo::file_descriptor().clone());
            deps.push(super::ItemList::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(82);
            messages.push(SwordTrainingGameInfo::generated_message_descriptor_data());
            messages.push(SwordTrainingGetSkillInfoCsReq::generated_message_descriptor_data());
            messages.push(SwordTrainingGetSkillInfoScRsp::generated_message_descriptor_data());
            messages.push(SwordTrainingEffectInfo::generated_message_descriptor_data());
            messages.push(SwordTrainingSkillInfo::generated_message_descriptor_data());
            messages.push(SwordTrainingPartner::generated_message_descriptor_data());
            messages.push(SwordTrainingPartnerInfo::generated_message_descriptor_data());
            messages.push(SwordTrainingStoryInfo::generated_message_descriptor_data());
            messages.push(SwordTrainingStatus::generated_message_descriptor_data());
            messages.push(SwordTrainingStatusTypeInfo::generated_message_descriptor_data());
            messages.push(SwordTrainingStatusList::generated_message_descriptor_data());
            messages.push(SwordTrainingAction::generated_message_descriptor_data());
            messages.push(SwordTrainingActionInfo::generated_message_descriptor_data());
            messages.push(SwordTrainingTurnInfo::generated_message_descriptor_data());
            messages.push(NEMGFNPGEDK::generated_message_descriptor_data());
            messages.push(SwordTrainingPartnerAbility::generated_message_descriptor_data());
            messages.push(SwordTrainingActionTurnInfo::generated_message_descriptor_data());
            messages.push(SwordTrainingExamTurnInfo::generated_message_descriptor_data());
            messages.push(SwordTrainingPendingAction::generated_message_descriptor_data());
            messages.push(ABHNAFELEME::generated_message_descriptor_data());
            messages.push(PKGODKBNAAM::generated_message_descriptor_data());
            messages.push(NJAHHFGIMBF::generated_message_descriptor_data());
            messages.push(NGFELCGLDGB::generated_message_descriptor_data());
            messages.push(OALMPFHPFPK::generated_message_descriptor_data());
            messages.push(OEJIIDGGGBO::generated_message_descriptor_data());
            messages.push(BOIFCPNAOLC::generated_message_descriptor_data());
            messages.push(LFNDEHMBKNN::generated_message_descriptor_data());
            messages.push(ENGJLGMAOAC::generated_message_descriptor_data());
            messages.push(BFDCFCKHILP::generated_message_descriptor_data());
            messages.push(HNADJAAFBMJ::generated_message_descriptor_data());
            messages.push(KBKHABGINKB::generated_message_descriptor_data());
            messages.push(LCEMAIAAPCA::generated_message_descriptor_data());
            messages.push(EJNNNBLNJIC::generated_message_descriptor_data());
            messages.push(HOFBPPLLJGJ::generated_message_descriptor_data());
            messages.push(ANDOCAGGDMH::generated_message_descriptor_data());
            messages.push(EFLKKNBMPHB::generated_message_descriptor_data());
            messages.push(HNHNFFFGFJC::generated_message_descriptor_data());
            messages.push(BECAJOBHPIP::generated_message_descriptor_data());
            messages.push(BFGHEKNAALJ::generated_message_descriptor_data());
            messages.push(DNLEFEGOBEG::generated_message_descriptor_data());
            messages.push(KOBFGKFDMJE::generated_message_descriptor_data());
            messages.push(GetSwordTrainingDataCsReq::generated_message_descriptor_data());
            messages.push(GetSwordTrainingDataScRsp::generated_message_descriptor_data());
            messages.push(IOMJGKBIAFK::generated_message_descriptor_data());
            messages.push(IGBCHKMINLM::generated_message_descriptor_data());
            messages.push(LANKBIELLHP::generated_message_descriptor_data());
            messages.push(EACNAKCAJHP::generated_message_descriptor_data());
            messages.push(JJLLFHOLLGC::generated_message_descriptor_data());
            messages.push(ELKMCNJBFAD::generated_message_descriptor_data());
            messages.push(PMDKCCPGMDE::generated_message_descriptor_data());
            messages.push(KEDCGGPPBLB::generated_message_descriptor_data());
            messages.push(FCCLHJINFED::generated_message_descriptor_data());
            messages.push(ENLDPPNFOGP::generated_message_descriptor_data());
            messages.push(AGBEKCNNNJH::generated_message_descriptor_data());
            messages.push(NFAIOAMFDEM::generated_message_descriptor_data());
            messages.push(NBNELCONAPD::generated_message_descriptor_data());
            messages.push(NHCJMPNEDDI::generated_message_descriptor_data());
            messages.push(SwordTrainingStartGameCsReq::generated_message_descriptor_data());
            messages.push(SwordTrainingStartGameScRsp::generated_message_descriptor_data());
            messages.push(ECDJBHNLCMG::generated_message_descriptor_data());
            messages.push(PEAGMIKINCF::generated_message_descriptor_data());
            messages.push(MJLBEIOLCPC::generated_message_descriptor_data());
            messages.push(PCBOEDPMHOI::generated_message_descriptor_data());
            messages.push(DLBJKLCHJHK::generated_message_descriptor_data());
            messages.push(AKMPGPMADKO::generated_message_descriptor_data());
            messages.push(SwordTrainingFinishEndingHintCsReq::generated_message_descriptor_data());
            messages.push(SwordTrainingFinishEndingHintScRsp::generated_message_descriptor_data());
            messages.push(DCOLJDKGDBN::generated_message_descriptor_data());
            messages.push(NPJPKIGLBJP::generated_message_descriptor_data());
            messages.push(KPABJCCEADF::generated_message_descriptor_data());
            messages.push(KAONBIOFBBD::generated_message_descriptor_data());
            messages.push(EFCDNJALEOJ::generated_message_descriptor_data());
            messages.push(CGNHMHLODCO::generated_message_descriptor_data());
            messages.push(PBLFCMEHPFO::generated_message_descriptor_data());
            messages.push(HLDHAFGIPOE::generated_message_descriptor_data());
            messages.push(KLEHMMANNOI::generated_message_descriptor_data());
            messages.push(MNABGDHDJAJ::generated_message_descriptor_data());
            messages.push(PPLNOKJDGPC::generated_message_descriptor_data());
            messages.push(NENMDHEHAKM::generated_message_descriptor_data());
            messages.push(AGAIFKGBKCD::generated_message_descriptor_data());
            messages.push(LDBDDLPJEEP::generated_message_descriptor_data());
            messages.push(BNBHKDENLOE::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(IMPNHHHPMBA::generated_enum_descriptor_data());
            enums.push(SwordTrainingDailyPhaseType::generated_enum_descriptor_data());
            enums.push(SwordTrainingStatusType::generated_enum_descriptor_data());
            enums.push(SwordTrainingGameSettle::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
