// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `BEAEPAPGHLP.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:BEAEPAPGHLP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BEAEPAPGHLP {
    // message oneof groups
    pub HCGINDLACPP: ::std::option::Option<beaepapghlp::HCGINDLACPP>,
    // special fields
    // @@protoc_insertion_point(special_field:BEAEPAPGHLP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BEAEPAPGHLP {
    fn default() -> &'a BEAEPAPGHLP {
        <BEAEPAPGHLP as ::protobuf::Message>::default_instance()
    }
}

impl BEAEPAPGHLP {
    pub fn new() -> BEAEPAPGHLP {
        ::std::default::Default::default()
    }

    // .DMOBDOOFMBI HADIGPFDFDD = 8;

    pub fn HADIGPFDFDD(&self) -> &super::DMOBDOOFMBI::DMOBDOOFMBI {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::HADIGPFDFDD(ref v)) => v,
            _ => <super::DMOBDOOFMBI::DMOBDOOFMBI as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_HADIGPFDFDD(&mut self) {
        self.HCGINDLACPP = ::std::option::Option::None;
    }

    pub fn has_HADIGPFDFDD(&self) -> bool {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::HADIGPFDFDD(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_HADIGPFDFDD(&mut self, v: super::DMOBDOOFMBI::DMOBDOOFMBI) {
        self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::HADIGPFDFDD(v))
    }

    // Mutable pointer to the field.
    pub fn mut_HADIGPFDFDD(&mut self) -> &mut super::DMOBDOOFMBI::DMOBDOOFMBI {
        if let ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::HADIGPFDFDD(_)) = self.HCGINDLACPP {
        } else {
            self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::HADIGPFDFDD(super::DMOBDOOFMBI::DMOBDOOFMBI::new()));
        }
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::HADIGPFDFDD(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_HADIGPFDFDD(&mut self) -> super::DMOBDOOFMBI::DMOBDOOFMBI {
        if self.has_HADIGPFDFDD() {
            match self.HCGINDLACPP.take() {
                ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::HADIGPFDFDD(v)) => v,
                _ => panic!(),
            }
        } else {
            super::DMOBDOOFMBI::DMOBDOOFMBI::new()
        }
    }

    // .DMOBDOOFMBI NHOOBFLLAMN = 14;

    pub fn NHOOBFLLAMN(&self) -> &super::DMOBDOOFMBI::DMOBDOOFMBI {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::NHOOBFLLAMN(ref v)) => v,
            _ => <super::DMOBDOOFMBI::DMOBDOOFMBI as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_NHOOBFLLAMN(&mut self) {
        self.HCGINDLACPP = ::std::option::Option::None;
    }

    pub fn has_NHOOBFLLAMN(&self) -> bool {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::NHOOBFLLAMN(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_NHOOBFLLAMN(&mut self, v: super::DMOBDOOFMBI::DMOBDOOFMBI) {
        self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::NHOOBFLLAMN(v))
    }

    // Mutable pointer to the field.
    pub fn mut_NHOOBFLLAMN(&mut self) -> &mut super::DMOBDOOFMBI::DMOBDOOFMBI {
        if let ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::NHOOBFLLAMN(_)) = self.HCGINDLACPP {
        } else {
            self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::NHOOBFLLAMN(super::DMOBDOOFMBI::DMOBDOOFMBI::new()));
        }
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::NHOOBFLLAMN(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_NHOOBFLLAMN(&mut self) -> super::DMOBDOOFMBI::DMOBDOOFMBI {
        if self.has_NHOOBFLLAMN() {
            match self.HCGINDLACPP.take() {
                ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::NHOOBFLLAMN(v)) => v,
                _ => panic!(),
            }
        } else {
            super::DMOBDOOFMBI::DMOBDOOFMBI::new()
        }
    }

    // .GEANJPFCADJ MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE = 1;

    pub fn MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE(&self) -> &super::GEANJPFCADJ::GEANJPFCADJ {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(ref v)) => v,
            _ => <super::GEANJPFCADJ::GEANJPFCADJ as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE(&mut self) {
        self.HCGINDLACPP = ::std::option::Option::None;
    }

    pub fn has_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE(&self) -> bool {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE(&mut self, v: super::GEANJPFCADJ::GEANJPFCADJ) {
        self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(v))
    }

    // Mutable pointer to the field.
    pub fn mut_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE(&mut self) -> &mut super::GEANJPFCADJ::GEANJPFCADJ {
        if let ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(_)) = self.HCGINDLACPP {
        } else {
            self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(super::GEANJPFCADJ::GEANJPFCADJ::new()));
        }
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE(&mut self) -> super::GEANJPFCADJ::GEANJPFCADJ {
        if self.has_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE() {
            match self.HCGINDLACPP.take() {
                ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(v)) => v,
                _ => panic!(),
            }
        } else {
            super::GEANJPFCADJ::GEANJPFCADJ::new()
        }
    }

    // .GEANJPFCADJ COIOJGMCHIN = 6;

    pub fn COIOJGMCHIN(&self) -> &super::GEANJPFCADJ::GEANJPFCADJ {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::COIOJGMCHIN(ref v)) => v,
            _ => <super::GEANJPFCADJ::GEANJPFCADJ as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_COIOJGMCHIN(&mut self) {
        self.HCGINDLACPP = ::std::option::Option::None;
    }

    pub fn has_COIOJGMCHIN(&self) -> bool {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::COIOJGMCHIN(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_COIOJGMCHIN(&mut self, v: super::GEANJPFCADJ::GEANJPFCADJ) {
        self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::COIOJGMCHIN(v))
    }

    // Mutable pointer to the field.
    pub fn mut_COIOJGMCHIN(&mut self) -> &mut super::GEANJPFCADJ::GEANJPFCADJ {
        if let ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::COIOJGMCHIN(_)) = self.HCGINDLACPP {
        } else {
            self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::COIOJGMCHIN(super::GEANJPFCADJ::GEANJPFCADJ::new()));
        }
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::COIOJGMCHIN(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_COIOJGMCHIN(&mut self) -> super::GEANJPFCADJ::GEANJPFCADJ {
        if self.has_COIOJGMCHIN() {
            match self.HCGINDLACPP.take() {
                ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::COIOJGMCHIN(v)) => v,
                _ => panic!(),
            }
        } else {
            super::GEANJPFCADJ::GEANJPFCADJ::new()
        }
    }

    // .HHLDOHHKIHE HMDPKFKMLGJ = 10;

    pub fn HMDPKFKMLGJ(&self) -> &super::HHLDOHHKIHE::HHLDOHHKIHE {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::HMDPKFKMLGJ(ref v)) => v,
            _ => <super::HHLDOHHKIHE::HHLDOHHKIHE as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_HMDPKFKMLGJ(&mut self) {
        self.HCGINDLACPP = ::std::option::Option::None;
    }

    pub fn has_HMDPKFKMLGJ(&self) -> bool {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::HMDPKFKMLGJ(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_HMDPKFKMLGJ(&mut self, v: super::HHLDOHHKIHE::HHLDOHHKIHE) {
        self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::HMDPKFKMLGJ(v))
    }

    // Mutable pointer to the field.
    pub fn mut_HMDPKFKMLGJ(&mut self) -> &mut super::HHLDOHHKIHE::HHLDOHHKIHE {
        if let ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::HMDPKFKMLGJ(_)) = self.HCGINDLACPP {
        } else {
            self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::HMDPKFKMLGJ(super::HHLDOHHKIHE::HHLDOHHKIHE::new()));
        }
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::HMDPKFKMLGJ(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_HMDPKFKMLGJ(&mut self) -> super::HHLDOHHKIHE::HHLDOHHKIHE {
        if self.has_HMDPKFKMLGJ() {
            match self.HCGINDLACPP.take() {
                ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::HMDPKFKMLGJ(v)) => v,
                _ => panic!(),
            }
        } else {
            super::HHLDOHHKIHE::HHLDOHHKIHE::new()
        }
    }

    // .HHLDOHHKIHE JGEDAHNKOGM = 13;

    pub fn JGEDAHNKOGM(&self) -> &super::HHLDOHHKIHE::HHLDOHHKIHE {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::JGEDAHNKOGM(ref v)) => v,
            _ => <super::HHLDOHHKIHE::HHLDOHHKIHE as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_JGEDAHNKOGM(&mut self) {
        self.HCGINDLACPP = ::std::option::Option::None;
    }

    pub fn has_JGEDAHNKOGM(&self) -> bool {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::JGEDAHNKOGM(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_JGEDAHNKOGM(&mut self, v: super::HHLDOHHKIHE::HHLDOHHKIHE) {
        self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::JGEDAHNKOGM(v))
    }

    // Mutable pointer to the field.
    pub fn mut_JGEDAHNKOGM(&mut self) -> &mut super::HHLDOHHKIHE::HHLDOHHKIHE {
        if let ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::JGEDAHNKOGM(_)) = self.HCGINDLACPP {
        } else {
            self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::JGEDAHNKOGM(super::HHLDOHHKIHE::HHLDOHHKIHE::new()));
        }
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::JGEDAHNKOGM(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_JGEDAHNKOGM(&mut self) -> super::HHLDOHHKIHE::HHLDOHHKIHE {
        if self.has_JGEDAHNKOGM() {
            match self.HCGINDLACPP.take() {
                ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::JGEDAHNKOGM(v)) => v,
                _ => panic!(),
            }
        } else {
            super::HHLDOHHKIHE::HHLDOHHKIHE::new()
        }
    }

    // .BCJGDLJBGFB LNJBKCPAMIN = 3;

    pub fn LNJBKCPAMIN(&self) -> &super::BCJGDLJBGFB::BCJGDLJBGFB {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::LNJBKCPAMIN(ref v)) => v,
            _ => <super::BCJGDLJBGFB::BCJGDLJBGFB as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_LNJBKCPAMIN(&mut self) {
        self.HCGINDLACPP = ::std::option::Option::None;
    }

    pub fn has_LNJBKCPAMIN(&self) -> bool {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::LNJBKCPAMIN(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_LNJBKCPAMIN(&mut self, v: super::BCJGDLJBGFB::BCJGDLJBGFB) {
        self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::LNJBKCPAMIN(v))
    }

    // Mutable pointer to the field.
    pub fn mut_LNJBKCPAMIN(&mut self) -> &mut super::BCJGDLJBGFB::BCJGDLJBGFB {
        if let ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::LNJBKCPAMIN(_)) = self.HCGINDLACPP {
        } else {
            self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::LNJBKCPAMIN(super::BCJGDLJBGFB::BCJGDLJBGFB::new()));
        }
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::LNJBKCPAMIN(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_LNJBKCPAMIN(&mut self) -> super::BCJGDLJBGFB::BCJGDLJBGFB {
        if self.has_LNJBKCPAMIN() {
            match self.HCGINDLACPP.take() {
                ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::LNJBKCPAMIN(v)) => v,
                _ => panic!(),
            }
        } else {
            super::BCJGDLJBGFB::BCJGDLJBGFB::new()
        }
    }

    // .BCJGDLJBGFB EIGGABEEAJN = 12;

    pub fn EIGGABEEAJN(&self) -> &super::BCJGDLJBGFB::BCJGDLJBGFB {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::EIGGABEEAJN(ref v)) => v,
            _ => <super::BCJGDLJBGFB::BCJGDLJBGFB as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_EIGGABEEAJN(&mut self) {
        self.HCGINDLACPP = ::std::option::Option::None;
    }

    pub fn has_EIGGABEEAJN(&self) -> bool {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::EIGGABEEAJN(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_EIGGABEEAJN(&mut self, v: super::BCJGDLJBGFB::BCJGDLJBGFB) {
        self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::EIGGABEEAJN(v))
    }

    // Mutable pointer to the field.
    pub fn mut_EIGGABEEAJN(&mut self) -> &mut super::BCJGDLJBGFB::BCJGDLJBGFB {
        if let ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::EIGGABEEAJN(_)) = self.HCGINDLACPP {
        } else {
            self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::EIGGABEEAJN(super::BCJGDLJBGFB::BCJGDLJBGFB::new()));
        }
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::EIGGABEEAJN(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_EIGGABEEAJN(&mut self) -> super::BCJGDLJBGFB::BCJGDLJBGFB {
        if self.has_EIGGABEEAJN() {
            match self.HCGINDLACPP.take() {
                ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::EIGGABEEAJN(v)) => v,
                _ => panic!(),
            }
        } else {
            super::BCJGDLJBGFB::BCJGDLJBGFB::new()
        }
    }

    // .FAMDDGEBEIB MPDJCAPLCLG = 5;

    pub fn MPDJCAPLCLG(&self) -> &super::FAMDDGEBEIB::FAMDDGEBEIB {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::MPDJCAPLCLG(ref v)) => v,
            _ => <super::FAMDDGEBEIB::FAMDDGEBEIB as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_MPDJCAPLCLG(&mut self) {
        self.HCGINDLACPP = ::std::option::Option::None;
    }

    pub fn has_MPDJCAPLCLG(&self) -> bool {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::MPDJCAPLCLG(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_MPDJCAPLCLG(&mut self, v: super::FAMDDGEBEIB::FAMDDGEBEIB) {
        self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::MPDJCAPLCLG(v))
    }

    // Mutable pointer to the field.
    pub fn mut_MPDJCAPLCLG(&mut self) -> &mut super::FAMDDGEBEIB::FAMDDGEBEIB {
        if let ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::MPDJCAPLCLG(_)) = self.HCGINDLACPP {
        } else {
            self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::MPDJCAPLCLG(super::FAMDDGEBEIB::FAMDDGEBEIB::new()));
        }
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::MPDJCAPLCLG(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_MPDJCAPLCLG(&mut self) -> super::FAMDDGEBEIB::FAMDDGEBEIB {
        if self.has_MPDJCAPLCLG() {
            match self.HCGINDLACPP.take() {
                ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::MPDJCAPLCLG(v)) => v,
                _ => panic!(),
            }
        } else {
            super::FAMDDGEBEIB::FAMDDGEBEIB::new()
        }
    }

    // .EPDNAGOCBJN CHHFIEFIOLE = 9;

    pub fn CHHFIEFIOLE(&self) -> &super::EPDNAGOCBJN::EPDNAGOCBJN {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::CHHFIEFIOLE(ref v)) => v,
            _ => <super::EPDNAGOCBJN::EPDNAGOCBJN as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_CHHFIEFIOLE(&mut self) {
        self.HCGINDLACPP = ::std::option::Option::None;
    }

    pub fn has_CHHFIEFIOLE(&self) -> bool {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::CHHFIEFIOLE(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_CHHFIEFIOLE(&mut self, v: super::EPDNAGOCBJN::EPDNAGOCBJN) {
        self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::CHHFIEFIOLE(v))
    }

    // Mutable pointer to the field.
    pub fn mut_CHHFIEFIOLE(&mut self) -> &mut super::EPDNAGOCBJN::EPDNAGOCBJN {
        if let ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::CHHFIEFIOLE(_)) = self.HCGINDLACPP {
        } else {
            self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::CHHFIEFIOLE(super::EPDNAGOCBJN::EPDNAGOCBJN::new()));
        }
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::CHHFIEFIOLE(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_CHHFIEFIOLE(&mut self) -> super::EPDNAGOCBJN::EPDNAGOCBJN {
        if self.has_CHHFIEFIOLE() {
            match self.HCGINDLACPP.take() {
                ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::CHHFIEFIOLE(v)) => v,
                _ => panic!(),
            }
        } else {
            super::EPDNAGOCBJN::EPDNAGOCBJN::new()
        }
    }

    // .HHLDOHHKIHE NKIHGLLANOB = 15;

    pub fn NKIHGLLANOB(&self) -> &super::HHLDOHHKIHE::HHLDOHHKIHE {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::NKIHGLLANOB(ref v)) => v,
            _ => <super::HHLDOHHKIHE::HHLDOHHKIHE as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_NKIHGLLANOB(&mut self) {
        self.HCGINDLACPP = ::std::option::Option::None;
    }

    pub fn has_NKIHGLLANOB(&self) -> bool {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::NKIHGLLANOB(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_NKIHGLLANOB(&mut self, v: super::HHLDOHHKIHE::HHLDOHHKIHE) {
        self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::NKIHGLLANOB(v))
    }

    // Mutable pointer to the field.
    pub fn mut_NKIHGLLANOB(&mut self) -> &mut super::HHLDOHHKIHE::HHLDOHHKIHE {
        if let ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::NKIHGLLANOB(_)) = self.HCGINDLACPP {
        } else {
            self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::NKIHGLLANOB(super::HHLDOHHKIHE::HHLDOHHKIHE::new()));
        }
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::NKIHGLLANOB(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_NKIHGLLANOB(&mut self) -> super::HHLDOHHKIHE::HHLDOHHKIHE {
        if self.has_NKIHGLLANOB() {
            match self.HCGINDLACPP.take() {
                ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::NKIHGLLANOB(v)) => v,
                _ => panic!(),
            }
        } else {
            super::HHLDOHHKIHE::HHLDOHHKIHE::new()
        }
    }

    // .BCJGDLJBGFB DMDILNMGJMG = 11;

    pub fn DMDILNMGJMG(&self) -> &super::BCJGDLJBGFB::BCJGDLJBGFB {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::DMDILNMGJMG(ref v)) => v,
            _ => <super::BCJGDLJBGFB::BCJGDLJBGFB as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_DMDILNMGJMG(&mut self) {
        self.HCGINDLACPP = ::std::option::Option::None;
    }

    pub fn has_DMDILNMGJMG(&self) -> bool {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::DMDILNMGJMG(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_DMDILNMGJMG(&mut self, v: super::BCJGDLJBGFB::BCJGDLJBGFB) {
        self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::DMDILNMGJMG(v))
    }

    // Mutable pointer to the field.
    pub fn mut_DMDILNMGJMG(&mut self) -> &mut super::BCJGDLJBGFB::BCJGDLJBGFB {
        if let ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::DMDILNMGJMG(_)) = self.HCGINDLACPP {
        } else {
            self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::DMDILNMGJMG(super::BCJGDLJBGFB::BCJGDLJBGFB::new()));
        }
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::DMDILNMGJMG(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_DMDILNMGJMG(&mut self) -> super::BCJGDLJBGFB::BCJGDLJBGFB {
        if self.has_DMDILNMGJMG() {
            match self.HCGINDLACPP.take() {
                ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::DMDILNMGJMG(v)) => v,
                _ => panic!(),
            }
        } else {
            super::BCJGDLJBGFB::BCJGDLJBGFB::new()
        }
    }

    // .NGDHPCDEHOM EPCOCHJAGFJ = 4;

    pub fn EPCOCHJAGFJ(&self) -> &super::NGDHPCDEHOM::NGDHPCDEHOM {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::EPCOCHJAGFJ(ref v)) => v,
            _ => <super::NGDHPCDEHOM::NGDHPCDEHOM as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_EPCOCHJAGFJ(&mut self) {
        self.HCGINDLACPP = ::std::option::Option::None;
    }

    pub fn has_EPCOCHJAGFJ(&self) -> bool {
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::EPCOCHJAGFJ(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_EPCOCHJAGFJ(&mut self, v: super::NGDHPCDEHOM::NGDHPCDEHOM) {
        self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::EPCOCHJAGFJ(v))
    }

    // Mutable pointer to the field.
    pub fn mut_EPCOCHJAGFJ(&mut self) -> &mut super::NGDHPCDEHOM::NGDHPCDEHOM {
        if let ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::EPCOCHJAGFJ(_)) = self.HCGINDLACPP {
        } else {
            self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::EPCOCHJAGFJ(super::NGDHPCDEHOM::NGDHPCDEHOM::new()));
        }
        match self.HCGINDLACPP {
            ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::EPCOCHJAGFJ(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_EPCOCHJAGFJ(&mut self) -> super::NGDHPCDEHOM::NGDHPCDEHOM {
        if self.has_EPCOCHJAGFJ() {
            match self.HCGINDLACPP.take() {
                ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::EPCOCHJAGFJ(v)) => v,
                _ => panic!(),
            }
        } else {
            super::NGDHPCDEHOM::NGDHPCDEHOM::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::DMOBDOOFMBI::DMOBDOOFMBI>(
            "HADIGPFDFDD",
            BEAEPAPGHLP::has_HADIGPFDFDD,
            BEAEPAPGHLP::HADIGPFDFDD,
            BEAEPAPGHLP::mut_HADIGPFDFDD,
            BEAEPAPGHLP::set_HADIGPFDFDD,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::DMOBDOOFMBI::DMOBDOOFMBI>(
            "NHOOBFLLAMN",
            BEAEPAPGHLP::has_NHOOBFLLAMN,
            BEAEPAPGHLP::NHOOBFLLAMN,
            BEAEPAPGHLP::mut_NHOOBFLLAMN,
            BEAEPAPGHLP::set_NHOOBFLLAMN,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::GEANJPFCADJ::GEANJPFCADJ>(
            "MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE",
            BEAEPAPGHLP::has_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE,
            BEAEPAPGHLP::MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE,
            BEAEPAPGHLP::mut_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE,
            BEAEPAPGHLP::set_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::GEANJPFCADJ::GEANJPFCADJ>(
            "COIOJGMCHIN",
            BEAEPAPGHLP::has_COIOJGMCHIN,
            BEAEPAPGHLP::COIOJGMCHIN,
            BEAEPAPGHLP::mut_COIOJGMCHIN,
            BEAEPAPGHLP::set_COIOJGMCHIN,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::HHLDOHHKIHE::HHLDOHHKIHE>(
            "HMDPKFKMLGJ",
            BEAEPAPGHLP::has_HMDPKFKMLGJ,
            BEAEPAPGHLP::HMDPKFKMLGJ,
            BEAEPAPGHLP::mut_HMDPKFKMLGJ,
            BEAEPAPGHLP::set_HMDPKFKMLGJ,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::HHLDOHHKIHE::HHLDOHHKIHE>(
            "JGEDAHNKOGM",
            BEAEPAPGHLP::has_JGEDAHNKOGM,
            BEAEPAPGHLP::JGEDAHNKOGM,
            BEAEPAPGHLP::mut_JGEDAHNKOGM,
            BEAEPAPGHLP::set_JGEDAHNKOGM,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::BCJGDLJBGFB::BCJGDLJBGFB>(
            "LNJBKCPAMIN",
            BEAEPAPGHLP::has_LNJBKCPAMIN,
            BEAEPAPGHLP::LNJBKCPAMIN,
            BEAEPAPGHLP::mut_LNJBKCPAMIN,
            BEAEPAPGHLP::set_LNJBKCPAMIN,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::BCJGDLJBGFB::BCJGDLJBGFB>(
            "EIGGABEEAJN",
            BEAEPAPGHLP::has_EIGGABEEAJN,
            BEAEPAPGHLP::EIGGABEEAJN,
            BEAEPAPGHLP::mut_EIGGABEEAJN,
            BEAEPAPGHLP::set_EIGGABEEAJN,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::FAMDDGEBEIB::FAMDDGEBEIB>(
            "MPDJCAPLCLG",
            BEAEPAPGHLP::has_MPDJCAPLCLG,
            BEAEPAPGHLP::MPDJCAPLCLG,
            BEAEPAPGHLP::mut_MPDJCAPLCLG,
            BEAEPAPGHLP::set_MPDJCAPLCLG,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::EPDNAGOCBJN::EPDNAGOCBJN>(
            "CHHFIEFIOLE",
            BEAEPAPGHLP::has_CHHFIEFIOLE,
            BEAEPAPGHLP::CHHFIEFIOLE,
            BEAEPAPGHLP::mut_CHHFIEFIOLE,
            BEAEPAPGHLP::set_CHHFIEFIOLE,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::HHLDOHHKIHE::HHLDOHHKIHE>(
            "NKIHGLLANOB",
            BEAEPAPGHLP::has_NKIHGLLANOB,
            BEAEPAPGHLP::NKIHGLLANOB,
            BEAEPAPGHLP::mut_NKIHGLLANOB,
            BEAEPAPGHLP::set_NKIHGLLANOB,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::BCJGDLJBGFB::BCJGDLJBGFB>(
            "DMDILNMGJMG",
            BEAEPAPGHLP::has_DMDILNMGJMG,
            BEAEPAPGHLP::DMDILNMGJMG,
            BEAEPAPGHLP::mut_DMDILNMGJMG,
            BEAEPAPGHLP::set_DMDILNMGJMG,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::NGDHPCDEHOM::NGDHPCDEHOM>(
            "EPCOCHJAGFJ",
            BEAEPAPGHLP::has_EPCOCHJAGFJ,
            BEAEPAPGHLP::EPCOCHJAGFJ,
            BEAEPAPGHLP::mut_EPCOCHJAGFJ,
            BEAEPAPGHLP::set_EPCOCHJAGFJ,
        ));
        oneofs.push(beaepapghlp::HCGINDLACPP::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BEAEPAPGHLP>(
            "BEAEPAPGHLP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BEAEPAPGHLP {
    const NAME: &'static str = "BEAEPAPGHLP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                66 => {
                    self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::HADIGPFDFDD(is.read_message()?));
                },
                114 => {
                    self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::NHOOBFLLAMN(is.read_message()?));
                },
                10 => {
                    self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(is.read_message()?));
                },
                50 => {
                    self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::COIOJGMCHIN(is.read_message()?));
                },
                82 => {
                    self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::HMDPKFKMLGJ(is.read_message()?));
                },
                106 => {
                    self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::JGEDAHNKOGM(is.read_message()?));
                },
                26 => {
                    self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::LNJBKCPAMIN(is.read_message()?));
                },
                98 => {
                    self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::EIGGABEEAJN(is.read_message()?));
                },
                42 => {
                    self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::MPDJCAPLCLG(is.read_message()?));
                },
                74 => {
                    self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::CHHFIEFIOLE(is.read_message()?));
                },
                122 => {
                    self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::NKIHGLLANOB(is.read_message()?));
                },
                90 => {
                    self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::DMDILNMGJMG(is.read_message()?));
                },
                34 => {
                    self.HCGINDLACPP = ::std::option::Option::Some(beaepapghlp::HCGINDLACPP::EPCOCHJAGFJ(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.HCGINDLACPP {
            match v {
                &beaepapghlp::HCGINDLACPP::HADIGPFDFDD(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &beaepapghlp::HCGINDLACPP::NHOOBFLLAMN(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &beaepapghlp::HCGINDLACPP::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &beaepapghlp::HCGINDLACPP::COIOJGMCHIN(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &beaepapghlp::HCGINDLACPP::HMDPKFKMLGJ(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &beaepapghlp::HCGINDLACPP::JGEDAHNKOGM(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &beaepapghlp::HCGINDLACPP::LNJBKCPAMIN(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &beaepapghlp::HCGINDLACPP::EIGGABEEAJN(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &beaepapghlp::HCGINDLACPP::MPDJCAPLCLG(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &beaepapghlp::HCGINDLACPP::CHHFIEFIOLE(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &beaepapghlp::HCGINDLACPP::NKIHGLLANOB(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &beaepapghlp::HCGINDLACPP::DMDILNMGJMG(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &beaepapghlp::HCGINDLACPP::EPCOCHJAGFJ(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.HCGINDLACPP {
            match v {
                &beaepapghlp::HCGINDLACPP::HADIGPFDFDD(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &beaepapghlp::HCGINDLACPP::NHOOBFLLAMN(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &beaepapghlp::HCGINDLACPP::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &beaepapghlp::HCGINDLACPP::COIOJGMCHIN(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &beaepapghlp::HCGINDLACPP::HMDPKFKMLGJ(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &beaepapghlp::HCGINDLACPP::JGEDAHNKOGM(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &beaepapghlp::HCGINDLACPP::LNJBKCPAMIN(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &beaepapghlp::HCGINDLACPP::EIGGABEEAJN(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &beaepapghlp::HCGINDLACPP::MPDJCAPLCLG(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &beaepapghlp::HCGINDLACPP::CHHFIEFIOLE(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &beaepapghlp::HCGINDLACPP::NKIHGLLANOB(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &beaepapghlp::HCGINDLACPP::DMDILNMGJMG(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &beaepapghlp::HCGINDLACPP::EPCOCHJAGFJ(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BEAEPAPGHLP {
        BEAEPAPGHLP::new()
    }

    fn clear(&mut self) {
        self.HCGINDLACPP = ::std::option::Option::None;
        self.HCGINDLACPP = ::std::option::Option::None;
        self.HCGINDLACPP = ::std::option::Option::None;
        self.HCGINDLACPP = ::std::option::Option::None;
        self.HCGINDLACPP = ::std::option::Option::None;
        self.HCGINDLACPP = ::std::option::Option::None;
        self.HCGINDLACPP = ::std::option::Option::None;
        self.HCGINDLACPP = ::std::option::Option::None;
        self.HCGINDLACPP = ::std::option::Option::None;
        self.HCGINDLACPP = ::std::option::Option::None;
        self.HCGINDLACPP = ::std::option::Option::None;
        self.HCGINDLACPP = ::std::option::Option::None;
        self.HCGINDLACPP = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BEAEPAPGHLP {
        static instance: BEAEPAPGHLP = BEAEPAPGHLP {
            HCGINDLACPP: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BEAEPAPGHLP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BEAEPAPGHLP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BEAEPAPGHLP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BEAEPAPGHLP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BEAEPAPGHLP`
pub mod beaepapghlp {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:BEAEPAPGHLP.HCGINDLACPP)
    pub enum HCGINDLACPP {
        // @@protoc_insertion_point(oneof_field:BEAEPAPGHLP.HADIGPFDFDD)
        HADIGPFDFDD(super::super::DMOBDOOFMBI::DMOBDOOFMBI),
        // @@protoc_insertion_point(oneof_field:BEAEPAPGHLP.NHOOBFLLAMN)
        NHOOBFLLAMN(super::super::DMOBDOOFMBI::DMOBDOOFMBI),
        // @@protoc_insertion_point(oneof_field:BEAEPAPGHLP.MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE)
        MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(super::super::GEANJPFCADJ::GEANJPFCADJ),
        // @@protoc_insertion_point(oneof_field:BEAEPAPGHLP.COIOJGMCHIN)
        COIOJGMCHIN(super::super::GEANJPFCADJ::GEANJPFCADJ),
        // @@protoc_insertion_point(oneof_field:BEAEPAPGHLP.HMDPKFKMLGJ)
        HMDPKFKMLGJ(super::super::HHLDOHHKIHE::HHLDOHHKIHE),
        // @@protoc_insertion_point(oneof_field:BEAEPAPGHLP.JGEDAHNKOGM)
        JGEDAHNKOGM(super::super::HHLDOHHKIHE::HHLDOHHKIHE),
        // @@protoc_insertion_point(oneof_field:BEAEPAPGHLP.LNJBKCPAMIN)
        LNJBKCPAMIN(super::super::BCJGDLJBGFB::BCJGDLJBGFB),
        // @@protoc_insertion_point(oneof_field:BEAEPAPGHLP.EIGGABEEAJN)
        EIGGABEEAJN(super::super::BCJGDLJBGFB::BCJGDLJBGFB),
        // @@protoc_insertion_point(oneof_field:BEAEPAPGHLP.MPDJCAPLCLG)
        MPDJCAPLCLG(super::super::FAMDDGEBEIB::FAMDDGEBEIB),
        // @@protoc_insertion_point(oneof_field:BEAEPAPGHLP.CHHFIEFIOLE)
        CHHFIEFIOLE(super::super::EPDNAGOCBJN::EPDNAGOCBJN),
        // @@protoc_insertion_point(oneof_field:BEAEPAPGHLP.NKIHGLLANOB)
        NKIHGLLANOB(super::super::HHLDOHHKIHE::HHLDOHHKIHE),
        // @@protoc_insertion_point(oneof_field:BEAEPAPGHLP.DMDILNMGJMG)
        DMDILNMGJMG(super::super::BCJGDLJBGFB::BCJGDLJBGFB),
        // @@protoc_insertion_point(oneof_field:BEAEPAPGHLP.EPCOCHJAGFJ)
        EPCOCHJAGFJ(super::super::NGDHPCDEHOM::NGDHPCDEHOM),
    }

    impl ::protobuf::Oneof for HCGINDLACPP {
    }

    impl ::protobuf::OneofFull for HCGINDLACPP {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::BEAEPAPGHLP as ::protobuf::MessageFull>::descriptor().oneof_by_name("HCGINDLACPP").unwrap()).clone()
        }
    }

    impl HCGINDLACPP {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<HCGINDLACPP>("HCGINDLACPP")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11BEAEPAPGHLP.proto\x1a\x11BCJGDLJBGFB.proto\x1a\x11DMOBDOOFMBI.prot\
    o\x1a\x11EPDNAGOCBJN.proto\x1a\x11FAMDDGEBEIB.proto\x1a\x11GEANJPFCADJ.p\
    roto\x1a\x11HHLDOHHKIHE.proto\x1a\x11NGDHPCDEHOM.proto\"\xea\x05\n\x0bBE\
    AEPAPGHLP\x120\n\x0bHADIGPFDFDD\x18\x08\x20\x01(\x0b2\x0c.DMOBDOOFMBIH\0\
    R\x0bHADIGPFDFDD\x120\n\x0bNHOOBFLLAMN\x18\x0e\x20\x01(\x0b2\x0c.DMOBDOO\
    FMBIH\0R\x0bNHOOBFLLAMN\x12t\n0MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_\
    UPGRADE\x18\x01\x20\x01(\x0b2\x0c.GEANJPFCADJH\0R*MONOPOLYACTIONRESULTSO\
    URCETYPEASSETUPGRADE\x120\n\x0bCOIOJGMCHIN\x18\x06\x20\x01(\x0b2\x0c.GEA\
    NJPFCADJH\0R\x0bCOIOJGMCHIN\x120\n\x0bHMDPKFKMLGJ\x18\n\x20\x01(\x0b2\
    \x0c.HHLDOHHKIHEH\0R\x0bHMDPKFKMLGJ\x120\n\x0bJGEDAHNKOGM\x18\r\x20\x01(\
    \x0b2\x0c.HHLDOHHKIHEH\0R\x0bJGEDAHNKOGM\x120\n\x0bLNJBKCPAMIN\x18\x03\
    \x20\x01(\x0b2\x0c.BCJGDLJBGFBH\0R\x0bLNJBKCPAMIN\x120\n\x0bEIGGABEEAJN\
    \x18\x0c\x20\x01(\x0b2\x0c.BCJGDLJBGFBH\0R\x0bEIGGABEEAJN\x120\n\x0bMPDJ\
    CAPLCLG\x18\x05\x20\x01(\x0b2\x0c.FAMDDGEBEIBH\0R\x0bMPDJCAPLCLG\x120\n\
    \x0bCHHFIEFIOLE\x18\t\x20\x01(\x0b2\x0c.EPDNAGOCBJNH\0R\x0bCHHFIEFIOLE\
    \x120\n\x0bNKIHGLLANOB\x18\x0f\x20\x01(\x0b2\x0c.HHLDOHHKIHEH\0R\x0bNKIH\
    GLLANOB\x120\n\x0bDMDILNMGJMG\x18\x0b\x20\x01(\x0b2\x0c.BCJGDLJBGFBH\0R\
    \x0bDMDILNMGJMG\x120\n\x0bEPCOCHJAGFJ\x18\x04\x20\x01(\x0b2\x0c.NGDHPCDE\
    HOMH\0R\x0bEPCOCHJAGFJB\r\n\x0bHCGINDLACPPb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(7);
            deps.push(super::BCJGDLJBGFB::file_descriptor().clone());
            deps.push(super::DMOBDOOFMBI::file_descriptor().clone());
            deps.push(super::EPDNAGOCBJN::file_descriptor().clone());
            deps.push(super::FAMDDGEBEIB::file_descriptor().clone());
            deps.push(super::GEANJPFCADJ::file_descriptor().clone());
            deps.push(super::HHLDOHHKIHE::file_descriptor().clone());
            deps.push(super::NGDHPCDEHOM::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(1);
            messages.push(BEAEPAPGHLP::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
