// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `ADNEJCJKBNF_OIDIHJNBMCK.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:OIDIHJNBMCK)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OIDIHJNBMCK {
    // message fields
    // @@protoc_insertion_point(field:OIDIHJNBMCK.KPNIGOCFNKJ)
    pub KPNIGOCFNKJ: u32,
    // @@protoc_insertion_point(field:OIDIHJNBMCK.OOEDLBAAKPO)
    pub OOEDLBAAKPO: ::std::vec::Vec<ADNEJCJKBNF>,
    // special fields
    // @@protoc_insertion_point(special_field:OIDIHJNBMCK.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OIDIHJNBMCK {
    fn default() -> &'a OIDIHJNBMCK {
        <OIDIHJNBMCK as ::protobuf::Message>::default_instance()
    }
}

impl OIDIHJNBMCK {
    pub fn new() -> OIDIHJNBMCK {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "KPNIGOCFNKJ",
            |m: &OIDIHJNBMCK| { &m.KPNIGOCFNKJ },
            |m: &mut OIDIHJNBMCK| { &mut m.KPNIGOCFNKJ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "OOEDLBAAKPO",
            |m: &OIDIHJNBMCK| { &m.OOEDLBAAKPO },
            |m: &mut OIDIHJNBMCK| { &mut m.OOEDLBAAKPO },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OIDIHJNBMCK>(
            "OIDIHJNBMCK",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OIDIHJNBMCK {
    const NAME: &'static str = "OIDIHJNBMCK";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.KPNIGOCFNKJ = is.read_uint32()?;
                },
                106 => {
                    self.OOEDLBAAKPO.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.KPNIGOCFNKJ != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.KPNIGOCFNKJ);
        }
        for value in &self.OOEDLBAAKPO {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.KPNIGOCFNKJ != 0 {
            os.write_uint32(2, self.KPNIGOCFNKJ)?;
        }
        for v in &self.OOEDLBAAKPO {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OIDIHJNBMCK {
        OIDIHJNBMCK::new()
    }

    fn clear(&mut self) {
        self.KPNIGOCFNKJ = 0;
        self.OOEDLBAAKPO.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OIDIHJNBMCK {
        static instance: OIDIHJNBMCK = OIDIHJNBMCK {
            KPNIGOCFNKJ: 0,
            OOEDLBAAKPO: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OIDIHJNBMCK {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OIDIHJNBMCK").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OIDIHJNBMCK {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OIDIHJNBMCK {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ADNEJCJKBNF)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ADNEJCJKBNF {
    // message fields
    // @@protoc_insertion_point(field:ADNEJCJKBNF.CFNNMEMPIKE)
    pub CFNNMEMPIKE: u32,
    // message oneof groups
    pub EMKBLDJJLKK: ::std::option::Option<adnejcjkbnf::EMKBLDJJLKK>,
    // special fields
    // @@protoc_insertion_point(special_field:ADNEJCJKBNF.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ADNEJCJKBNF {
    fn default() -> &'a ADNEJCJKBNF {
        <ADNEJCJKBNF as ::protobuf::Message>::default_instance()
    }
}

impl ADNEJCJKBNF {
    pub fn new() -> ADNEJCJKBNF {
        ::std::default::Default::default()
    }

    // .PLJNHEIJAMO NMBJMLJCPIA = 3;

    pub fn NMBJMLJCPIA(&self) -> &super::PLJNHEIJAMO::PLJNHEIJAMO {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NMBJMLJCPIA(ref v)) => v,
            _ => <super::PLJNHEIJAMO::PLJNHEIJAMO as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_NMBJMLJCPIA(&mut self) {
        self.EMKBLDJJLKK = ::std::option::Option::None;
    }

    pub fn has_NMBJMLJCPIA(&self) -> bool {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NMBJMLJCPIA(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_NMBJMLJCPIA(&mut self, v: super::PLJNHEIJAMO::PLJNHEIJAMO) {
        self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NMBJMLJCPIA(v))
    }

    // Mutable pointer to the field.
    pub fn mut_NMBJMLJCPIA(&mut self) -> &mut super::PLJNHEIJAMO::PLJNHEIJAMO {
        if let ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NMBJMLJCPIA(_)) = self.EMKBLDJJLKK {
        } else {
            self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NMBJMLJCPIA(super::PLJNHEIJAMO::PLJNHEIJAMO::new()));
        }
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NMBJMLJCPIA(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_NMBJMLJCPIA(&mut self) -> super::PLJNHEIJAMO::PLJNHEIJAMO {
        if self.has_NMBJMLJCPIA() {
            match self.EMKBLDJJLKK.take() {
                ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NMBJMLJCPIA(v)) => v,
                _ => panic!(),
            }
        } else {
            super::PLJNHEIJAMO::PLJNHEIJAMO::new()
        }
    }

    // .DEBGLDCAGPF NICHFNCLGJP = 15;

    pub fn NICHFNCLGJP(&self) -> &super::DEBGLDCAGPF::DEBGLDCAGPF {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NICHFNCLGJP(ref v)) => v,
            _ => <super::DEBGLDCAGPF::DEBGLDCAGPF as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_NICHFNCLGJP(&mut self) {
        self.EMKBLDJJLKK = ::std::option::Option::None;
    }

    pub fn has_NICHFNCLGJP(&self) -> bool {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NICHFNCLGJP(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_NICHFNCLGJP(&mut self, v: super::DEBGLDCAGPF::DEBGLDCAGPF) {
        self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NICHFNCLGJP(v))
    }

    // Mutable pointer to the field.
    pub fn mut_NICHFNCLGJP(&mut self) -> &mut super::DEBGLDCAGPF::DEBGLDCAGPF {
        if let ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NICHFNCLGJP(_)) = self.EMKBLDJJLKK {
        } else {
            self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NICHFNCLGJP(super::DEBGLDCAGPF::DEBGLDCAGPF::new()));
        }
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NICHFNCLGJP(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_NICHFNCLGJP(&mut self) -> super::DEBGLDCAGPF::DEBGLDCAGPF {
        if self.has_NICHFNCLGJP() {
            match self.EMKBLDJJLKK.take() {
                ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NICHFNCLGJP(v)) => v,
                _ => panic!(),
            }
        } else {
            super::DEBGLDCAGPF::DEBGLDCAGPF::new()
        }
    }

    // .KHCOKINAOFI JMJHMMJIFKP = 2;

    pub fn JMJHMMJIFKP(&self) -> &super::KHCOKINAOFI::KHCOKINAOFI {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::JMJHMMJIFKP(ref v)) => v,
            _ => <super::KHCOKINAOFI::KHCOKINAOFI as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_JMJHMMJIFKP(&mut self) {
        self.EMKBLDJJLKK = ::std::option::Option::None;
    }

    pub fn has_JMJHMMJIFKP(&self) -> bool {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::JMJHMMJIFKP(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_JMJHMMJIFKP(&mut self, v: super::KHCOKINAOFI::KHCOKINAOFI) {
        self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::JMJHMMJIFKP(v))
    }

    // Mutable pointer to the field.
    pub fn mut_JMJHMMJIFKP(&mut self) -> &mut super::KHCOKINAOFI::KHCOKINAOFI {
        if let ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::JMJHMMJIFKP(_)) = self.EMKBLDJJLKK {
        } else {
            self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::JMJHMMJIFKP(super::KHCOKINAOFI::KHCOKINAOFI::new()));
        }
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::JMJHMMJIFKP(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_JMJHMMJIFKP(&mut self) -> super::KHCOKINAOFI::KHCOKINAOFI {
        if self.has_JMJHMMJIFKP() {
            match self.EMKBLDJJLKK.take() {
                ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::JMJHMMJIFKP(v)) => v,
                _ => panic!(),
            }
        } else {
            super::KHCOKINAOFI::KHCOKINAOFI::new()
        }
    }

    // .OGMAENLBCDC LFAKCJHMBAM = 5;

    pub fn LFAKCJHMBAM(&self) -> &super::OGMAENLBCDC::OGMAENLBCDC {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::LFAKCJHMBAM(ref v)) => v,
            _ => <super::OGMAENLBCDC::OGMAENLBCDC as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_LFAKCJHMBAM(&mut self) {
        self.EMKBLDJJLKK = ::std::option::Option::None;
    }

    pub fn has_LFAKCJHMBAM(&self) -> bool {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::LFAKCJHMBAM(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_LFAKCJHMBAM(&mut self, v: super::OGMAENLBCDC::OGMAENLBCDC) {
        self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::LFAKCJHMBAM(v))
    }

    // Mutable pointer to the field.
    pub fn mut_LFAKCJHMBAM(&mut self) -> &mut super::OGMAENLBCDC::OGMAENLBCDC {
        if let ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::LFAKCJHMBAM(_)) = self.EMKBLDJJLKK {
        } else {
            self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::LFAKCJHMBAM(super::OGMAENLBCDC::OGMAENLBCDC::new()));
        }
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::LFAKCJHMBAM(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_LFAKCJHMBAM(&mut self) -> super::OGMAENLBCDC::OGMAENLBCDC {
        if self.has_LFAKCJHMBAM() {
            match self.EMKBLDJJLKK.take() {
                ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::LFAKCJHMBAM(v)) => v,
                _ => panic!(),
            }
        } else {
            super::OGMAENLBCDC::OGMAENLBCDC::new()
        }
    }

    // .FEOJMHIFPCH HKJNIIEKEDC = 1;

    pub fn HKJNIIEKEDC(&self) -> &super::FEOJMHIFPCH::FEOJMHIFPCH {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::HKJNIIEKEDC(ref v)) => v,
            _ => <super::FEOJMHIFPCH::FEOJMHIFPCH as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_HKJNIIEKEDC(&mut self) {
        self.EMKBLDJJLKK = ::std::option::Option::None;
    }

    pub fn has_HKJNIIEKEDC(&self) -> bool {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::HKJNIIEKEDC(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_HKJNIIEKEDC(&mut self, v: super::FEOJMHIFPCH::FEOJMHIFPCH) {
        self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::HKJNIIEKEDC(v))
    }

    // Mutable pointer to the field.
    pub fn mut_HKJNIIEKEDC(&mut self) -> &mut super::FEOJMHIFPCH::FEOJMHIFPCH {
        if let ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::HKJNIIEKEDC(_)) = self.EMKBLDJJLKK {
        } else {
            self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::HKJNIIEKEDC(super::FEOJMHIFPCH::FEOJMHIFPCH::new()));
        }
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::HKJNIIEKEDC(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_HKJNIIEKEDC(&mut self) -> super::FEOJMHIFPCH::FEOJMHIFPCH {
        if self.has_HKJNIIEKEDC() {
            match self.EMKBLDJJLKK.take() {
                ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::HKJNIIEKEDC(v)) => v,
                _ => panic!(),
            }
        } else {
            super::FEOJMHIFPCH::FEOJMHIFPCH::new()
        }
    }

    // .NEJFJFCOOKA IDJGHDKAOOD = 13;

    pub fn IDJGHDKAOOD(&self) -> &super::NEJFJFCOOKA::NEJFJFCOOKA {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::IDJGHDKAOOD(ref v)) => v,
            _ => <super::NEJFJFCOOKA::NEJFJFCOOKA as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_IDJGHDKAOOD(&mut self) {
        self.EMKBLDJJLKK = ::std::option::Option::None;
    }

    pub fn has_IDJGHDKAOOD(&self) -> bool {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::IDJGHDKAOOD(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_IDJGHDKAOOD(&mut self, v: super::NEJFJFCOOKA::NEJFJFCOOKA) {
        self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::IDJGHDKAOOD(v))
    }

    // Mutable pointer to the field.
    pub fn mut_IDJGHDKAOOD(&mut self) -> &mut super::NEJFJFCOOKA::NEJFJFCOOKA {
        if let ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::IDJGHDKAOOD(_)) = self.EMKBLDJJLKK {
        } else {
            self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::IDJGHDKAOOD(super::NEJFJFCOOKA::NEJFJFCOOKA::new()));
        }
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::IDJGHDKAOOD(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_IDJGHDKAOOD(&mut self) -> super::NEJFJFCOOKA::NEJFJFCOOKA {
        if self.has_IDJGHDKAOOD() {
            match self.EMKBLDJJLKK.take() {
                ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::IDJGHDKAOOD(v)) => v,
                _ => panic!(),
            }
        } else {
            super::NEJFJFCOOKA::NEJFJFCOOKA::new()
        }
    }

    // .BGBJAPLADOJ PUNK_LORD_SHARE_TYPE_FRIEND = 6;

    pub fn PUNK_LORD_SHARE_TYPE_FRIEND(&self) -> &super::BGBJAPLADOJ::BGBJAPLADOJ {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::PUNKLORDSHARETYPEFRIEND(ref v)) => v,
            _ => <super::BGBJAPLADOJ::BGBJAPLADOJ as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_PUNK_LORD_SHARE_TYPE_FRIEND(&mut self) {
        self.EMKBLDJJLKK = ::std::option::Option::None;
    }

    pub fn has_PUNK_LORD_SHARE_TYPE_FRIEND(&self) -> bool {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::PUNKLORDSHARETYPEFRIEND(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_PUNK_LORD_SHARE_TYPE_FRIEND(&mut self, v: super::BGBJAPLADOJ::BGBJAPLADOJ) {
        self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::PUNKLORDSHARETYPEFRIEND(v))
    }

    // Mutable pointer to the field.
    pub fn mut_PUNK_LORD_SHARE_TYPE_FRIEND(&mut self) -> &mut super::BGBJAPLADOJ::BGBJAPLADOJ {
        if let ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::PUNKLORDSHARETYPEFRIEND(_)) = self.EMKBLDJJLKK {
        } else {
            self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::PUNKLORDSHARETYPEFRIEND(super::BGBJAPLADOJ::BGBJAPLADOJ::new()));
        }
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::PUNKLORDSHARETYPEFRIEND(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_PUNK_LORD_SHARE_TYPE_FRIEND(&mut self) -> super::BGBJAPLADOJ::BGBJAPLADOJ {
        if self.has_PUNK_LORD_SHARE_TYPE_FRIEND() {
            match self.EMKBLDJJLKK.take() {
                ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::PUNKLORDSHARETYPEFRIEND(v)) => v,
                _ => panic!(),
            }
        } else {
            super::BGBJAPLADOJ::BGBJAPLADOJ::new()
        }
    }

    // .JMCHKIMAKHM GMLKLJENNEK = 4;

    pub fn GMLKLJENNEK(&self) -> &super::JMCHKIMAKHM::JMCHKIMAKHM {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::GMLKLJENNEK(ref v)) => v,
            _ => <super::JMCHKIMAKHM::JMCHKIMAKHM as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_GMLKLJENNEK(&mut self) {
        self.EMKBLDJJLKK = ::std::option::Option::None;
    }

    pub fn has_GMLKLJENNEK(&self) -> bool {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::GMLKLJENNEK(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_GMLKLJENNEK(&mut self, v: super::JMCHKIMAKHM::JMCHKIMAKHM) {
        self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::GMLKLJENNEK(v))
    }

    // Mutable pointer to the field.
    pub fn mut_GMLKLJENNEK(&mut self) -> &mut super::JMCHKIMAKHM::JMCHKIMAKHM {
        if let ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::GMLKLJENNEK(_)) = self.EMKBLDJJLKK {
        } else {
            self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::GMLKLJENNEK(super::JMCHKIMAKHM::JMCHKIMAKHM::new()));
        }
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::GMLKLJENNEK(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_GMLKLJENNEK(&mut self) -> super::JMCHKIMAKHM::JMCHKIMAKHM {
        if self.has_GMLKLJENNEK() {
            match self.EMKBLDJJLKK.take() {
                ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::GMLKLJENNEK(v)) => v,
                _ => panic!(),
            }
        } else {
            super::JMCHKIMAKHM::JMCHKIMAKHM::new()
        }
    }

    // .OIDIHJNBMCK NFCHNCHHKEA = 12;

    pub fn NFCHNCHHKEA(&self) -> &OIDIHJNBMCK {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NFCHNCHHKEA(ref v)) => v,
            _ => <OIDIHJNBMCK as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_NFCHNCHHKEA(&mut self) {
        self.EMKBLDJJLKK = ::std::option::Option::None;
    }

    pub fn has_NFCHNCHHKEA(&self) -> bool {
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NFCHNCHHKEA(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_NFCHNCHHKEA(&mut self, v: OIDIHJNBMCK) {
        self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NFCHNCHHKEA(v))
    }

    // Mutable pointer to the field.
    pub fn mut_NFCHNCHHKEA(&mut self) -> &mut OIDIHJNBMCK {
        if let ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NFCHNCHHKEA(_)) = self.EMKBLDJJLKK {
        } else {
            self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NFCHNCHHKEA(OIDIHJNBMCK::new()));
        }
        match self.EMKBLDJJLKK {
            ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NFCHNCHHKEA(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_NFCHNCHHKEA(&mut self) -> OIDIHJNBMCK {
        if self.has_NFCHNCHHKEA() {
            match self.EMKBLDJJLKK.take() {
                ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NFCHNCHHKEA(v)) => v,
                _ => panic!(),
            }
        } else {
            OIDIHJNBMCK::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CFNNMEMPIKE",
            |m: &ADNEJCJKBNF| { &m.CFNNMEMPIKE },
            |m: &mut ADNEJCJKBNF| { &mut m.CFNNMEMPIKE },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::PLJNHEIJAMO::PLJNHEIJAMO>(
            "NMBJMLJCPIA",
            ADNEJCJKBNF::has_NMBJMLJCPIA,
            ADNEJCJKBNF::NMBJMLJCPIA,
            ADNEJCJKBNF::mut_NMBJMLJCPIA,
            ADNEJCJKBNF::set_NMBJMLJCPIA,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::DEBGLDCAGPF::DEBGLDCAGPF>(
            "NICHFNCLGJP",
            ADNEJCJKBNF::has_NICHFNCLGJP,
            ADNEJCJKBNF::NICHFNCLGJP,
            ADNEJCJKBNF::mut_NICHFNCLGJP,
            ADNEJCJKBNF::set_NICHFNCLGJP,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::KHCOKINAOFI::KHCOKINAOFI>(
            "JMJHMMJIFKP",
            ADNEJCJKBNF::has_JMJHMMJIFKP,
            ADNEJCJKBNF::JMJHMMJIFKP,
            ADNEJCJKBNF::mut_JMJHMMJIFKP,
            ADNEJCJKBNF::set_JMJHMMJIFKP,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::OGMAENLBCDC::OGMAENLBCDC>(
            "LFAKCJHMBAM",
            ADNEJCJKBNF::has_LFAKCJHMBAM,
            ADNEJCJKBNF::LFAKCJHMBAM,
            ADNEJCJKBNF::mut_LFAKCJHMBAM,
            ADNEJCJKBNF::set_LFAKCJHMBAM,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::FEOJMHIFPCH::FEOJMHIFPCH>(
            "HKJNIIEKEDC",
            ADNEJCJKBNF::has_HKJNIIEKEDC,
            ADNEJCJKBNF::HKJNIIEKEDC,
            ADNEJCJKBNF::mut_HKJNIIEKEDC,
            ADNEJCJKBNF::set_HKJNIIEKEDC,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::NEJFJFCOOKA::NEJFJFCOOKA>(
            "IDJGHDKAOOD",
            ADNEJCJKBNF::has_IDJGHDKAOOD,
            ADNEJCJKBNF::IDJGHDKAOOD,
            ADNEJCJKBNF::mut_IDJGHDKAOOD,
            ADNEJCJKBNF::set_IDJGHDKAOOD,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::BGBJAPLADOJ::BGBJAPLADOJ>(
            "PUNK_LORD_SHARE_TYPE_FRIEND",
            ADNEJCJKBNF::has_PUNK_LORD_SHARE_TYPE_FRIEND,
            ADNEJCJKBNF::PUNK_LORD_SHARE_TYPE_FRIEND,
            ADNEJCJKBNF::mut_PUNK_LORD_SHARE_TYPE_FRIEND,
            ADNEJCJKBNF::set_PUNK_LORD_SHARE_TYPE_FRIEND,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::JMCHKIMAKHM::JMCHKIMAKHM>(
            "GMLKLJENNEK",
            ADNEJCJKBNF::has_GMLKLJENNEK,
            ADNEJCJKBNF::GMLKLJENNEK,
            ADNEJCJKBNF::mut_GMLKLJENNEK,
            ADNEJCJKBNF::set_GMLKLJENNEK,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OIDIHJNBMCK>(
            "NFCHNCHHKEA",
            ADNEJCJKBNF::has_NFCHNCHHKEA,
            ADNEJCJKBNF::NFCHNCHHKEA,
            ADNEJCJKBNF::mut_NFCHNCHHKEA,
            ADNEJCJKBNF::set_NFCHNCHHKEA,
        ));
        oneofs.push(adnejcjkbnf::EMKBLDJJLKK::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ADNEJCJKBNF>(
            "ADNEJCJKBNF",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ADNEJCJKBNF {
    const NAME: &'static str = "ADNEJCJKBNF";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                56 => {
                    self.CFNNMEMPIKE = is.read_uint32()?;
                },
                26 => {
                    self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NMBJMLJCPIA(is.read_message()?));
                },
                122 => {
                    self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NICHFNCLGJP(is.read_message()?));
                },
                18 => {
                    self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::JMJHMMJIFKP(is.read_message()?));
                },
                42 => {
                    self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::LFAKCJHMBAM(is.read_message()?));
                },
                10 => {
                    self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::HKJNIIEKEDC(is.read_message()?));
                },
                106 => {
                    self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::IDJGHDKAOOD(is.read_message()?));
                },
                50 => {
                    self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::PUNKLORDSHARETYPEFRIEND(is.read_message()?));
                },
                34 => {
                    self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::GMLKLJENNEK(is.read_message()?));
                },
                98 => {
                    self.EMKBLDJJLKK = ::std::option::Option::Some(adnejcjkbnf::EMKBLDJJLKK::NFCHNCHHKEA(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.CFNNMEMPIKE != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.CFNNMEMPIKE);
        }
        if let ::std::option::Option::Some(ref v) = self.EMKBLDJJLKK {
            match v {
                &adnejcjkbnf::EMKBLDJJLKK::NMBJMLJCPIA(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &adnejcjkbnf::EMKBLDJJLKK::NICHFNCLGJP(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &adnejcjkbnf::EMKBLDJJLKK::JMJHMMJIFKP(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &adnejcjkbnf::EMKBLDJJLKK::LFAKCJHMBAM(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &adnejcjkbnf::EMKBLDJJLKK::HKJNIIEKEDC(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &adnejcjkbnf::EMKBLDJJLKK::IDJGHDKAOOD(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &adnejcjkbnf::EMKBLDJJLKK::PUNKLORDSHARETYPEFRIEND(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &adnejcjkbnf::EMKBLDJJLKK::GMLKLJENNEK(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &adnejcjkbnf::EMKBLDJJLKK::NFCHNCHHKEA(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.CFNNMEMPIKE != 0 {
            os.write_uint32(7, self.CFNNMEMPIKE)?;
        }
        if let ::std::option::Option::Some(ref v) = self.EMKBLDJJLKK {
            match v {
                &adnejcjkbnf::EMKBLDJJLKK::NMBJMLJCPIA(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &adnejcjkbnf::EMKBLDJJLKK::NICHFNCLGJP(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &adnejcjkbnf::EMKBLDJJLKK::JMJHMMJIFKP(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &adnejcjkbnf::EMKBLDJJLKK::LFAKCJHMBAM(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &adnejcjkbnf::EMKBLDJJLKK::HKJNIIEKEDC(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &adnejcjkbnf::EMKBLDJJLKK::IDJGHDKAOOD(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &adnejcjkbnf::EMKBLDJJLKK::PUNKLORDSHARETYPEFRIEND(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &adnejcjkbnf::EMKBLDJJLKK::GMLKLJENNEK(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &adnejcjkbnf::EMKBLDJJLKK::NFCHNCHHKEA(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ADNEJCJKBNF {
        ADNEJCJKBNF::new()
    }

    fn clear(&mut self) {
        self.CFNNMEMPIKE = 0;
        self.EMKBLDJJLKK = ::std::option::Option::None;
        self.EMKBLDJJLKK = ::std::option::Option::None;
        self.EMKBLDJJLKK = ::std::option::Option::None;
        self.EMKBLDJJLKK = ::std::option::Option::None;
        self.EMKBLDJJLKK = ::std::option::Option::None;
        self.EMKBLDJJLKK = ::std::option::Option::None;
        self.EMKBLDJJLKK = ::std::option::Option::None;
        self.EMKBLDJJLKK = ::std::option::Option::None;
        self.EMKBLDJJLKK = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ADNEJCJKBNF {
        static instance: ADNEJCJKBNF = ADNEJCJKBNF {
            CFNNMEMPIKE: 0,
            EMKBLDJJLKK: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ADNEJCJKBNF {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ADNEJCJKBNF").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ADNEJCJKBNF {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ADNEJCJKBNF {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ADNEJCJKBNF`
pub mod adnejcjkbnf {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:ADNEJCJKBNF.EMKBLDJJLKK)
    pub enum EMKBLDJJLKK {
        // @@protoc_insertion_point(oneof_field:ADNEJCJKBNF.NMBJMLJCPIA)
        NMBJMLJCPIA(super::super::PLJNHEIJAMO::PLJNHEIJAMO),
        // @@protoc_insertion_point(oneof_field:ADNEJCJKBNF.NICHFNCLGJP)
        NICHFNCLGJP(super::super::DEBGLDCAGPF::DEBGLDCAGPF),
        // @@protoc_insertion_point(oneof_field:ADNEJCJKBNF.JMJHMMJIFKP)
        JMJHMMJIFKP(super::super::KHCOKINAOFI::KHCOKINAOFI),
        // @@protoc_insertion_point(oneof_field:ADNEJCJKBNF.LFAKCJHMBAM)
        LFAKCJHMBAM(super::super::OGMAENLBCDC::OGMAENLBCDC),
        // @@protoc_insertion_point(oneof_field:ADNEJCJKBNF.HKJNIIEKEDC)
        HKJNIIEKEDC(super::super::FEOJMHIFPCH::FEOJMHIFPCH),
        // @@protoc_insertion_point(oneof_field:ADNEJCJKBNF.IDJGHDKAOOD)
        IDJGHDKAOOD(super::super::NEJFJFCOOKA::NEJFJFCOOKA),
        // @@protoc_insertion_point(oneof_field:ADNEJCJKBNF.PUNK_LORD_SHARE_TYPE_FRIEND)
        PUNKLORDSHARETYPEFRIEND(super::super::BGBJAPLADOJ::BGBJAPLADOJ),
        // @@protoc_insertion_point(oneof_field:ADNEJCJKBNF.GMLKLJENNEK)
        GMLKLJENNEK(super::super::JMCHKIMAKHM::JMCHKIMAKHM),
        // @@protoc_insertion_point(oneof_field:ADNEJCJKBNF.NFCHNCHHKEA)
        NFCHNCHHKEA(super::OIDIHJNBMCK),
    }

    impl ::protobuf::Oneof for EMKBLDJJLKK {
    }

    impl ::protobuf::OneofFull for EMKBLDJJLKK {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ADNEJCJKBNF as ::protobuf::MessageFull>::descriptor().oneof_by_name("EMKBLDJJLKK").unwrap()).clone()
        }
    }

    impl EMKBLDJJLKK {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<EMKBLDJJLKK>("EMKBLDJJLKK")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1dADNEJCJKBNF_OIDIHJNBMCK.proto\x1a\x11BGBJAPLADOJ.proto\x1a\x11DEBG\
    LDCAGPF.proto\x1a\x11FEOJMHIFPCH.proto\x1a\x11JMCHKIMAKHM.proto\x1a\x11K\
    HCOKINAOFI.proto\x1a\x11NEJFJFCOOKA.proto\x1a\x11OGMAENLBCDC.proto\x1a\
    \x11PLJNHEIJAMO.proto\"_\n\x0bOIDIHJNBMCK\x12\x20\n\x0bKPNIGOCFNKJ\x18\
    \x02\x20\x01(\rR\x0bKPNIGOCFNKJ\x12.\n\x0bOOEDLBAAKPO\x18\r\x20\x03(\x0b\
    2\x0c.ADNEJCJKBNFR\x0bOOEDLBAAKPO\"\x9c\x04\n\x0bADNEJCJKBNF\x12\x20\n\
    \x0bCFNNMEMPIKE\x18\x07\x20\x01(\rR\x0bCFNNMEMPIKE\x120\n\x0bNMBJMLJCPIA\
    \x18\x03\x20\x01(\x0b2\x0c.PLJNHEIJAMOH\0R\x0bNMBJMLJCPIA\x120\n\x0bNICH\
    FNCLGJP\x18\x0f\x20\x01(\x0b2\x0c.DEBGLDCAGPFH\0R\x0bNICHFNCLGJP\x120\n\
    \x0bJMJHMMJIFKP\x18\x02\x20\x01(\x0b2\x0c.KHCOKINAOFIH\0R\x0bJMJHMMJIFKP\
    \x120\n\x0bLFAKCJHMBAM\x18\x05\x20\x01(\x0b2\x0c.OGMAENLBCDCH\0R\x0bLFAK\
    CJHMBAM\x120\n\x0bHKJNIIEKEDC\x18\x01\x20\x01(\x0b2\x0c.FEOJMHIFPCHH\0R\
    \x0bHKJNIIEKEDC\x120\n\x0bIDJGHDKAOOD\x18\r\x20\x01(\x0b2\x0c.NEJFJFCOOK\
    AH\0R\x0bIDJGHDKAOOD\x12L\n\x1bPUNK_LORD_SHARE_TYPE_FRIEND\x18\x06\x20\
    \x01(\x0b2\x0c.BGBJAPLADOJH\0R\x17PUNKLORDSHARETYPEFRIEND\x120\n\x0bGMLK\
    LJENNEK\x18\x04\x20\x01(\x0b2\x0c.JMCHKIMAKHMH\0R\x0bGMLKLJENNEK\x120\n\
    \x0bNFCHNCHHKEA\x18\x0c\x20\x01(\x0b2\x0c.OIDIHJNBMCKH\0R\x0bNFCHNCHHKEA\
    B\r\n\x0bEMKBLDJJLKKb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(8);
            deps.push(super::BGBJAPLADOJ::file_descriptor().clone());
            deps.push(super::DEBGLDCAGPF::file_descriptor().clone());
            deps.push(super::FEOJMHIFPCH::file_descriptor().clone());
            deps.push(super::JMCHKIMAKHM::file_descriptor().clone());
            deps.push(super::KHCOKINAOFI::file_descriptor().clone());
            deps.push(super::NEJFJFCOOKA::file_descriptor().clone());
            deps.push(super::OGMAENLBCDC::file_descriptor().clone());
            deps.push(super::PLJNHEIJAMO::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(2);
            messages.push(OIDIHJNBMCK::generated_message_descriptor_data());
            messages.push(ADNEJCJKBNF::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
