// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `KBEDBHCIFHD.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:KBEDBHCIFHD)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KBEDBHCIFHD {
    // message oneof groups
    pub MILGCPJOMGE: ::std::option::Option<kbedbhcifhd::MILGCPJOMGE>,
    // special fields
    // @@protoc_insertion_point(special_field:KBEDBHCIFHD.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KBEDBHCIFHD {
    fn default() -> &'a KBEDBHCIFHD {
        <KBEDBHCIFHD as ::protobuf::Message>::default_instance()
    }
}

impl KBEDBHCIFHD {
    pub fn new() -> KBEDBHCIFHD {
        ::std::default::Default::default()
    }

    // .IAMPEBBEGFH ABKOHABEMMF = 9;

    pub fn ABKOHABEMMF(&self) -> &super::IAMPEBBEGFH::IAMPEBBEGFH {
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::ABKOHABEMMF(ref v)) => v,
            _ => <super::IAMPEBBEGFH::IAMPEBBEGFH as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ABKOHABEMMF(&mut self) {
        self.MILGCPJOMGE = ::std::option::Option::None;
    }

    pub fn has_ABKOHABEMMF(&self) -> bool {
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::ABKOHABEMMF(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ABKOHABEMMF(&mut self, v: super::IAMPEBBEGFH::IAMPEBBEGFH) {
        self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::ABKOHABEMMF(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ABKOHABEMMF(&mut self) -> &mut super::IAMPEBBEGFH::IAMPEBBEGFH {
        if let ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::ABKOHABEMMF(_)) = self.MILGCPJOMGE {
        } else {
            self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::ABKOHABEMMF(super::IAMPEBBEGFH::IAMPEBBEGFH::new()));
        }
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::ABKOHABEMMF(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ABKOHABEMMF(&mut self) -> super::IAMPEBBEGFH::IAMPEBBEGFH {
        if self.has_ABKOHABEMMF() {
            match self.MILGCPJOMGE.take() {
                ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::ABKOHABEMMF(v)) => v,
                _ => panic!(),
            }
        } else {
            super::IAMPEBBEGFH::IAMPEBBEGFH::new()
        }
    }

    // .HMECPBPGDJF CKDFADABICO = 13;

    pub fn CKDFADABICO(&self) -> &super::HMECPBPGDJF::HMECPBPGDJF {
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::CKDFADABICO(ref v)) => v,
            _ => <super::HMECPBPGDJF::HMECPBPGDJF as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_CKDFADABICO(&mut self) {
        self.MILGCPJOMGE = ::std::option::Option::None;
    }

    pub fn has_CKDFADABICO(&self) -> bool {
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::CKDFADABICO(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_CKDFADABICO(&mut self, v: super::HMECPBPGDJF::HMECPBPGDJF) {
        self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::CKDFADABICO(v))
    }

    // Mutable pointer to the field.
    pub fn mut_CKDFADABICO(&mut self) -> &mut super::HMECPBPGDJF::HMECPBPGDJF {
        if let ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::CKDFADABICO(_)) = self.MILGCPJOMGE {
        } else {
            self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::CKDFADABICO(super::HMECPBPGDJF::HMECPBPGDJF::new()));
        }
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::CKDFADABICO(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_CKDFADABICO(&mut self) -> super::HMECPBPGDJF::HMECPBPGDJF {
        if self.has_CKDFADABICO() {
            match self.MILGCPJOMGE.take() {
                ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::CKDFADABICO(v)) => v,
                _ => panic!(),
            }
        } else {
            super::HMECPBPGDJF::HMECPBPGDJF::new()
        }
    }

    // .JBGGHPCNBME PFPBPHHIINB = 1;

    pub fn PFPBPHHIINB(&self) -> &super::JBGGHPCNBME::JBGGHPCNBME {
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::PFPBPHHIINB(ref v)) => v,
            _ => <super::JBGGHPCNBME::JBGGHPCNBME as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_PFPBPHHIINB(&mut self) {
        self.MILGCPJOMGE = ::std::option::Option::None;
    }

    pub fn has_PFPBPHHIINB(&self) -> bool {
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::PFPBPHHIINB(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_PFPBPHHIINB(&mut self, v: super::JBGGHPCNBME::JBGGHPCNBME) {
        self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::PFPBPHHIINB(v))
    }

    // Mutable pointer to the field.
    pub fn mut_PFPBPHHIINB(&mut self) -> &mut super::JBGGHPCNBME::JBGGHPCNBME {
        if let ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::PFPBPHHIINB(_)) = self.MILGCPJOMGE {
        } else {
            self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::PFPBPHHIINB(super::JBGGHPCNBME::JBGGHPCNBME::new()));
        }
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::PFPBPHHIINB(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_PFPBPHHIINB(&mut self) -> super::JBGGHPCNBME::JBGGHPCNBME {
        if self.has_PFPBPHHIINB() {
            match self.MILGCPJOMGE.take() {
                ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::PFPBPHHIINB(v)) => v,
                _ => panic!(),
            }
        } else {
            super::JBGGHPCNBME::JBGGHPCNBME::new()
        }
    }

    // .LDHDKNBOKNE DAKOPHLKOGK = 4;

    pub fn DAKOPHLKOGK(&self) -> &super::LDHDKNBOKNE::LDHDKNBOKNE {
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::DAKOPHLKOGK(ref v)) => v,
            _ => <super::LDHDKNBOKNE::LDHDKNBOKNE as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_DAKOPHLKOGK(&mut self) {
        self.MILGCPJOMGE = ::std::option::Option::None;
    }

    pub fn has_DAKOPHLKOGK(&self) -> bool {
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::DAKOPHLKOGK(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_DAKOPHLKOGK(&mut self, v: super::LDHDKNBOKNE::LDHDKNBOKNE) {
        self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::DAKOPHLKOGK(v))
    }

    // Mutable pointer to the field.
    pub fn mut_DAKOPHLKOGK(&mut self) -> &mut super::LDHDKNBOKNE::LDHDKNBOKNE {
        if let ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::DAKOPHLKOGK(_)) = self.MILGCPJOMGE {
        } else {
            self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::DAKOPHLKOGK(super::LDHDKNBOKNE::LDHDKNBOKNE::new()));
        }
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::DAKOPHLKOGK(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_DAKOPHLKOGK(&mut self) -> super::LDHDKNBOKNE::LDHDKNBOKNE {
        if self.has_DAKOPHLKOGK() {
            match self.MILGCPJOMGE.take() {
                ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::DAKOPHLKOGK(v)) => v,
                _ => panic!(),
            }
        } else {
            super::LDHDKNBOKNE::LDHDKNBOKNE::new()
        }
    }

    // .EDCHHLDIOAH NBLBECMLILO = 14;

    pub fn NBLBECMLILO(&self) -> &super::EDCHHLDIOAH::EDCHHLDIOAH {
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::NBLBECMLILO(ref v)) => v,
            _ => <super::EDCHHLDIOAH::EDCHHLDIOAH as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_NBLBECMLILO(&mut self) {
        self.MILGCPJOMGE = ::std::option::Option::None;
    }

    pub fn has_NBLBECMLILO(&self) -> bool {
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::NBLBECMLILO(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_NBLBECMLILO(&mut self, v: super::EDCHHLDIOAH::EDCHHLDIOAH) {
        self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::NBLBECMLILO(v))
    }

    // Mutable pointer to the field.
    pub fn mut_NBLBECMLILO(&mut self) -> &mut super::EDCHHLDIOAH::EDCHHLDIOAH {
        if let ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::NBLBECMLILO(_)) = self.MILGCPJOMGE {
        } else {
            self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::NBLBECMLILO(super::EDCHHLDIOAH::EDCHHLDIOAH::new()));
        }
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::NBLBECMLILO(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_NBLBECMLILO(&mut self) -> super::EDCHHLDIOAH::EDCHHLDIOAH {
        if self.has_NBLBECMLILO() {
            match self.MILGCPJOMGE.take() {
                ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::NBLBECMLILO(v)) => v,
                _ => panic!(),
            }
        } else {
            super::EDCHHLDIOAH::EDCHHLDIOAH::new()
        }
    }

    // .AIFIGGICMNC CHMELADEMMM = 15;

    pub fn CHMELADEMMM(&self) -> &super::AIFIGGICMNC::AIFIGGICMNC {
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::CHMELADEMMM(ref v)) => v,
            _ => <super::AIFIGGICMNC::AIFIGGICMNC as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_CHMELADEMMM(&mut self) {
        self.MILGCPJOMGE = ::std::option::Option::None;
    }

    pub fn has_CHMELADEMMM(&self) -> bool {
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::CHMELADEMMM(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_CHMELADEMMM(&mut self, v: super::AIFIGGICMNC::AIFIGGICMNC) {
        self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::CHMELADEMMM(v))
    }

    // Mutable pointer to the field.
    pub fn mut_CHMELADEMMM(&mut self) -> &mut super::AIFIGGICMNC::AIFIGGICMNC {
        if let ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::CHMELADEMMM(_)) = self.MILGCPJOMGE {
        } else {
            self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::CHMELADEMMM(super::AIFIGGICMNC::AIFIGGICMNC::new()));
        }
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::CHMELADEMMM(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_CHMELADEMMM(&mut self) -> super::AIFIGGICMNC::AIFIGGICMNC {
        if self.has_CHMELADEMMM() {
            match self.MILGCPJOMGE.take() {
                ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::CHMELADEMMM(v)) => v,
                _ => panic!(),
            }
        } else {
            super::AIFIGGICMNC::AIFIGGICMNC::new()
        }
    }

    // .HDFLAEHAEGO MOGLLMLEMIP = 7;

    pub fn MOGLLMLEMIP(&self) -> &super::HDFLAEHAEGO::HDFLAEHAEGO {
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::MOGLLMLEMIP(ref v)) => v,
            _ => <super::HDFLAEHAEGO::HDFLAEHAEGO as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_MOGLLMLEMIP(&mut self) {
        self.MILGCPJOMGE = ::std::option::Option::None;
    }

    pub fn has_MOGLLMLEMIP(&self) -> bool {
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::MOGLLMLEMIP(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_MOGLLMLEMIP(&mut self, v: super::HDFLAEHAEGO::HDFLAEHAEGO) {
        self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::MOGLLMLEMIP(v))
    }

    // Mutable pointer to the field.
    pub fn mut_MOGLLMLEMIP(&mut self) -> &mut super::HDFLAEHAEGO::HDFLAEHAEGO {
        if let ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::MOGLLMLEMIP(_)) = self.MILGCPJOMGE {
        } else {
            self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::MOGLLMLEMIP(super::HDFLAEHAEGO::HDFLAEHAEGO::new()));
        }
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::MOGLLMLEMIP(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_MOGLLMLEMIP(&mut self) -> super::HDFLAEHAEGO::HDFLAEHAEGO {
        if self.has_MOGLLMLEMIP() {
            match self.MILGCPJOMGE.take() {
                ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::MOGLLMLEMIP(v)) => v,
                _ => panic!(),
            }
        } else {
            super::HDFLAEHAEGO::HDFLAEHAEGO::new()
        }
    }

    // .BHFKPPKCIIK DAGLMONMMMH = 8;

    pub fn DAGLMONMMMH(&self) -> &super::BHFKPPKCIIK::BHFKPPKCIIK {
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::DAGLMONMMMH(ref v)) => v,
            _ => <super::BHFKPPKCIIK::BHFKPPKCIIK as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_DAGLMONMMMH(&mut self) {
        self.MILGCPJOMGE = ::std::option::Option::None;
    }

    pub fn has_DAGLMONMMMH(&self) -> bool {
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::DAGLMONMMMH(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_DAGLMONMMMH(&mut self, v: super::BHFKPPKCIIK::BHFKPPKCIIK) {
        self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::DAGLMONMMMH(v))
    }

    // Mutable pointer to the field.
    pub fn mut_DAGLMONMMMH(&mut self) -> &mut super::BHFKPPKCIIK::BHFKPPKCIIK {
        if let ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::DAGLMONMMMH(_)) = self.MILGCPJOMGE {
        } else {
            self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::DAGLMONMMMH(super::BHFKPPKCIIK::BHFKPPKCIIK::new()));
        }
        match self.MILGCPJOMGE {
            ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::DAGLMONMMMH(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_DAGLMONMMMH(&mut self) -> super::BHFKPPKCIIK::BHFKPPKCIIK {
        if self.has_DAGLMONMMMH() {
            match self.MILGCPJOMGE.take() {
                ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::DAGLMONMMMH(v)) => v,
                _ => panic!(),
            }
        } else {
            super::BHFKPPKCIIK::BHFKPPKCIIK::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::IAMPEBBEGFH::IAMPEBBEGFH>(
            "ABKOHABEMMF",
            KBEDBHCIFHD::has_ABKOHABEMMF,
            KBEDBHCIFHD::ABKOHABEMMF,
            KBEDBHCIFHD::mut_ABKOHABEMMF,
            KBEDBHCIFHD::set_ABKOHABEMMF,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::HMECPBPGDJF::HMECPBPGDJF>(
            "CKDFADABICO",
            KBEDBHCIFHD::has_CKDFADABICO,
            KBEDBHCIFHD::CKDFADABICO,
            KBEDBHCIFHD::mut_CKDFADABICO,
            KBEDBHCIFHD::set_CKDFADABICO,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::JBGGHPCNBME::JBGGHPCNBME>(
            "PFPBPHHIINB",
            KBEDBHCIFHD::has_PFPBPHHIINB,
            KBEDBHCIFHD::PFPBPHHIINB,
            KBEDBHCIFHD::mut_PFPBPHHIINB,
            KBEDBHCIFHD::set_PFPBPHHIINB,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::LDHDKNBOKNE::LDHDKNBOKNE>(
            "DAKOPHLKOGK",
            KBEDBHCIFHD::has_DAKOPHLKOGK,
            KBEDBHCIFHD::DAKOPHLKOGK,
            KBEDBHCIFHD::mut_DAKOPHLKOGK,
            KBEDBHCIFHD::set_DAKOPHLKOGK,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::EDCHHLDIOAH::EDCHHLDIOAH>(
            "NBLBECMLILO",
            KBEDBHCIFHD::has_NBLBECMLILO,
            KBEDBHCIFHD::NBLBECMLILO,
            KBEDBHCIFHD::mut_NBLBECMLILO,
            KBEDBHCIFHD::set_NBLBECMLILO,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::AIFIGGICMNC::AIFIGGICMNC>(
            "CHMELADEMMM",
            KBEDBHCIFHD::has_CHMELADEMMM,
            KBEDBHCIFHD::CHMELADEMMM,
            KBEDBHCIFHD::mut_CHMELADEMMM,
            KBEDBHCIFHD::set_CHMELADEMMM,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::HDFLAEHAEGO::HDFLAEHAEGO>(
            "MOGLLMLEMIP",
            KBEDBHCIFHD::has_MOGLLMLEMIP,
            KBEDBHCIFHD::MOGLLMLEMIP,
            KBEDBHCIFHD::mut_MOGLLMLEMIP,
            KBEDBHCIFHD::set_MOGLLMLEMIP,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::BHFKPPKCIIK::BHFKPPKCIIK>(
            "DAGLMONMMMH",
            KBEDBHCIFHD::has_DAGLMONMMMH,
            KBEDBHCIFHD::DAGLMONMMMH,
            KBEDBHCIFHD::mut_DAGLMONMMMH,
            KBEDBHCIFHD::set_DAGLMONMMMH,
        ));
        oneofs.push(kbedbhcifhd::MILGCPJOMGE::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KBEDBHCIFHD>(
            "KBEDBHCIFHD",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KBEDBHCIFHD {
    const NAME: &'static str = "KBEDBHCIFHD";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                74 => {
                    self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::ABKOHABEMMF(is.read_message()?));
                },
                106 => {
                    self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::CKDFADABICO(is.read_message()?));
                },
                10 => {
                    self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::PFPBPHHIINB(is.read_message()?));
                },
                34 => {
                    self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::DAKOPHLKOGK(is.read_message()?));
                },
                114 => {
                    self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::NBLBECMLILO(is.read_message()?));
                },
                122 => {
                    self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::CHMELADEMMM(is.read_message()?));
                },
                58 => {
                    self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::MOGLLMLEMIP(is.read_message()?));
                },
                66 => {
                    self.MILGCPJOMGE = ::std::option::Option::Some(kbedbhcifhd::MILGCPJOMGE::DAGLMONMMMH(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.MILGCPJOMGE {
            match v {
                &kbedbhcifhd::MILGCPJOMGE::ABKOHABEMMF(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &kbedbhcifhd::MILGCPJOMGE::CKDFADABICO(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &kbedbhcifhd::MILGCPJOMGE::PFPBPHHIINB(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &kbedbhcifhd::MILGCPJOMGE::DAKOPHLKOGK(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &kbedbhcifhd::MILGCPJOMGE::NBLBECMLILO(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &kbedbhcifhd::MILGCPJOMGE::CHMELADEMMM(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &kbedbhcifhd::MILGCPJOMGE::MOGLLMLEMIP(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &kbedbhcifhd::MILGCPJOMGE::DAGLMONMMMH(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.MILGCPJOMGE {
            match v {
                &kbedbhcifhd::MILGCPJOMGE::ABKOHABEMMF(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &kbedbhcifhd::MILGCPJOMGE::CKDFADABICO(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &kbedbhcifhd::MILGCPJOMGE::PFPBPHHIINB(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &kbedbhcifhd::MILGCPJOMGE::DAKOPHLKOGK(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &kbedbhcifhd::MILGCPJOMGE::NBLBECMLILO(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &kbedbhcifhd::MILGCPJOMGE::CHMELADEMMM(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &kbedbhcifhd::MILGCPJOMGE::MOGLLMLEMIP(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &kbedbhcifhd::MILGCPJOMGE::DAGLMONMMMH(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KBEDBHCIFHD {
        KBEDBHCIFHD::new()
    }

    fn clear(&mut self) {
        self.MILGCPJOMGE = ::std::option::Option::None;
        self.MILGCPJOMGE = ::std::option::Option::None;
        self.MILGCPJOMGE = ::std::option::Option::None;
        self.MILGCPJOMGE = ::std::option::Option::None;
        self.MILGCPJOMGE = ::std::option::Option::None;
        self.MILGCPJOMGE = ::std::option::Option::None;
        self.MILGCPJOMGE = ::std::option::Option::None;
        self.MILGCPJOMGE = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KBEDBHCIFHD {
        static instance: KBEDBHCIFHD = KBEDBHCIFHD {
            MILGCPJOMGE: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KBEDBHCIFHD {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KBEDBHCIFHD").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KBEDBHCIFHD {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KBEDBHCIFHD {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `KBEDBHCIFHD`
pub mod kbedbhcifhd {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:KBEDBHCIFHD.MILGCPJOMGE)
    pub enum MILGCPJOMGE {
        // @@protoc_insertion_point(oneof_field:KBEDBHCIFHD.ABKOHABEMMF)
        ABKOHABEMMF(super::super::IAMPEBBEGFH::IAMPEBBEGFH),
        // @@protoc_insertion_point(oneof_field:KBEDBHCIFHD.CKDFADABICO)
        CKDFADABICO(super::super::HMECPBPGDJF::HMECPBPGDJF),
        // @@protoc_insertion_point(oneof_field:KBEDBHCIFHD.PFPBPHHIINB)
        PFPBPHHIINB(super::super::JBGGHPCNBME::JBGGHPCNBME),
        // @@protoc_insertion_point(oneof_field:KBEDBHCIFHD.DAKOPHLKOGK)
        DAKOPHLKOGK(super::super::LDHDKNBOKNE::LDHDKNBOKNE),
        // @@protoc_insertion_point(oneof_field:KBEDBHCIFHD.NBLBECMLILO)
        NBLBECMLILO(super::super::EDCHHLDIOAH::EDCHHLDIOAH),
        // @@protoc_insertion_point(oneof_field:KBEDBHCIFHD.CHMELADEMMM)
        CHMELADEMMM(super::super::AIFIGGICMNC::AIFIGGICMNC),
        // @@protoc_insertion_point(oneof_field:KBEDBHCIFHD.MOGLLMLEMIP)
        MOGLLMLEMIP(super::super::HDFLAEHAEGO::HDFLAEHAEGO),
        // @@protoc_insertion_point(oneof_field:KBEDBHCIFHD.DAGLMONMMMH)
        DAGLMONMMMH(super::super::BHFKPPKCIIK::BHFKPPKCIIK),
    }

    impl ::protobuf::Oneof for MILGCPJOMGE {
    }

    impl ::protobuf::OneofFull for MILGCPJOMGE {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::KBEDBHCIFHD as ::protobuf::MessageFull>::descriptor().oneof_by_name("MILGCPJOMGE").unwrap()).clone()
        }
    }

    impl MILGCPJOMGE {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<MILGCPJOMGE>("MILGCPJOMGE")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11KBEDBHCIFHD.proto\x1a\x11AIFIGGICMNC.proto\x1a\x11BHFKPPKCIIK.prot\
    o\x1a\x11EDCHHLDIOAH.proto\x1a\x11HDFLAEHAEGO.proto\x1a\x11HMECPBPGDJF.p\
    roto\x1a\x11IAMPEBBEGFH.proto\x1a\x11JBGGHPCNBME.proto\x1a\x11LDHDKNBOKN\
    E.proto\"\xac\x03\n\x0bKBEDBHCIFHD\x120\n\x0bABKOHABEMMF\x18\t\x20\x01(\
    \x0b2\x0c.IAMPEBBEGFHH\0R\x0bABKOHABEMMF\x120\n\x0bCKDFADABICO\x18\r\x20\
    \x01(\x0b2\x0c.HMECPBPGDJFH\0R\x0bCKDFADABICO\x120\n\x0bPFPBPHHIINB\x18\
    \x01\x20\x01(\x0b2\x0c.JBGGHPCNBMEH\0R\x0bPFPBPHHIINB\x120\n\x0bDAKOPHLK\
    OGK\x18\x04\x20\x01(\x0b2\x0c.LDHDKNBOKNEH\0R\x0bDAKOPHLKOGK\x120\n\x0bN\
    BLBECMLILO\x18\x0e\x20\x01(\x0b2\x0c.EDCHHLDIOAHH\0R\x0bNBLBECMLILO\x120\
    \n\x0bCHMELADEMMM\x18\x0f\x20\x01(\x0b2\x0c.AIFIGGICMNCH\0R\x0bCHMELADEM\
    MM\x120\n\x0bMOGLLMLEMIP\x18\x07\x20\x01(\x0b2\x0c.HDFLAEHAEGOH\0R\x0bMO\
    GLLMLEMIP\x120\n\x0bDAGLMONMMMH\x18\x08\x20\x01(\x0b2\x0c.BHFKPPKCIIKH\0\
    R\x0bDAGLMONMMMHB\r\n\x0bMILGCPJOMGEb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(8);
            deps.push(super::AIFIGGICMNC::file_descriptor().clone());
            deps.push(super::BHFKPPKCIIK::file_descriptor().clone());
            deps.push(super::EDCHHLDIOAH::file_descriptor().clone());
            deps.push(super::HDFLAEHAEGO::file_descriptor().clone());
            deps.push(super::HMECPBPGDJF::file_descriptor().clone());
            deps.push(super::IAMPEBBEGFH::file_descriptor().clone());
            deps.push(super::JBGGHPCNBME::file_descriptor().clone());
            deps.push(super::LDHDKNBOKNE::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(1);
            messages.push(KBEDBHCIFHD::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
